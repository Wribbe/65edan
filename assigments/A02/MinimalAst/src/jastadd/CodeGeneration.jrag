import java.util.Arrays;

aspect CodeGeneration {

    class NewlineStringBuilder {

        private StringBuilder sb;

        public NewlineStringBuilder() {
            sb = new StringBuilder();
        }

        public void newline() {
            sb.append('\n');
        }

        public void append(String string) {
            sb.append(string);
            newline();
        }

        public boolean isEmpty() {
            return sb.length() == 0;
        }

        public String toString() {
            if (!isEmpty()) {
                sb.deleteCharAt(sb.length()-1);
            }
            return sb.toString();
        }
    }

    public void Program.genCode(PrintStream out) {
        out.println(".global _start");
        out.println(".data");
        out.println("buf: .skip 1024");
        out.println(".text");
        out.println("_start:");
        out.println("call main");

        for(FunctionDeclaration declaration : getFunctionDeclarationList()) {
            declaration.genCode(out);
        }

        out.println(getHelpers());
    }

    public String ASTNode.getCode() { return ""; }

    public void ASTNode.genCode(PrintStream out) {
        out.println(getCode());
    }

    public void FunctionDeclaration.genCode(PrintStream out) {
        out.println("# start of "+name()+" function.");
        out.println(name()+": # function label");
        for(Statement statement : getBlockList()) {
            statement.genCode(out);
        }
        getReturn().genCode(out);
    }



    public String Numeral.getCode() {
        return "    movq $"+getNUMERAL()+", %rax # Store literal number "+getNUMERAL()+" in %rax.";
    }

    public String FunctionStatement.getCode() {
        return getFunctionUse().getCode();
    }

    public int ASTNode.range(int numArguments) {
        return 8*numArguments;
    }

    public String FunctionUse.getCode() {
        String functionName = getIdUse().getID();
        NewlineStringBuilder sb = new NewlineStringBuilder();
        for(int i=getNumExpression()-1; i>-1; i--) {
            Expression expression = getExpression(i);
            sb.append(expression.getCode());
            sb.append("    pushq %rax");
        }
        sb.append("    call "+functionName);
        int numArguments = getNumExpression();
        if (numArguments > 0) {
            sb.append("    addq $"+range(numArguments)+", %rsp # clear variables off stack.");
        }
        return sb.toString();
    }

    public String IdDeclare.getCode() {
        return getID();
    }

    public String Return.getCode() {
        NewlineStringBuilder sb = new NewlineStringBuilder();
        sb.append("    # Evaluate return expression.");
        sb.append(getExpression().getCode());
        sb.append("    # start return statement");
        sb.append("    movq %rax, %rdi # set return code to result.");
        String functionName = enclosingFunction().name();
        if (functionName.equals("main")) {
            sb.append("    movq $60, %rax # sys_exit");
            sb.append("    syscall");
        } else {
            sb.append("    ret");
        }
        return sb.toString();
    }

    public String Add.getCode() {

        NewlineStringBuilder sb = new NewlineStringBuilder();
        String left = getLeft().getCode();
        sb.append(left);
        sb.append("    pushq %rax # Pushing left var of Add to stack.");
        String right = getRight().getCode();
        sb.append(right);
        sb.append("    addq (%rsp), %rax # Operation: stack Add %rax.");
        sb.append("    addq $"+range(1)+", %rsp # Popping temp variable from stack.");
        return sb.toString();

    }

    public String Mul.getCode() {

        NewlineStringBuilder sb = new NewlineStringBuilder();
        String left = getLeft().getCode();
        sb.append(left);
        sb.append("    pushq %rax # Pushing left var of Mul to stack.");
        String right = getRight().getCode();
        sb.append(right);
        sb.append("    imulq (%rsp), %rax # Operation: stack Mul %rax.");
        sb.append("    addq $"+range(1)+", %rsp # Popping temp variable from stack.");
        return sb.toString();

    }

    public String Div.getCode() {

        NewlineStringBuilder sb = new NewlineStringBuilder();
        String left = getLeft().getCode();
        sb.append(left);
        sb.append("    pushq %rax # Pushing left var (dividend) of Div to stack.");
        String right = getRight().getCode();
        sb.append(right);
        // Shuffle it around a bit.
        sb.append("    pushq %rax # Pushing right var (divisor) of Div to stack.");
        sb.append("    movq "+range(1)+"(%rsp), %rax # Writing second var on stack (dividend) to %rax.");
        sb.append("    idivq (%rsp) # Operation: Divide dividend (%rsa) with divisor (first in stack), result in %rsa.");
        sb.append("    addq $"+range(2)+", %rsp # Pop two temp variables.");
        return sb.toString();

    }

    public String Minus.getCode() {

        NewlineStringBuilder sb = new NewlineStringBuilder();
        String left = getLeft().getCode();
        sb.append(left);
        sb.append("    pushq %rax # Pushing left positive var of Minus to stack.");
        String right = getRight().getCode();
        sb.append(right);
        sb.append("    pushq %rax # Pushing right negative var of Minus to stack.");
        sb.append("    movq "+range(1)+"(%rsp), %rax # Writing second/negative var to %rax.");
        sb.append("    subq (%rsp), %rax # Operation: stack Minus %rax -> %rax.");
        sb.append("    addq $"+range(2)+", %rsp # Pop two temp variables.");
        return sb.toString();

    }


    /** Boolean expressions */
    /*----------------------*/

    public String Expression.generateConditionalJump(String label) {
        return "";
    }

    public class AssemblyGobbler {


        // String buffers.
        private ArrayList<String> sectionBuffer;
        private ArrayList<String> commentBuffer;

        // Variable mappings.
        private Map<String, String> variables;

        // Final string.
        String formattedAssembler = "";


        // Public constructor.
        public AssemblyGobbler(Map<String, String> variables, String[] rawAssembler) {

            this.variables = variables;

            sectionBuffer = new ArrayList<String>();
            commentBuffer = new ArrayList<String>();

            int maxLength = varSubInSection(rawAssembler);
            formattedAssembler = reassembleSectionWithPadding(maxLength);
        }

        public String toString() {
            return formattedAssembler;
        }

        // Var-substitution for a single word.
        private String varSub(String word) {
            if (word.contains("!{")) {
                ArrayList<String> varSubTokens = varExtraction(word);
                for (String key : varSubTokens) {
                    String varSubMask = "!{"+key+"}";
                    String value = variables.get(key);
                    if (value == null) {
                        value = key+" == NULL";
                    }
                    word = word.replace(varSubMask, value);
                }
            }
            return word;
        }

        // Extract the variable name from the word.
        private ArrayList<String> varExtraction(String word) {

            ArrayList<String> allVariables = new ArrayList<String>();

            StringBuilder buffer = new StringBuilder();
            StringBuilder var = new StringBuilder();

            boolean inVar = false;

            String start = "!{";
            String stop = "}";
            String window = "";

            int windowSize = start.length();


            int bufferSize = 0;
            for (int current=0; current<word.length(); current++) {
                char currentChar = word.charAt(current);
                buffer.append(currentChar);
                bufferSize++;
                if (bufferSize < windowSize) {
                    continue; // Need be at least windowSize.
                }
                window = buffer.substring(bufferSize-windowSize, bufferSize);
                if (window.equals(start)) {
                    inVar = true;
                    continue; // Don't append the '{'.
                } else if (window.endsWith(stop) && inVar) {
                    inVar = false;
                    allVariables.add(var.toString());
                    var = new StringBuilder();
                }
                if (inVar) {
                    var.append(currentChar);
                }
            }
            return allVariables;
        }

        // Var-substitution for a row.
        private String varSubInRow(String assemblerRow) {

            StringBuilder rowBuilder = new StringBuilder();
            // Iterate over all words in assemblerRow and substitute.
            for (String word : assemblerRow.split(" ")) {
                rowBuilder.append(varSub(word));
                rowBuilder.append(" ");
            }
            return rowBuilder.toString();
        }

        // Var-substitution for a section.
        private int varSubInSection(String[] assemblerSection) {

            // Maximum line length for assembler lines.
            int maxLineLength = 0;

            // Cut of first element.
            String[] subarray = Arrays.copyOfRange(assemblerSection,
                                                   1,
                                                   assemblerSection.length);

            // Iterate over all rows in subarray and substitute.
            for (String row : subarray) {

                String subRow = varSubInRow(row);

                String[] rowTokens = subRow.trim().split("#");
                String assemblerRow = rowTokens[0].trim();

                String comment = "";
                if (rowTokens.length > 1) {
                    comment = rowTokens[1].trim();
                }

                // Add comment to buffer.
                commentBuffer.add(varSubInRow(comment));

                if (assemblerRow.length() > maxLineLength) {
                    maxLineLength = assemblerRow.length();
                }

                // Add assembler to buffer.
                sectionBuffer.add(assemblerRow);
            }

            // Return maximum assembler line length.
            return maxLineLength;
        }

        //  Section reassembling with comment alignment.
        private String reassembleSectionWithPadding(int maxLineLength) {

            NewlineStringBuilder finalSectionBuilder = new NewlineStringBuilder();

            for (int i=0; i<sectionBuffer.size(); i++) {
                StringBuilder finalRowBuilder = new StringBuilder();
                // Append substituted assembler code.
                String assemblyCode = sectionBuffer.get(i);
                finalRowBuilder.append("    "+assemblyCode);

                // Fetch comment.
                String comment = commentBuffer.get(i);

                // Is there a comment?.
                if (!(comment.replace(" ","").length() == 0)) {
                    // Append appropriate whitespace.
                    for (int j=0; j<(maxLineLength-assemblyCode.length()+4); j++) {
                        finalRowBuilder.append(" ");
                    }
                    // Append comment.
                    finalRowBuilder.append("# "+comment);
                }
                finalSectionBuilder.append(finalRowBuilder.toString());
            }

            return finalSectionBuilder.toString();
        }
    }


    public class ConditionalSubset {

        // Private subclasses.
        private Expression exp;
        private String type;

        // Variable mappings.
        private Map<String, String> variables;

        // Raw Assembler code with variables.
        String[] assembler = {"",
            "!{left}",
            "pushq %rax                     # Pushing left var of !{type} to stack.",
            "!{right}",
            "pushq %rax                     # Pushing right var to stack.",
            "movq !{range1}(%rsp), %rax     # Writing second var on stack to %rax.",
            "cmpq (%rsp), %rax              # Comparing first value in stack with %rax.",
            "!{jumpType} !{label}           # If true jump to !{label}.",
            "addq $!{range2}, %rsp          # Pop two temp variables of the stack."};

        // Final formatted assembler code.
        String finalAssembler = "";

        // Constructor.
        public ConditionalSubset(BinaryExpression exp, String type, String label, String jumpType) {

            this.exp = exp;

            variables = new HashMap<String, String>();
            variables.put("type", type);
            variables.put("left", exp.getLeft().getCode());
            variables.put("right", exp.getRight().getCode());
            variables.put("range1", ""+exp.range(1));
            variables.put("range2", ""+exp.range(2));
            variables.put("jumpType", jumpType);
            variables.put("label", label);

            finalAssembler = new AssemblyGobbler(variables, assembler).toString();
        }

        public String toString() {
            return finalAssembler;
        }

    }

    public String NOEQ.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "NOEQ", label, "jne");
        return cs.toString();
    }

    public String EQ.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "EQ", label, "je");
        return cs.toString();
    }

    public String LTEQ.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "LTEQ", label, "jle");
        return cs.toString();
    }

    public String GTEQ.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "GTEQ", label, "jge");
        return cs.toString();
    }

    public String LT.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "LT", label, "jl");
        return cs.toString();
    }

    public String GT.generateConditionalJump(String label) {
        ConditionalSubset cs = new ConditionalSubset(this, "GT", label, "jg");
        return cs.toString();
    }

    /** IF/ELSE/WHEN */
    /*----------------*/

    inh String Statement.uniqueLabel();

    private HashMap<String, Integer> Program.labelMap = new HashMap<String, Integer>();
    eq Program.getFunctionDeclaration(int index).uniqueLabel() {
        FunctionDeclaration declaration = getFunctionDeclaration(index);
        String functionName = declaration.name();
        if (labelMap.get(functionName) == null) {
            labelMap.put(functionName, 0);
        }
        int currentIteration = labelMap.get(functionName);
        labelMap.put(functionName, currentIteration+1);
        return functionName+"_"+currentIteration;
    }

    public String IF.getCode() {
        NewlineStringBuilder sb = new NewlineStringBuilder();
        sb.append("    # Start of if statement.");
        // Set logic label.
        Expression logic = getLogic();
        String currentLabel = uniqueLabel();
        String if_label = "if_"+currentLabel;
        sb.append(logic.generateConditionalJump(if_label));
        if (hasELSE()) {
            sb.append("    # Start of else section.");
            for (Statement statement : getELSE().getBlockList()) {
                sb.append(statement.getCode());
            }
        }
        sb.append("    # Unconditional jump to end_"+currentLabel);
        sb.append("    jmp end_"+currentLabel);
        sb.append(if_label+":");
        for (Statement statement : getBlockList()) {
            sb.append(statement.getCode());
        }
        sb.append("end_"+currentLabel+":");
        return sb.toString();
    }

    public String WHILE.getCode() {
        NewlineStringBuilder sb = new NewlineStringBuilder();

        sb.append("    # Start of while statement.");
        Expression logic = getLogic();

        String currentLabel = uniqueLabel();
        String start_label = "while_start_"+currentLabel;
        String continue_label = "while_continue_"+currentLabel;
        String end_label = "while_end_"+currentLabel;

        sb.append(start_label+":");
        sb.append(logic.generateConditionalJump(continue_label));
        sb.append("    jmp "+end_label);
        sb.append(continue_label+":");
        for (Statement statement : getBlockList()) {
            sb.append(statement.getCode());
        }
        sb.append("    jmp "+start_label);
        sb.append(end_label+":");
        return sb.toString();
    }

    /**
     * Address of local variable variable in the current stack frame.
     */
    syn String IdDeclare.address() = "-"+(localIndex()*8)+"(%rbp)";

    /**
     * Local variable counting.
     */
    syn int ASTNode.numLocals() = lastNode().localIndex() - localIndex();

    /**
     * Local variable numbering.
     */
    syn int ASTNode.localIndex() = prevNode().localIndex();
    eq Program.localIndex() = 0;
    eq IdDeclare.localIndex() = prevNode().localIndex() + 1;

    inh ASTNode ASTNode.prevNode();
    eq ASTNode.getChild(int i).prevNode() = prevNode(i);
    syn ASTNode ASTNode.lastNode() = prevNode(getNumChild());
    syn ASTNode ASTNode.prevNode(int i) = i>0 ? getChild(i-1).lastNode() : this;

    public String Program.getHelpers() {
        return "######################################\n"
        +"####### Helper Methods ###############\n"
        +"######################################\n"
        +"# Procedure to print number to stdout\n"
        +"# C signature: void print(long int)\n"
        +"print:\n"
           +"    pushq %rbp\n"
           +"    movq %rsp, %rbp\n"
           +"    ### convert integer to string\n"
           +"    movq 16(%rbp), %rax\n"
           +"    # parameter\n"
           +"    movq $(buf+1023), %rsi # write ptr (start from end of buf)\n"
           +"    movb $0x0a, (%rsi)\n"
           +"    # insert newline\n"
           +"    movq $1, %rcx\n"
           +"    # string length\n"
        +"itoa_loop:\n"
           +"    # do.. while (at least one iteration)\n"
           +"    movq $10, %rbx\n"
           +"    movq $0, %rdx\n"
           +"    idivq %rbx\n"
           +"    # divide rdx:rax by 10\n"
           +"    addb $0x30, %dl\n"
           +"    # remainder + ’0’\n"
           +"    decq %rsi\n"
           +"    # move string pointer\n"
           +"    movb %dl, (%rsi)\n"
           +"    incq %rcx\n"
           +"    # increment string length\n"
           +"    cmpq $0, %rax\n"
           +"    jg itoa_loop\n"
           +"    # produce more digits\n"
        +"itoa_done:\n"
           +"    movq $1, %rdi\n"
           +"    movq %rcx, %rdx\n"
           +"    movq $1, %rax\n"
           +"    syscall\n"
           +"    popq %rbp\n"
           +"    ret\n"
        +"# Procedure to read number from stdin\n"
        +"# C signature: long int read(void)\n"
        +"read:\n"
           +"    pushq %rbp\n"
           +"    movq %rsp, %rbp\n"
           +"    movq $0, %rdi\n"
           +"    movq $buf, %rsi\n"
           +"    movq $1024, %rdx\n"
           +"    movq $0, %rax\n"
           +"    syscall\n"
           +"    # %rax = sys_read(0, buf, 1024)\n"
           +"    ### convert string to integer:\n"
           +"    ### %rax contains nchar\n"
           +"    ### %rsi contains ptr\n"
           +"    movq $0, %rdx\n"
           +"    # sum = 0\n"
        +"atoi_loop:\n"
           +"    cmpq $0, %rax\n"
           +"    # while (nchar > 0)\n"
           +"    jle atoi_done\n"
           +"    # leave loop if nchar <= 0\n"
           +"    movzbq (%rsi), %rbx\n"
           +"    # move byte, and sign extend to qword\n"
           +"    cmpq $0x30, %rbx\n"
           +"    # test if < ’0’\n"
           +"    jl atoi_done\n"
           +"    # character is not numeric\n"
           +"    cmpq $0x39, %rbx\n"
           +"    # test if > ’9’\n"
           +"    jg atoi_done\n"
           +"    # character is not numeric\n"
           +"    imulq $10, %rdx\n"
           +"    # multiply sum by 10\n"
           +"    subq $0x30, %rbx\n"
           +"    # value of character\n"
           +"    addq %rbx, %rdx\n"
           +"    # add to sum\n"
           +"    incq %rsi\n"
           +"    # step to next char\n"
           +"    decq %rax\n"
           +"    # nchar--\n"
           +"    jmp atoi_loop\n"
           +"    # loop back\n"
        +"atoi_done:\n"
           +"    movq %rdx, %rax\n"
           +"    # return value in RAX\n"
           +"    popq %rbp\n"
           +"    ret\n";
    }
}
