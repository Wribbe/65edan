%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
    static public void debug(String string) {
        System.out.println("[?] DEBUG: "+string);
    }
:};

// Type terminals.
%terminals ID, NUMERAL, INT;
// Arithmetic terminals.
%terminals PLUS, MUL, ASSIGN, DIV, MINUS, REM;
// Structural terminals.
%terminals LPAR, RPAR, LBRA, RBRA, SEMI, COMMA;
// Control logic terminals.
%terminals RETURN, IF, ELSE, WHILE;
// Logical operators.
%terminals NOEQ, EQ, LTEQ, GTEQ, LT, GT;

%typeof program = "Program";

%typeof expression = "Expression";
%typeof factor = "Expression";
%typeof term = "Expression";

%typeof function_declarations = "List";
%typeof function_declaration_parameters = "List";
%typeof function_use_parameters = "List";

%typeof expressions = "List";

%typeof function_declaration = "FunctionDeclaration";
%typeof block = "List";

%typeof non_assign_expression = "Expression";

%typeof id_use = "IdUse";
%typeof id_declare = "IdDeclare";

%typeof control_flow_statement = "Expression";
%typeof logic_expression = "LogicExpression";

%typeof else_statement = "ELSE";


%goal program;


program = function_declarations.functions {: return new Program(functions); :} ;


function_declarations =
    function_declaration.function {:
        return new List().add(function);
    :}
    | function_declarations.function_list function_declaration.function  {:
        return function_list.add(function);
    :}
    ;


function_declaration =
    id_declare.id LPAR function_declaration_parameters.fps RPAR block.block {:
        return new FunctionDeclaration(id, new Opt(fps), new Opt(block));
    :}
    ;


function_declaration_parameters =
    /* Epsilon */ {:
        return new List();
    :}
    | id_declare.id {:
        return new List().add(id);
    :}
    | function_declaration_parameters.list COMMA id_declare.id {:
        return list.add(id);
    :}
    ;


function_use =
    id_use.id LPAR function_use_parameters.funcparams RPAR {:
        return new FunctionUse(id, new Opt(funcparams));
    :}
    ;


function_use_parameters =
    /* Epsilon */ {:
        return new List();
    :}
    | non_assign_expression.expression {:
        return new List().add(expression);
    :}
    | function_use_parameters.list COMMA non_assign_expression.expression {:
        return list.add(expression);
    :}
    ;


block =
    LBRA RBRA {:
        return new List();
    :}
    | LBRA expressions.exps RBRA {:
        return exps;
    :}
    | LBRA block.block RBRA {:
        return block;
    :}
    ;


expressions =
    arithemetic_expressions
    | control_flow_expressions
    ;


arithemetic_expressions =
    expression.expression SEMI {:
        return new List().add(expression);
    :}
    | expressions.expression_list expression.expression SEMI {:
        return expression_list.add(expression);
    :}
    ;


control_flow_expressions =

    control_flow_statement.control {:
        return new List().add(control);
    :}
    | expressions.expression_list control_flow_statement.control {:
        return expression_list.add(control);
    :}
    ;


expression =
    id_use.id ASSIGN non_assign_expression.exp {:
        return new Assign(id, exp);
    :}
    | id_declare.id ASSIGN non_assign_expression.exp {:
        return new Assign(id, exp);
    :}
    | id_declare.id
    | RETURN non_assign_expression.expression {:
        return new Return(expression);
    :}
    | function_use
    | control_flow_statement
    ;


control_flow_statement =
    if_statement
    | while_statement
    ;


if_statement =
    IF LPAR logic_expression.logic RPAR block.block else_statement.elsestm {:
        return new IF(logic, new Opt(block), new Opt(elsestm));
    :}
    | IF LPAR logic_expression.logic RPAR block.block  {:
        return new IF(logic, new Opt(block), new Opt());
    :}
    ;


else_statement =
    ELSE block.block {:
        return new ELSE(new Opt(block));
    :}
    ;


while_statement =
    WHILE LPAR logic_expression.logic RPAR block.block {:
        return new WHILE(logic, new Opt(block));
    :}
    ;


logic_expression =
    non_logic_expression.exp1 NOEQ  non_assign_expression.exp2 {:
        return new NOEQ(exp1, exp2);
    :}
    | non_logic_expression.exp1 EQ non_assign_expression.exp2 {:
        return new  EQ(exp1, exp2);
    :}
    | non_logic_expression.exp1 LTEQ non_assign_expression.exp2 {:
        return new  LTEQ(exp1, exp2);
    :}
    | non_logic_expression.exp1 GTEQ non_assign_expression.exp2 {:
        return new  GTEQ(exp1, exp2);
    :}
    | non_logic_expression.exp1 LT non_assign_expression.exp2 {:
        return new  LT(exp1, exp2);
    :}
    | non_logic_expression.exp1 GT non_assign_expression.exp2 {:
        return new  GT(exp1, exp2);
    :}
    ;


non_logic_expression =
    term
    | non_assign_expression.expression PLUS term.term {:
        return new Add(expression, term);
    :}
    | non_assign_expression.expression MINUS term.term {:
        return new Minus(expression, term);
    :}
    ;


non_assign_expression =
    non_logic_expression
    | logic_expression
    ;


term =
    term.term MUL factor.factor {:
        return new Mul(term, factor);
    :}
    | term.term DIV factor.factor {:
        return new Div(term, factor);
    :}
    | term.term REM factor.factor {:
        return new Remainder(term, factor);
    :}
    | factor
    ;


factor =
    numeral
    | id_use
    | LPAR non_assign_expression.expression RPAR {:
        return expression;
    :}
    | function_use
    ;


numeral =
    NUMERAL.num {:
        return new Numeral(num);
    :}
    ;


id_declare =
    INT ID.id {:
        return new IdDeclare(id);
    :}
    ;


id_use =
    ID.id {:
        return new IdUse(id);
    :}
    ;
