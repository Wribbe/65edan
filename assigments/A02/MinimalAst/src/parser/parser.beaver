%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
    static public void debug(String string) {
        System.out.println("[?] DEBUG: "+string);
    }
:};

%terminals ID, NUMERAL, INT;
%terminals PLUS, MUL, ASSIGN;
%terminals LPAR, RPAR, LBRA, RBRA, SEMI, COMMA;

%typeof program = "Program";

%typeof expression = "Expression";
%typeof factor = "Expression";
%typeof term = "Expression";

%typeof functions = "List";
%typeof expressions = "List";

%typeof function = "FunctionDeclaration";
%typeof block = "List";

%typeof non_assign_expression = "Expression";

%typeof id_use = "IdUse";
%typeof id_declare = "IdDeclare";

%goal program;

program = functions.functions {: return new Program(functions); :} ;


functions =
    function.function {:
        return new List().add(function);
    :}
    | functions.function_list function.function  {:
        return function_list.add(function);
    :}
    ;


function =
    id_declare.id LPAR function_parameters.funcparam RPAR block.block {:
        return new FunctionDeclaration(id, new Opt(funcparam), new Opt(block));
    :}
    ;

function_parameters =
    /* Epsilon */ {:
        return new List();
    :}
    | id_declare.id {:
        return new List().add(id);
    :}
    | function_parameters.list COMMA id_declare.id {:
        return list.add(id);
    :}
    ;


block =
    LBRA RBRA {:
        return new List();
    :}
    | LBRA expressions.exps RBRA {:
        return exps ;
    :}
    ;


expressions =
    expression.expression SEMI {:
        return new List().add(expression);
    :}
    | expressions.expression_list expression.expression SEMI {:
        return expression_list.add(expression);
    :}
    ;


expression =
    id_use.id ASSIGN non_assign_expression.exp {:
        return new Assign(id, exp);
    :}
    | id_declare.id ASSIGN non_assign_expression.exp {:
        return new Assign(id, exp);
    :}
    | INT ID.id {:
        return new IdDeclare(id);
    :}
    ;


non_assign_expression =
    term
    | non_assign_expression.expression PLUS term.term {:
        return new Add(expression, term);
    :}
    ;


term =
    term.term MUL factor.factor {:
        return new Mul(term, factor);
    :}
    | factor
    ;


factor =
    numeral
    | id_use
    | LPAR non_assign_expression.expression RPAR {:
        return expression;
    :}
    ;


numeral =
    NUMERAL.num {:
        return new Numeral(num);
    :}
    ;


id_declare =
    INT ID.id {:
        return new IdDeclare(id);
    :}
    ;


id_use =
    ID.id {:
        return new IdUse(id);
    :}
    ;
