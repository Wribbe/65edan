L01.pdf:       EDAN65:  Compilers  
Introduc8on  and  Overview  
          Görel  Hedin  
         Revised:  2015-­‐08-­‐31  

L01.pdf:                                      Course  registra8on  
•  Conﬁrm  by  signing  the  Registra8on  Form  
•  Prerequisites  
     –  Object-­‐oriented  programming  and  Java  
     –  Algorithms  and  data  structures  
             (recursion,  trees,  lists,  hash  tables,  …)  
EDAN65,  2014,  Lecture  01  
                                                                          2  

L01.pdf:                                      CEQ  
•  Student  representa8ves?  
EDAN65,  2014,  Lecture  01  
                                              3  

L01.pdf:                                      Course  informa8on  
•  Web  page:  http://cs.lth.se/edan65  
     –  will  be  updated  during  the  course  
•  Literature  
     –  Course  material,  will  be  made  available  on  the  web  site  
                •  Lectures,  ar8cles,  assignments,  exercises  
                •  Not  handed  out  –  print  yourself.  
     –  Textbook  
                •  A.  W.  Appel,  Jens  Palsberg:  Modern  Compiler  Implementa8on  in  Java,  2nd  
                       Edi8on,  Cambridge  University  Press,  2002,  ISBN:  0-­‐521-­‐82060-­‐X  
                •  Available  as  an  on-­‐line  e-­‐book  through  Lund  University  
                •  Only  part  of  the  book  is  used.  Covers  only  part  of  the  course.  
•  Forum  (Q&A),  see  web  page.  
EDAN65,  2014,  Lecture  01  
                                                                                                                            4  

L01.pdf:                                      Course  structure  
•  14  lectures,  Mon  13-­‐15,  Tue  13-­‐15,  varying  lecture  halls  
•  Assignment  0,  for  freshing  up  on  Java  and  Unix.  Do  on  your  own.  
•  Assignment  1-­‐6.  Mandatory.  
     –       Work  in  pairs.  Use  the  lecture  break  or  the  forum  to  form  pairs.  
     –       Heavy.  Get  approved  and  get  help  at  Lab  sessions.  
     –       Thu  15-­‐17,  Fri  08-­‐10,  or  Fri  13-­‐15.  Sign  up  by  Thursday  Sept  3  
     –       Lab  sessions  start  next  week  (but  start  this  week  on  your  work)  
     –       Assignments  prerequisite  for  doing  exam  
•  Lecture  quizzes  
     –  New  course  feature.  Do  on  your  own.    
•  Exercises  
     –  Recommended  exercises  on  the  course  web.  Do  on  your  own.  
•  Wrihen  exam,  Tuesday  Oct  27,  2015  
     –  Re-­‐exam,  Friday  Jan  8,  2016  (sign  up  by  Dec  16)  
EDAN65,  2014,  Lecture  01  
                                                                                                                          5  

L01.pdf:                                      Instructors  
•  Lectures  
     –  Prof.  Görel  Hedin  
•  Programming  assignments  and  lab  sessions  
     –  Ph.  D.  student  Niklas  Fors  
     –  Ph.  D.  student  Jesper  Öqvist  
     –  Researcher  Christoﬀ  Bürger  
EDAN65,  2014,  Lecture  01  
                                                            6  

L01.pdf:  Why  learn  compiler  construc8on?  
•  Very  useful  in  prac8ce  
     –  Languages  are  everywhere  
     –  Your  next  project  might  need  a  small  language  
•  Interes8ng  
     –  Compiler  theory:  fundamental  to  computer  science  
     –  Essen8al  for  understanding  programming  languages  
EDAN65,  2014,  Lecture  01  
                                                                               7  

L01.pdf:A  tradi8onal  compiler  
               source                                                                assembly  
                                            compiler  
                code
 code

    EXAMPLE:                  .data  
                                                         a:            .long      0  
                                                         b:            .long      0  
                                                         csum:      .long      0  
  
    ...                  .code  
    csum  =  a  +  b  +  1;   compiler                  ...  
    ...  
                movl        a,  %eax  
                addl        b,  %eax  
                addl        $1,  %eax  
                movl        %eax,  csum  
    EDAN65,  2014,  Lecture  01                  ...

                                                                                                                               8  

L01.pdf:What  happens  aner  compila8on?  memory  
   source                                         assembly                  activation
                                      compiler                                              stack  
    code
 code
 records  
                                        object                 executable  
 assembler                                          linker                    objects   heap  
                                         code
 code

                                        library  
                                  object  code
 static
                                                                                 ...           data  
                                                                                 0000 0001
                                                                                 0176 0024
                                                                                 0024 7050
  •  object  code  contains  global  symbols                           2530 0000
     and  relocatable  addresses                                           0000 0010     code  
                                                                   loader      2444 5512
                                                                                 0000 0010
  •  in  executable  code  global  symbols  and                      ...
     relocatable  addresses  have  been  
     replaced  by  absolute  addresses  
                                                                                 machine
  EDAN65,  2014,  Lecture  01  
                                                                                                  9  

L01.pdf:What  about  Java?  
                                           javac  
      A.java
 A.class

                                       compiler  
                                                                     class  ﬁle  
                                                                 (java  bytecode)  
   EXAMPLE:                                                                         ...  
                                                                                      iload_1  
                                                                                      iload_2  
   ...  
                                                       javac                        iadd  
   csum  =  a  +  b  +  1;  
                                                     compiler                       iconst_1  
   ...  
                                                                                      iadd  
                                                                                      istore_3  
                                                                                      ...  
 EDAN65,  2014,  Lecture  01  
                                                                                                   10  

L01.pdf:Running  Java  code?                                                                  memory  
                                                                                           activation
                                              javac                                                           stack  
          A.java
 A.class
 records  
                                            compiler  
                                                                                             objects  
                                                                                                                heap  
                                                                            load             op8mized  
                                                                            and verify      machine  
                                                                                                code
 optimize  
                                                                                              machine  
The  java  program  contains  a  java  virtual  machine  (jvm).               code
 JIT  
It  can:                                                                                 bytecode

•  load  bytecode  to  the  heap  
•  interpret  bytecode                                                                  class  loader  
•  compile  bytecode  into  machine  code  during  execu>on  
                                                                                                                 code
       (JIT  –  Just-­‐In-­‐Time  Compila>on)                                          java             and
•  op>mize  the  machine  code                                                          VM  
                                                                                                                 data  
•  garbage  collect  the  heap  
                                                                                            machine
      EDAN65,  2014,  Lecture  01  
                                                                                                                          11  

L01.pdf:                                                                Each  phase  converts  the  program  
     Inside  the  compiler:                               from  one  representa7on  to  another  
                                                                   source  code  (text)  
                                        Lexical  analysis  
                                           (scanning)  
                                                                   tokens  
                                      Syntac8c  analysis  
              Analysis                    (parsing)  
                                                                   AST  (Abstract  syntax  tree)  
                                      Seman8c  analysis  
                                                                   Ahributed  AST  
                                         Intermediate  
                                       code  genera8on  
                                                                   intermediate  code  
             Synthesis                 Op8miza8on  
                                                                   intermediate  code  
                                          Target  code  
                                          genera8on  
EDAN65,  2014,  Lecture  01                                target  code                               12  

L01.pdf:     Front  and  back  end:  
                                                                           source  code  (text)  
                                                   Lexical  analysis  
                                                      (scanning)  
                                                                           tokens  
                                                 Syntac8c  analysis  
                                                       (parsing)  
             Front  end                                                AST  (Abstract  syntax  tree)  
(independent  on  target  language)  
                                                 Seman8c  analysis  
                                                                           Ahributed  AST  
                                                    Intermediate  
                                                  code  genera8on  
                                                                           intermediate  code  
            Middle  end  
                                                    Op8miza8on  
      (independent  on  both)  
                                                                           intermediate  code  
             Back  end                           Target  code  
(independent  on  source  language)          genera8on  
           EDAN65,  2014,  Lecture  01                             target  code                   13  

L01.pdf:Several  front  and  back  ends:  
              C-­‐Frontend                        L-­‐Frontend                ...  
                                                                                                           intermediate  code  
   Intel-­‐Backend                    MIPS-­‐Backend         Interpreter              ...  
                 Why?  
                 •  It  is  more  ra8onal  to  implement  m  front  ends  +  n  back  ends  
                         than  m  *  n  compilers.  
                 •  Many  op8miza8ons  are    best  performed  on  intermediate  code.  
                 •  It  may  be  easier  to  debug  the  front  end  using  an  interpreter  
                         than  a  target  machine  
  EDAN65,  2014,  Lecture  01  
                                                                                                                                    14  

L01.pdf:Example:  
                                        Eclipse               Scala  
       javac                                                                 Jython             ...  
                            Java  compiler            compiler  
                                                                                                            Java  bytecode  
                                                      Jikes  
       HotSpot  JVM                                                       dx          ...  
                                                  Research  VM  
                                                                                           Dalvik  bytecode  
                                                                          Dalvik  VM  
                                                                          (Android)  
  EDAN65,  2014,  Lecture  01  
                                                                                                                                 15  

L01.pdf:                                      Some  terminology  
•  A  compiler  translates  a  high-­‐level  program  to  low-­‐level  code.  
•  An  interpreter  is  sonware  that  executes  a  high/low  level  program,  onen  by  
    calling  one  procedure  for  each  program  construct.  
•  In  the  context  of  compiler  construc8on,  a  virtual  machine  (VM)  is  an  
    interpreter  that  executes  low-­‐level,  usually  plasorm-­‐independent  code.  
    (In  other  contexts,  virtual  machine  can  mean  system  virtualiza8on.)  
•  Plasorm-­‐independent  low-­‐level  code,  designed  to  be  executed  by  a  VM,  was  
    originally  called  p-­‐code  (portable  code),  but  is  now  usually  called  bytecode.  
•  An  interpreter  or  VM  may  use  a  JIT  (“just  in  8me”)  compiler  to  compile  all  or  
    parts  of  the  program  into  machine  code  during  execu8on.  
EDAN65,  2014,  Lecture  01  
                                                                                                                                  16  

L01.pdf:                     Some  historical  anecdotes  
•  The  ﬁrst  compiler  was  developed  by  Grace  Hopper  in  1952.  
•  John  McCarthy  used  JIT  compila8on  in  his  LISP  interpreter  in  1960.  
    This  was  called  "Compile  and  Go".  The  term  JIT  came  later,  and  was  
    popularized  with  Java.  
•  The  Pascal-­‐P  system,  developed  by  Niklaus  Wirth  in  1972,  used  
    portable  code  called  "p-­‐code".  The  interpreter  was  easy  to  port  to  
    diﬀerent  machines.  The  language  spread  quickly,  and  became  a  
    popular  language  taught  at  many  universi8es.  
•  Smalltalk-­‐80  used  bytecode,  and  pioneered  several  run8me  
    compila8on  and  op8miza8on  techniques  for  object-­‐oriented  
    languages.  
EDAN65,  2014,  Lecture  01  
                                                                                                               17  

L01.pdf: Compiler  phases  and  program  representa8ons:  
                                                                source  code  (text)  
                                        Lexical  analysis  
                                           (scanning)  
                                                                tokens  
                                      Syntac8c  analysis  
                                            (parsing)  
                                                                AST  (Abstract  syntax  tree)  
                                      Seman8c  analysis  
                                                                Ahributed  AST  
                                         Intermediate  
                                       code  genera8on  
                                                                intermediate  code  
                                         Op8miza8on  
                                                                intermediate  code  
                                          Target  code  
                                          genera8on  
EDAN65,  2014,  Lecture  01                             target  code                        18  

L01.pdf:                      Lexical  analysis  (scanning)  
 Source  text                  Tokens  
 while  (k<=n)  {                            WHILE  LPAR  ID(k)  LEQ  ID(n)  RPAR  LBRA  
    sum=sum+k;                              ID(sum)  EQ  ID(sum)  PLUS  ID(k)  SEMI  
    k=k+1;                                  ID(k)  EQ  ID(k)  PLUS  INT(1)  SEMI  
 }                                               RBRA  
 A  token  is  a  symbolic  name,  some8mes  with  an  ahribute.  
 A  lexeme  is  a  string  corresponding  to  a  token.  
EDAN65,  2014,  Lecture  01  
                                                                                                              19  

L01.pdf: Compiler  phases  and  program  representa8ons:  
                                                                source  code  (text)  
                                        Lexical  analysis  
                                           (scanning)  
                                                                tokens  
                                      Syntac8c  analysis  
                                            (parsing)  
                                                                AST  (Abstract  syntax  tree)  
                                      Seman8c  analysis  
                                                                Ahributed  AST  
                                         Intermediate  
                                       code  genera8on  
                                                                intermediate  code  
                                         Op8miza8on  
                                                                intermediate  code  
                                          Target  code  
                                          genera8on  
EDAN65,  2014,  Lecture  01                             target  code                        20  

L01.pdf:                      Syntac8c  analysis  (parsing)  
                                        WhileStmt                                            parse  tree  –  spans  all  tokens  
                                                                            CompoundStmt  
                                                     AssignStmt                              AssignStmt  
                 LessEqual                                          Add                                   Add  
WHILE  LPAR  ID  LEQ  ID  RPAR  LBRA  ID  EQ  ID  PLUS  ID  SEMI  ID  EQ  ID  PLUS  INT  SEMI  RBRA  
while  (  k  <=  n  )  {  sum  =  sum  +  k  ;  k  =  k  +  1  ;  }  
  EDAN65,  2014,  Lecture  01  
                                                                                                                                          21  

L01.pdf:                        Abstract  syntax  tree  (AST)  
                                        WhileStmt                                           AST  –  a  tree  with  only  the  
                                                                                              essen8al  structure  and  tokens  
                                                                            CompoundStmt  
                                                     AssignStmt                              AssignStmt  
                 LessEqual                                          Add                                     Add  
WHILE  LPAR  ID  LEQ  ID  RPAR  LBRA  ID  EQ  ID  PLUS  ID  SEMI  ID  EQ  ID  PLUS  INT  SEMI  RBRA  
while  (  k  <=  n  )  {  sum  =  sum  +  k  ;  k  =  k  +  1  ;  }  
  EDAN65,  2014,  Lecture  01  
                                                                                                                                               22  

L01.pdf:                                   Abstract  syntax  trees  
•  Used  inside  the  compiler  for  represen8ng  the  program  
•  Very  similar  to  the  parse  tree,  but  
     –  contains  only  essen8al  tokens  
     –  has  a  simpler  more  natural  structure  
•  Onen  represented  by  a  typed  object-­‐oriented  model  
     –  abstract  classes  (statements,  expressions,  declara8ons,  ...)  
     –  concrete  classes  (while,  if,  add,  subtract,  ...)  
EDAN65,  2014,  Lecture  01  
                                                                                        23  

L01.pdf:                                      AST  class  hierarchy  
•  Create  class  hierarchies  for  statements  and  
    expressions!  
•  Invent  names  for  suitable  abstract  classes!  
•  Add  gehers  for  traversing  the  AST!  
EDAN65,  2014,  Lecture  01  
                                                                    24  

L01.pdf:                                        AST  class  hierarchy  
                                 Stmt
 Expr

WhileStmt
 CompoundStmt
 AssignStmt
 Add
 LessEqual
 Id
 Int

getExpr()
 getStmts()
 getId()
 getExpr1()
 getExpr1()
 getID()
 getINT()

getStmt()
 getExpr()
 getExpr2()
 getExpr2()

  EDAN65,  2014,  Lecture  01  
                                                                                                        25  

L01.pdf: Compiler  phases  and  program  representa8ons:  
                                                                source  code  (text)  
                                        Lexical  analysis  
                                           (scanning)  
                                                                tokens  
                                      Syntac8c  analysis  
                                            (parsing)  
                                                                AST  (Abstract  syntax  tree)  
                                      Seman8c  analysis  
                                                                Ahributed  AST  
                                         Intermediate  
                                       code  genera8on  
                                                                intermediate  code  
                                         Op8miza8on  
                                                                intermediate  code  
                                          Target  code  
                                          genera8on  
EDAN65,  2014,  Lecture  01                             target  code                        26  

L01.pdf:                                      Seman8c  analysis  
Analyze  the  AST,  for  example,  
•  Which  declara8on  corresponds  to  a  variable?  
•  What  is  the  type  of  an  expression?  
•  Are  there  compile  8me  errors  in  the  program?  
  
Analysis  aided  by  adding  aGributes  to  the  AST  
(proper8es  of  AST  nodes)  
EDAN65,  2014,  Lecture  01  
                                                                         27  

L01.pdf:                                        Example  ahributes  
                                                                                                        Expr

                                 Stmt
 Decl
 type()

WhileStmt
 CompoundStmt
 AssignStmt
 Add
 LessEqual
 Id
 Int

getExpr()
 getStmts()
 getId()
 getExpr1()
 getExpr1()
 getID()
 getINT()

getStmt()
 getExpr()
 getExpr2()
 getExpr2()
 decl()

 Each  Expr  has  a  type()  ahribute,  indica8ng  if  the  expression  is  integer,  boolean,  etc.  
 Each  Id  has  a  decl()  ahribute,  referring  to  the  appropriate  declara8on  node.  
  EDAN65,  2014,  Lecture  01  
                                                                                                                                         28  

L01.pdf: Compiler  phases  and  program  representa8ons:  
                                                                source  code  (text)  
                                        Lexical  analysis  
                                           (scanning)  
                                                                tokens  
                                      Syntac8c  analysis  
                                            (parsing)  
                                                                AST  (Abstract  syntax  tree)  
                                      Seman8c  analysis  
                                                                Ahributed  AST  
                                         Intermediate  
                                       code  genera8on  
                                                                intermediate  code  
                                         Op8miza8on  
                                                                intermediate  code  
                                          Target  code  
                                          genera8on  
EDAN65,  2014,  Lecture  01                             target  code                        29  

L01.pdf:            Intermediate  code  genera8on  
Intermediate  code:  
•  independent  of  source  language  
•  independent  of  target  machine  
•  usually  assembly-­‐like  
      –  but  simpler,  without  many  instruc8on  variants  
      –  and  with  an  unlimited  number  of  registers  
             (or  uses  a  stack  instead  of  registers)  
  
By  adding  suitable  ahributes  to  the  AST,  code  
genera8on  becomes  simple.  
EDAN65,  2014,  Lecture  01  
                                                                          30  

L01.pdf:        Compiler  phases  and  program  representa8ons:  
                                                                    source  code  (text)  
                                            Lexical  analysis  
                                               (scanning)  
                                                                    tokens  
                                          Syntac8c  analysis  
                                                (parsing)  
                                                                    AST  (Abstract  syntax  tree)  
                                          Seman8c  analysis  
                                                                    Ahributed  AST  
                                             Intermediate  
                                           code  genera8on  
                                                                    intermediate  code  
                                             Op8miza8on  
See  the  course  Op8mizing  
                                                                    intermediate  code  
Compilers,  EDA230  
                                              Target  code  
                                              genera8on  
    EDAN65,  2014,  Lecture  01                             target  code                      31  

L01.pdf:   Genera8ng  the  compiler:  
    Regular                                                                   Lexical  analyzer  
                                                     Scanner  generator  
  expressions
 (scanner)  
 Context-­‐free                                          Parser            Syntac8c  analyzer  
   grammar
 generator                (parser)  
   Ahribute                                        Ahribute  evaluator  
                                                                               Seman8c  analyzer  
   grammar
 generator  
                                                                                 Intermediate  
                                                                                code  generator  
Code  genera8on  can                                Reusable  
also  be  done  using                            algoritms,              Op8mizer  
ahribute  grammars                                  see  EDA230

                                                                                  Target  code  
                                                                                   generator  
               EDAN65,  2014,  Lecture  01  
                                                                                                        32  

L01.pdf: Program  errors  
       Lexical  analysis                 lexical  errors  
             (scanning)                    text  that  cannot  be  interpreted  as  a  token  
    Syntac8c  analysis                   syntac>c  errors                                                compile-­‐7me  
              (parsing)                    tokens  in  the  wrong  order                             errors  
                                             sta>c-­‐seman>c  errors  
    Seman8c  analysis                    wrong  use  of  names,  types,  ...  
                                                                               run7me  errors  
                                           interpreter/                        null  pointer  excep8on,  
      Code  genera8on  
                                             machine                           division  by  zero,  
                                                                               stack  overﬂow,  ...  
     logic  errors  
     Compute  the  wrong  result.  
     Not  caught  by  the  compiler  or  the  machine.  
     Normally  try  to  catch  using  test  cases.  
     Asser8ons  and  program  veriﬁca8on  can  also  help.  
EDAN65,  2014,  Lecture  01  
                                                                                                                            33  

L01.pdf:                                           Example  errors  
Lexical  error:                                    Run8me  error:  
int  #  square(int  x)  {                    int  square(int  x)  {  
        return  x  *  x;          return  x  /  0;  
}                                                    }  
Syntac8c  error:                                   Logic  error:  
int  double  square(int  x)  {               int  square(int  x)  {  
        return  x  *  x;          return  2  *  x;  
}                                                    }  
Sta8c-­‐seman8c  error:  
boolean  square(int  x)  {  
        return  x  *  x;  
}  
EDAN65,  2014,  Lecture  01  
                                                                                                  34  

L01.pdf:             Safe  versus  unsafe  languages  
•   Safe  language  
  
    All  run8me  errors  are  caught  by  the  generated  code  and/or  run8me  system,  and  
    are  reported  in  terms  of  the  language.  
  
    Examples:  Java,  C#,  Smalltalk,  Python,  ...  
•   Unsafe  language  
  
    Run8me  errors  in  the  generated  code  can  lead  to  undeﬁned  behavior,  for  example  
    an  out  of  bounds  array  access.  In  the  best  case,  this  gives  a  hardware  excep8on  
    soon  aner  the  real  error,  stopping  the  program  ("segmenta8on  fault").  In  the  
    worst  case,  the  execu8on  con8nues,  compu8ng  the  wrong  result  or  giving  a  
    segmenta8on  fault  much  later,  leading  to  bugs  that  can  be  extremely  hard  to  ﬁnd.  
  
    Examples:  C,  Assembly  
EDAN65,  2014,  Lecture  01  
                                                                                                                                  35  

L01.pdf:             Course  overview  
                                                                                                          runtime system  
                                                                        source  code  (text)  
    Regular                         A1      Lexical  analyzer                                           activation
                                                                                                                                stack  
  expressions
 (scanner)                                                    records  
                                                                        tokens  
 Context-­‐free                A1,  A2   Syntac8c  analyzer  
                                                                                                                               garbage
   grammar
 (parser)  
                                                                                                                               collection  
                                                                        AST  (Abstract  syntax  tree)  
   Ahribute                    A3,  A4                                                                                    heap  
                                               Seman8c  analyzer  
   grammar
 objects  
                                                                        Ahributed  AST  
                                                 Intermediate  
                                                                           A5                                 Interpreter

                                                code  generator  
                                                                        intermediate  code                                   code
                                                                                                                   Virtual      and
                                                   Op8mizer                                                     machine
 data  
                                                                        intermediate  code  
                                                  Target  code  
                                                                           A6                                  machine
                                                   generator  
EDAN65,  2014,  Lecture  01                                       target  code  
                                                                                                                                      36  

L01.pdf:                                      Aner  this  course...  
•  You  will  have  built  a  complete  compiler  
•  You  will  have  seen  new  declara8ve  ways  of  programming  
•  You  will  have  learnt  some  fundamental  computer  science  theory  
•  You  will  have  experience  from  using  several  prac8cal  tools  
•  You  might  be  interested  in  doing  a  compiler  project  in  the  EDAN70  course  
    (Project  in  Computer  Science)  
•  You  might  be  interested  in  doing  a  master's  thesis  project  in  compilers  
    (related  to  research  or  industry)    
EDAN65,  2014,  Lecture  01  
                                                                                                                    37  

L01.pdf:  Applica8ons  of  compiler  construc8on  
•  Tradi8onal  compilers  from  source  to  assembly  
•  Source-­‐to-­‐source  translators,  preprocessors  
•  Interpreters  and  virtual  machines  
•  Integrated  programming  environments  
•  Analysis  tools  
•  Refactoring  tools  
•  Domain-­‐speciﬁc  languages  
EDAN65,  2014,  Lecture  01  
                                                                   38  

L01.pdf:                                      Examples  of  
                        Domain-­‐Speciﬁc  Languages  
EDAN65,  2014,  Lecture  01  
                                                          39  

L01.pdf:                                                  HTML  
...  
<h3>Lecture  1:  Introduction.  Mon  13-­‐15.  <a  href="http://
fileadmin.cs.lth.se/cs/Education/EDAN65/2015/documents/
EDAN65-­‐map.pdf">DC:  Stora  Hörsalen</a></h3>  
    <ul>  
        <li><a  href="http://fileadmin.cs.lth.se/cs/Education/
EDAN65/2015/lectures/L01.pdf">Slides</a>  
        <li>Appel  Book:  Ch  1-­‐1.2  
        <li><a  href  ="http://moodle.cs.lth.se/moodle/mod/quiz/
view.php?id=493">Moodle  Quiz</a>  
    </ul>  
...  
EDAN65,  2014,  Lecture  01  
                                                                             40  

L01.pdf:                                                                  .gitconﬁg  
[user]  
                name  =  Görel  Hedin  
                email  =  gorel@cs.lth.se  
[push]  
                default  =  simple  
EDAN65,  2014,  Lecture  01  
                                                                                41  

L01.pdf:                                                           Modelica  
                                                      hhp://www.modelica.org  
model  BouncingBall  //A  model  of  a  bouncing  ball  
        parameter  Real  g  =  9.81;  //  Accelera8on  due  to  gravity  
        parameter  Real  e  =  0.9;  //  Elas8city  coeﬃcient  
        Real  pos(start=1);  //  Posi8on  of  the  ball  
        Real  vel(start=0);  //  Velocity  of  the  ball  
equaDon  
        der(pos)  =  vel;  /  /  Newtons  second  law  
        der(vel)  =  -­‐g;  
        when  pos  <=0  then  
                reinit(vel,-­‐e*pre(vel));  //  set  velocity  aner  bounce  end  when;  
end  BouncingBall;  
                                         1
                                                                                                                        Earth ball
                                                                                                                        Moon ball
                                        0.8
                         Position [m]
                                        0.6
                                        0.4
                                        0.2
                                         0
                                              0   1    2            3           4             5           6            7             8
                                                                             Time [s]
EDAN65,  2014,  Lecture  01  
                                                                                                                                         42  

L01.pdf:                                         Grafchart  
                          hhp://www.control.lth.se/Research/tools/grafchart.html  
  
EDAN65,  2014,  Lecture  01  
                                                                                     43  

L01.pdf:                         Control  Builder  Diagram  
                                      hhp://new.abb.com  
EDAN65,  2014,  Lecture  01  
                                                            44  

L01.pdf:                          Related  research  at  LTH  
•  Extensible  compiler  tools  (Görel  Hedin)  
•  Real-­‐8me  garbage  collec8on  (Roger  Henriksson)  
•  Code  op8miza8on  for  mul8processors  (Jonas  Skeppstedt)  
•  Natural  language  processing  (Pierre  Nugues)  
•  Constraint  solvers  (Krzysztof  Kuchcinski)  
•  Data-­‐ﬂow  languages  (Jörn  Janneck)  
•  Languages  for  pervasive  systems  (Boris  Magnusson)  
•  Languages  for  requirements  modeling  (Björn  Regnell)  
•  Languages  for  simula8on  and  control  (The  control  department)  
EDAN65,  2014,  Lecture  01  
                                                                                         45  

L01.pdf:                                      Summary  ques8ons  
     •  What  are  the  major  compiler  phases?  
     •  What  is  the  diﬀerence  between  the  analysis  and  synthesis  phases?  
     •  Why  do  we  use  intermediate  code?  
     •  What  is  the  advantage  of  separa8ng  the  front  and  back  ends?  
     •  What  is  
               •  a  lexeme?  
               •  a  token?  
               •  a  parse  tree?  
               •  an  abstract  syntax  tree?  
               •  intermediate  code?  
     •  What  is  the  diﬀerence  between  assembly  code,  object  code,  and  
            executable  code?  
     •  What  is  bytecode,  an  interpreter,  a  virtual  machine?  
     •  What  is  a  JIT  compiler?  
     •  What  kind  of  errors  can  be  caught  by  a  compiler?  A  run8me  system?  
EDAN65,  2014,  Lecture  01  
                                                                                                                  46  

L02.pdf:      EDAN65:  Compilers,  Lecture  02  
Regular  expressions  and  scanning  
               Görel  Hedin  
              Revised:  2015-­‐09-­‐01  

L02.pdf:             Course  overview                              This  lecture  
                                                                                                 runtime system  
                                                               source  code  (text)  
    Regular                          Lexical  analyzer                                           activation
                                                                                                                       stack  
  expressions
 (scanner)                                                    records  
                                                               tokens  
 Context-­‐free                     SyntacHc  analyzer  
                                                                                                                      garbage
   grammar
 (parser)  
                                                                                                                      collection  
                                                               AST  (Abstract  syntax  tree)  
   ARribute                                                                                                          heap  
                                      SemanHc  analyzer  
   grammar
 objects  
                                                               ARributed  AST  
                                        Intermediate  
                                                                                                       Interpreter

                                       code  generator  
                                                               intermediate  code                                   code
                                                                                                          Virtual      and
                                          OpHmizer                                                     machine
 data  
                                                               intermediate  code  
                                         Target  code  
                                                                                                        machine
                                          generator  
EDAN65,  2014,  Lecture  02                              target  code  
                                                                                                                                 2  

L02.pdf:                          Analyzing  program  text  
                                          AssignStmt  
                                                 Exp  
parse tree  
                                                    Add  
                                                 Exp      Exp  
tokens                               ID EQ    ID PLUS ID
 This  lecture  
program text                        sum =    sum       +   k

EDAN65,  2014,  Lecture  02  
                                                                                        3  

L02.pdf:  Recall:  GeneraHng  the  compiler:  
                                  We  will  use  a  scanner  
                                  generator  called  JFlex                                 text  
  Regular                                                              Lexical  analyzer  
                                        Scanner  generator  
expressions
 (scanner)  
                                                                                                 tokens  
Context-­‐free                                Parser                SyntacHc  analyzer  
 grammar
 generator                    (parser)  
                                                                                                 tree  
 ARribute                             ARribute  evaluator  
                                                                        SemanHc  analyzer  
 grammar
 generator  
        EDAN65,  2014,  Lecture  02  
                                                                                                            4  

L02.pdf:                                                     Some  typical  tokens  
                                           Token     Example  lexemes                    Regular  expression  
Reserved  words                        IF        if                                  "if"  
(keywords)                               THEN      then                                  "then"  
                                         FOR       for                                   "for"  
IdenHﬁers                                ID        B      alpha      k10     [A-­‐Za-­‐z][A-­‐Za-­‐z0-­‐9]*  
Literals                                 INT       123 0      99      2014   [0-­‐9]+  
                                         FLOAT     3.1416      0.2                 [0-­‐9]+  "."    [0-­‐9]+  
                                         CHAR      'A'      'c'                    \'  [^\']  \'  
                                         STRING    "Hello"    ""    "j"          \"  [^\"]*  \"  
Operators                                PLUS      +                                     "+"  
                                         INCR      ++                                    "++"  
                                         NE        !=                                    "!="  
Separators                               SEMI      ;                                     ";"  
                                         COMMA     ,                                     ","  
                                         LPAREN    (                                     "("  
                                                                                                       JFlex  syntax  
     EDAN65,  2014,  Lecture  02  
                                                                                                                                   5  

L02.pdf:                                      Formal  languages  
•  An  alphabet,  Σ,  is  a  set  of  symbols  (nonempty  and  ﬁnite).  
•  A  string  is  a  sequence  of  symbols  (each  string  is  ﬁnite)  
•  A  formal  language,  L,  is  a  set  of  strings  (can  be  inﬁnite).    
•  We  would  like  to  have  rules  or  algorithms  for  deﬁning  a  
    language  –  deciding  if  a  certain  string  over  the  alphabet  
    belongs  to  the  language  or  not.  
EDAN65,  2014,  Lecture  02  
                                                                                                        6  

L02.pdf:     Example:  Languages  over  binary  numbers  
Suppose  we  have  the  alphabet  Σ  =  {0,  1}  
  
Example  languages:  
•  The  set  of  all  possible  combinaHons  of  zeros  and  ones:  
      L0  =  {0,  1,  00,  01,  10,  11,  000,  ...}  
•  All  binary  numbers  without  unnecessary  leading  zeros:  
      L1  =  {0,  1,  10,  11,  100,  101,  110,  111,  1000,  ...}  
•  All  binary  numbers  with  two  digits:  
      L2  =  {00,  01,  10,  11}  
•  ...  
EDAN65,  2014,  Lecture  02  
                                                                                              7  

L02.pdf:             Example:  Languages  over  UNICODE  
Here,  the  alphabet  Σ  is  the  set  of  UNICODE  characters  
  
  
Example  languages:  
•  All  possible  Java  keywords:  {”class”,  ”import”,  public”,  ...}  
•  All  possible  lexemes  corresponding  to  Java  tokens.  
•  All  possible  lexemes  corresponding  to  Java  whitespace.  
•  All  binary  numbers  
•  ...  
EDAN65,  2014,  Lecture  02  
                                                                                          8  

L02.pdf:        Example:  Languages  over  Java  tokens  
Here,  the  alphabet  Σ  is  the  set  of  Java  tokens  
  
  
Example  languages:  
•  All  syntacHcally  correct  Java  programs  
•  All  that  are  syntacHcally  incorrect  
•  All  that  are  compile-­‐Hme  correct  
•  All  that  terminate   (This  language  cannot  be  computed:  
                                      TerminaHon  is  undecidable:  it  is  not  
•  ...                              possible  to  construct  an  algorithm  that  
                                      decides  for  any  string,  if  it  is  a  
                                      terminaHng  program  or  not.)  
EDAN65,  2014,  Lecture  02  
                                                                                                  9  

L02.pdf:           Deﬁning  languages  using  rules  
Increasingly  powerful:  
•  Regular  expressions  (for  tokens)  
•  Context-­‐free  grammars  (for  syntax  trees)  
•  ARribute  grammars  (for  arbitrary  decidable  languages)  
EDAN65,  2014,  Lecture  02  
                                                                            10  

L02.pdf:       Regular  expressions  (core  notaHon)  
RE                                                               read                                             is  called  
a                                                                a                                                symbol  
M  |  N                                                      M  or  N                                     alternaHve  
M  N                                                           M  followed  by  N                         concatenaHon  
∊                                                                the  empty  string                           epsilon  
M*                                                               zero  or  more  M                          repeHHon  (Kleene  star)  
(M)  
where  a  is  a  symbol  in  the  alphabet  (e.g.,  {0,1}  or  UNICODE)  
and  M  and  N  are  regular  expressions  
  
Each  regular  expression  deﬁnes  a  language  over  the  alphabet  
(a  set  of  strings  that  belong  to  the  langauge).  
  
PrioriHes:          M  |  N  P*        means            M  |  (N  (P*))  
EDAN65,  2014,  Lecture  02  
                                                                                                                                                       11  

L02.pdf:                                      Example  
a  |  b  c*  
  
means  
  
{a,  b,  bc,  bcc,  bccc,  ...}  
  
EDAN65,  2014,  Lecture  02  
                                                  12  

L02.pdf:                Regular  expressions  (extended  notaHon)  
Core  RE                          read                                            is  called  
a                                   a                                               symbol  
M  |  N                         M  or  N                                    alternaHve  
M  N                              M  followed  by  N                        concatenaHon  
∊                                   the  empty  string                          epsilon  
M*                                  zero  or  more  M                         repeHHon  (Kleene  star)  
(M)  
Extended  RE                      read                                            means  
M+                                  at  least  one  ...                       M  M*  
M?                                  op8onal  ...                                  ∊  |  M  
[aou]                               one  of  ...  (a  character  class)   a  |  o  |  u  
[a-­‐zA-­‐Z]                                                                          a  |  b  |  ...  |  z  |  A  |  B  |  ...  |  Z  
[^0-­‐9]                            not  ...                                      one  character,  but  not  
(Appel  notaHon:  ~[0-­‐9])                                                       anyone  of  those  listed  
"a+b"                               the  string  ...                            a  \+  b  
EDAN65,  2014,  Lecture  02  
                                                                                                                                                                        13  

L02.pdf:                                                                                     Exercise  
Write  a  regular  expression  that  deﬁnes  the  language  of  all  decimal  numbers,  like  
  
      3.14      0.75      4711      0        ...  
  
But  not  numbers  lacking  an  integer  part.  And  not  numbers  with  a  decimal  point  but  
lacking  a  fracHonal  part.  So  not  numbers  like  
  
      17.      .236      .  
  
Leading  and  trailing  zeros  are  allowed.  So  the  following  are  ok:  
  
      007      008.00      0.0      1.700  
  
a)  Use  the  extended  notaHon.  
b)  Then  translate  the  expression  to  the  core  notaHon  
c)  Then  write  an  expression  that  disallows  leading  zeros  
EDAN65,  2014,  Lecture  02  
                                                                                                                                14  

L02.pdf:                                                        SoluHon  
a)  
      [0-­‐9]+  ("."[0-­‐9]+)?  
  
  
b)  
      (0  |...|  9)(0  |...|  9)*  (∊  |  ("."((0  |...|  9)(0  |...|  9)*)))  
  
  
c)  
      (0  |  [1-­‐9]  [0-­‐9]*)  ("."[0-­‐9]+)?  
  
             EDAN65,  2014,  Lecture  02  
                                                                                                              15  

L02.pdf:                                      Escaped  characters  
                          Use  backslash  to  escape  metacharacters  and  
                          non-­‐prinHng  control  characters.  
Metacharacters                         Non-­‐prin=ng  control  characters  
\+                                     \n                                       newline  
\*                                     \r                                       return  
\(                                     \t                                       tab  
\)                                     \f                                       formfeed  
\|                                     ...  
\\  
...  
EDAN65,  2014,  Lecture  02  
                                                                                                 16  

L02.pdf:                                               Some  typical  tokens  
Kind                                Name     Example  lexemes                  Regular  expression  
Reserved  words   IF                       if                                "if"  
(keywords)                          THEN     then                                "then"  
                                      FOR      for                                 "for"  
IdenHﬁers                           ID       B      alpha      k10   [A-­‐Za-­‐z]([A-­‐Za-­‐z0-­‐9])*  
Literals                            INT      123      0      99      [0-­‐9]+  
                                      FLOAT    3.1416      0.2               [0-­‐9]+  "."    [0-­‐9]+  
                                      CHAR     'A'      'c'                  \'  [^\']  \'  
                                      STRING   "Hello"    ""    "j"        \"  [^\"]*  \"  
Operators                           PLUS     +                                   "+"  
                                      INCR     ++                                  "++"  
                                      NE       !=                                  "!="  
Separators                          SEMI     ;                                   ";"  
                                      COMMA    ,                                   ","  
                                      LPAREN   (                                   "("  
EDAN65,  2014,  Lecture  02  
                                                                                                                            17  

L02.pdf:                                        Some  typical  non-­‐tokens  
Non-­‐Token                             Example  lexemes                        Regular  expression  (jﬂex)  
WHITESPACE                              blank      tab      newline   "  "  |  "\t"  |  "\n"  |  "\r"  
                                          return    
ENDOFLINECOMMENT                        //  comment                             "//"  [^\n\r]*  ([\n\r])?  
                                                                                                      JFlex  syntax  
  Non-­‐tokens  are  also  recognized  by  the  scanner,  just  like  tokens.  
  But  they  are  not  sent  on  to  the  parser.  
  (The  newline/return  ending  an  end-­‐of-­‐line  comment  is  opHonal  in  order  to  allow  a  
  ﬁle  to  end  with  an  end-­‐of-­‐line  comment,  without  an  extra  newline/return.)  
  EDAN65,  2014,  Lecture  02  
                                                                                                                                        18  

L02.pdf:                           JFlex:  A  scanner  generator  
                                 GeneraHng  a  scanner  for  a  language  lang  
                                                                                  Program.lang  
                                                                                               characters  
     lang.jﬂex
 jﬂex.jar                     LangScanner.java  
JFlex  speciﬁcaHon  
with  regular  exprs
 Scanner  generator                                  tokens  
                                                                                 LangParser.java  
  EDAN65,  2014,  Lecture  02  
                                                                                                              19  

L02.pdf:                                                                               A  JFlex  speciﬁcaHon  
  package  lang;                        //  the  generated  scanner  will  belong  to  the  package  lang  
  import  lang.Token;              //  Our  own  class  for  tokens  
  ...  
  
  //  ignore  whitespace  
  "  "  |  \t  |  \n  |  \r  |  \f        {  /*  ignore  */  }  
  
  //  tokens  
  "if"                                {  return  new  Token("IF");  }  
  "="                                  {  return  new  Token("ASSIGN");  }  
  "<"                                  {  return  new  Token("LT");  }  
  "<="                                {  return  new  Token("LE");  }  
  [a-­‐zA-­‐Z]+                      {  return  new  Token("ID",  yytext());  }  
  ...  
  Rules  and  lexical  ac=ons  
  Each  rule  has  the  form:  
          regular-­‐expression            {  lexical  ac8on  }  
  The  lexical  acHon  consists  of  arbitrary  Java  code.  
  It  is  run  when  a  token  is  matched.  
  The  method  yytext()  returns  the  lexeme  (the  token  value).  
EDAN65,  2014,  Lecture  02  
                                                                                                                                                          20  

L02.pdf:                                                                                         AmbiguiHes?  
  package  lang;                        //  the  generated  scanner  will  belong  to  the  package  lang  
  import  lang.Token;              //  Class  for  tokens  
  ...  
  
  //  ignore  whitespace  
  "  "  |  \t  |  \n  |  \r  |  \f        {  /*  ignore  */  }  
  
  //  tokens  
  "if"                                {  return  new  Token("IF");  }  
  "="                                  {  return  new  Token("ASSIGN");  }  
  "<"                                  {  return  new  Token("LT");  }  
  "<="                                {  return  new  Token("LE");  }  
  [a-­‐zA-­‐Z]+                      {  return  new  Token("ID",  yytext());  }  
  ...  
                                                                          Are  the  token  deﬁni=ons  ambiguous?  
                                                                          Which  rules  match  "<="?  
                                                                          Which  rules  match  "if"?  
                                                                          Which  rules  match  "iﬀf"?  
                                                                          Which  rules  match  "xyz"?  
EDAN65,  2014,  Lecture  02  
                                                                                                                                                          21  

L02.pdf:    Extra  rules  for  resolving  ambiguiHes  
Longest  match  
     If  one  rule  can  be  used  to  match  a  token,  but  there  is  another  rule  
     that  will  match  a  longer  token,  the  laRer  rule  will  be  chosen.  This  
     way,  the  scanner  will  match  the  longest  token  possible.  
  
Rule  priority  
     If  two  rules  can  be  used  to  match  the  same  sequence  of  characters,  
     the  ﬁrst  one  takes  priority.  
EDAN65,  2014,  Lecture  02  
                                                                                                                       22  

L02.pdf:              ImplementaHon  of  scanners  
ObservaHon:  
        Regular  expressions  are  equivalent  to  ﬁnite  automata  (ﬁnite-­‐state  machines).  
        (They  can  recognize  the  same  class  of  formal  languages:  the  regular  languages.)  
Overall  approach:  
•  Translate  each  token  regular  expression  to  a  ﬁnite  automaton.  
       Label  the  ﬁnal  state  with  the  token.  
•  Merge  all  the  automata.  
•  The  resulHng  automaton  will  in  general  be  nondeterminis8c  
•  Translate  the  nondeterminisHc  automaton  to  a  determinis8c  automaton.  
•  Implement  the  determinisHc  automaton,  
       either  using  switch  statements  or  a  table.  
A  scanner  generator  automates  this  process.  
EDAN65,  2014,  Lecture  02  
                                                                                                                       23  

L02.pdf:       Construct  an  automaton  for  each  token  
                                           i                         f  
       "if"                                                                   IF  
                                                                                             state  
                                                          0-­‐9  
                                        0-­‐9  
  [0-­‐9]+                                                           INT  
                                                                                       a   transiHon  
                                            "  "                   WHITESPACE  
                                                 \n  
 "  "  |  \n  |  \t                                        WHITESPACE  
                                                                                             start  state  
                                             \t                      WHITESPACE  
                                                        a-­‐zA-­‐Z  
                                                                                             ﬁnal  state  
                                      a-­‐zA-­‐Z  
      [a-­‐zA-­‐Z]+                                                   ID  
EDAN65,  2014,  Lecture  02  
                                                                                                            24  

L02.pdf:     Merge  the  start  states  of  the  automata  
                                                                                f  
                                                                                         IF  
                                                      i  
                                                                   0-­‐9  
                                                    0-­‐9  
                                                                                INT  
                                                    "  "\n\t  
                                                                                WHITESPACE  
                                             a-­‐zA-­‐Z        a-­‐zA-­‐Z  
                                                                                 ID  
                                Is  the  new  automaton  determinis=c?  
EDAN65,  2014,  Lecture  02  

L02.pdf:                                       DeterminisHc  ﬁnite  automata  
In  a  determinisHc  ﬁnite  automaton  each  transiHon  is  uniquely  determined  by  the  input.  
                           a            2     NondeterminisHc,  since  if  we  read  a  when  in  state  1,  
                  1                             we  don't  know  if  we  should  go  to  state  2  or  3.  
                           a            3  
                                 ε              NondeterminisHc,  since  when  we  are  in  state  1,  we  don't  
                   1                      2   know  if  we  should  stay  there,  or  go  to  state  2  without  
                                                  reading  any  input.  (Epsilon  denotes  the  empty  string.)  
                             a            2  
                                                  DeterminisHc,  since  from  state  1,  the  next  input  
                   1                            determines  if  we  go  to  state  2  or  3.  
                             b            3  
      EDAN65,  2014,  Lecture  02  
                                                                                                                                              26  

L02.pdf:                                          DFA  versus  NFA  
Determinis=c  Finite  Automaton  (DFA)  
A  ﬁnite  automaton  is  determinisHc  if  
         –  all  outgoing  edges  from  any  given  state  have  disjoint  character  sets  
         –  there  are  no  epsilon  edges  
Can  be  implemented  eﬃciently  
  
  
Non-­‐determinis=c  Finite  Automaton  (NFA)  
An  NFA  may  have  
         –  two  outgoing  edges  with  overlapping  character  sets  
         –  epsilon  edges  
Every  DFA  is  also  an  NFA.  
Every  NFA  can  be  translated  to  an  equivalent  DFA.  
  
  EDAN65,  2014,  Lecture  02                                                                            27  

L02.pdf:               TranslaHng  an  NFA  to  a  DFA  
Simulate  the  NFA  
     –  keep  track  of  a  set  of  current  NFA-­‐states  
     –  follow  ε  edges  to  extend  the  current  set  (take  the  closure)  
  
Construct  the  corresponding  DFA  
     –  Each  such  set  of  NFA  states  corresponds  to  one  DFA  state  
     –  If  any  of  the  NFA  states  is  ﬁnal,  the  DFA  state  is  also  ﬁnal,  
             and  is  marked  with  the  corresponding  token.  
     –  If  there  is  more  than  one  token  to  choose  from,  select  the  
             token  that  is  deﬁned  ﬁrst  (rule  priority).  
(Minimize  the  DFA  for  eﬃciency)  
EDAN65,  2014,  Lecture  02  
                                                                                                                 28  

L02.pdf:                                                                     Example  
                     NFA                                                                  DFA  
                                      f                                              ID                 f  
                           2                        3     IF                             2,4                        3,4     IF  
           i                                                                   i  
                                                                                                       a-­‐eg-­‐z  
   1                                                                    1  
                 a-­‐z                                                                                                          a-­‐z  
                                            a-­‐z                                                               a-­‐z  
                                                                                a-­‐hj-­‐z  
                                             4       ID                                                        4        ID  
EDAN65,  2014,  Lecture  02  
                                                                                                                                             29  

L02.pdf:                                        Error  handling  
                                                                    ID  
                                                                                  f  
                                                                      2                         3       IF  
                                                       i  
                                                                            a-­‐eg-­‐z  
                                               1  
                                                                                                        a-­‐z  
                                                                                        a-­‐z  
                                                             a-­‐hj-­‐z  
                                                                                         4        ID  
                                                                                            ^a-­‐z               ^a-­‐z  
                                              ^a-­‐z  
                          ^a-­‐z  
                                                                            0  
                                                                 ERROR  
                     •  Add  a  "dead  state"  (state  0),  corresponding  to  erroneous  input.  
                     •  Add  transiHons  to  the  "dead  state"  for  all  erroneous  input.  
                     •  Generate  an  "ERROR  token"  when  the  dead  state  is  reached.  
EDAN65,  2014,  Lecture  02  
                                                                                                                              30  

L02.pdf:     ImplementaHon  alternaHves  for  DFAs  
Table-­‐driven  
      –  Represent  the  automaton  by  a  table  
      –  AddiHonal  table  to  keep  track  of  ﬁnal  states  and  token  kinds  
      –  A  global  variable  keeps  track  of  the  current  state  
  
Switch  statements  
      –  Each  state  is  implemented  as  a  switch  statement  
      –  Each  case  implements  a  state  transiHon  as  a  jump  (to  another  switch  
             statement)  
      –  The  current  state  is  represented  by  the  program  counter.  
EDAN65,  2014,  Lecture  02  
                                                                                                                  31  

L02.pdf:              Table-­‐driven  implementaHon  
                                                                  ID                       f  
                                                                                2                                3       IF  
                                                               i  
                                                                                       a-­‐eg-­‐z  
                                                         1  
                                                                                                                         a-­‐z  
                                                                                                   a-­‐z  
                                             +  
                                                                     a-­‐hj-­‐z  
                                                                                                     4            ID  
                               PLUS          5  
      ...    +       ...         a   ...   e       f        g         ...   h            i           j      ...   z   ...   ﬁnal     kind  
0    0     0        0          0    0    0       0        0          0         0       0          0        0    0    0   true    ERROR  
1    0     5        0          4    4    4       4        4          4         4       2          4        4    4    0   false  
2    0     0        0          4    4    4       3        4          4         4       4          4        4    4    0   true    ID  
3    0     0        0          4    4    4       4        4          4         4       4          4        4    4    0   true    IF  
4    0     0        0          4    4    4       4        4          4         4       4          4        4    4    0   true    ID  
5    0     0        0          0    0    0       0        0          0         0       0          0        0    0    0   true    PLUS  
 EDAN65,  2014,  Lecture  02  
                                                                                                                                                                              32  

L02.pdf:    Scanner  implementaHon,  design  
                                                      Token

                                               int kind()

                                               String value()

                                      call                       call  
                               File
 Scanner
 Parser

                    char nextChar()
 Token nextToken()






EDAN65,  2014,  Lecture  02  
                                                                                        33  

L02.pdf:            Scanner  implementaHon,  sketch  
        Idea:  Scan  the  next  token  by  
        •  starHng  in  the  start  state  
        •  scan  characters  unHl  we  reach  a  ﬁnal  state  
        •  return  a  new  token  
  Token  nextToken()  {  
      state  =  1;  //  start  state  
      while  (!  isFinal[state])  {  
            ch  =  file.readChar();  
            state  =  edges[state,  ch];  
      }  
      return  new  Token(kind[state]);  
  }  
 Needs  to  be  extended  with  handling  of:  
 •  longest  match  
 •  end  of  ﬁle  
 •  non  tokens  (like  whitespace)  
 •  token  values  (like  the  idenHﬁer  name)  
EDAN65,  2014,  Lecture  02  
                                                                               34  

L02.pdf:                                         Extend  to  longest  match,  design  
                                                                                      Token

                                                                             int kind()

                                                                             String value()

      File
 PushbackFile
 Scanner
 Parser

char readChar()
 char readChar()
 Token nextToken()



 void pushback(String)





   Idea:  
   •  When  a  token  is  matched,  don't  stop  scanning.  
   •  When  the  error  state  is  reached,  return  the  last  token  matched.  
   •  Push  read  characters  that  are  unused  back  into  the  ﬁle,  so  they  can  be  scanned  again.  
   •  Use  a  PushbackFile  to  accomplish  this.  
   EDAN65,  2014,  Lecture  02  
                                                                                                                                       35  

L02.pdf:             Extend  to  handle  longest  match,  sketch  
•        When  a  token  is  matched  (a  ﬁnal  state  reached),  don’t  stop  scanning.  
•        Keep  track  of  the  currently  scanned  string,  str.  
•        Keep  track  of  the  latest  matched  token  (lastFinalState,  lastTokenValue).  
•        ConHnue  scanning  unHl  we  reach  the  error  state.  
•        Restore  the  input  stream  using  PushBackFile.  
•        Return  the  latest  matched  token.  
•        (or  return  the  ERROR  token  if  there  was  no  latest  matched  token)  
   Token  nextToken()  {  
      state  =  1;  
      str  =  "";  
      lastFinalState  =  0;  lastTokenValue  =  "";  
      while  (state  !=  0)  {  
            ch  =  pushbackfile.readChar();  
            str  =  str  +  ch;         //  In  Java,  StringBuilder  would  be  more  efficient  
            state  =  edges[state,  ch];  
            if  (isFinal[state])  {  
                  lastFinalState  =  state;  
                  lastTokenValue  =  str;  
            }  
      }  
      pushbackfile.pushback(str.substring(lastTokenValue.length));  
      return  new  Token(kind[lastFinalState],  lastTokenValue);  
   }  
EDAN65,  2014,  Lecture  02  
                                                                                                                                              36  

L02.pdf:       Handling  End-­‐of-­‐ﬁle  (EOF)  and  non-­‐tokens    
EOF  
     –  construct  an  explicit  EOF  token  when  the  EOF  character  is  read  
  
Non-­‐tokens  (Whitespace  &  Comments)  
     –  view  as  tokens  of  a  special  kind  
     –  scan  them  as  normal  tokens,  but  don’t  create  token  objects  for  them  
     –  loop  in  next()  unHl  a  real  token  has  been  found  
  
Errors  
     –  construct  an  explicit  ERROR  token  to  be  returned  when  no  valid  token  
             can  be  found.  
EDAN65,  2014,  Lecture  02  
                                                                                                                  37  

L02.pdf:                                     Specifying  EOF  and  ERROR  in  JFlex  
  package  lang;                        //  the  generated  scanner  will  belong  to  the  package  lang  
  import  lang.Token;              //  Class  for  tokens  
  ...  
  
  //  ignore  whitespace  
  "  "  |  \t  |  \n  |  \r  |  \f        {  /*  ignore  */  }  
  
  //  tokens  
  "if"                                {  return  new  Token("IF");  }  
  "="                                  {  return  new  Token("ASSIGN");  }  
  "<"                                  {  return  new  Token("LT");  }  
  "<="                                {  return  new  Token("LE");  }  
  [a-­‐zA-­‐Z]+                      {  return  new  Token("ID",  yytext());  }  
  ...  
  <<EOF>>                          {  return  new  Token("EOF");  }  
  [^]                                  {  return  new  Token("ERROR");  }  
  <<EOF>>  is  a  special  regular  expression  in  JFlex,  matching  end  of  ﬁle.  
  
  [^]  means  any  character.  Due  to  rule  priority,  this  will  match  any  character  not  
  matched  by  previous  rules.  
  
EDAN65,  2014,  Lecture  02  
                                                                                                                                                          38  

L02.pdf:               Example  scanner  generators  
            tool                     author                      generates  
            lex                      Schmidt,  Lesk.  1975   C-­‐code  
            ﬂex  ("fast  lex")   Paxon.  1987              C-­‐code  
            jlex                                                   Java  code  
            jﬂex                                                   Java  code  
            ...  
EDAN65,  2014,  Lecture  02  
                                                                                      39  

L02.pdf:                                                Lexical  states  
    •  Some  tokens  are  diﬃcult  or  impossible  to  deﬁne  with  regular  expressions.  
    •  Lexical  states  (sets  of  token  rules)  give  the  possibility  to  switch  token  sets  
        (DFAs)  during  scanning.  
                               LEXSTATE1                      LEXSTATE2  
                                         T1                          T5  
                                         T2                          T6  
                                         T3                          T7  
                                         T4                         ...  
                                       ...  
  
•  Useful  for  mulH-­‐line  comments,  HTML,  scanning  mulH-­‐language  
        documents,  etc.  
•  Supported  by  many  scanner  generators  (including  JFlex)  
      EDAN65,  2014,  Lecture  02  
                                                                                                                              40  

L02.pdf:                                Example:  mulH-­‐line  comments  
   Would  like  to  scan  the  complete  comment  as  one  token:  
     /*  
     int  m()  {  
      return  15  /  3  *  4  *  2;  
     }  
     */  
   Can  be  solved  easily  with  lexical  states:  
         Default                       ID                                "*/"                Token  set  used  
                                       "if"                             [^]  
         token  set               "then"  
                                                                                                   inside  comment  
                                       "/*"  
                                        ...  
                  WriHng  an  ordinary  regular  expression  for  this  is  diﬃcult:  
                                                "/*"((\*+[^/*])|([^*]))*\**"*/"  
   However,  some  scanner  generators,  like  JFlex,  has  the  special  operator  upto  (~)  that  
   can  be  used  instead:                               "/*"  ~"*/"      {  /*  Comment  */  }  
EDAN65,  2014,  Lecture  02  
                                                                                                                                41  

L02.pdf:             Course  overview  
                                                                                                          runtime system  
                                                                        source  code  (text)  
    Regular                     Lab  1    Lexical  analyzer                                           activation
                                                                          This  lecture                                     stack  
  expressions
 (scanner)                                                    records  
                                                                        tokens  
 Context-­‐free                 Lab  1   SyntacHc  analyzer  
                                                                          Next  lecture                                    garbage
   grammar
 (parser)  
                                                                                                                               collection  
                                                                        AST  (Abstract  syntax  tree)  
   ARribute                                                                                                                   heap  
                                               SemanHc  analyzer  
   grammar
 objects  
                                                                        ARributed  AST  
                                                 Intermediate  
                                                                                                                Interpreter

                                                code  generator  
                                                                        intermediate  code                                   code
                                                                                                                   Virtual      and
                                                   OpHmizer                                                     machine
 data  
                                                                        intermediate  code  
                                                  Target  code  
                                                                                                                 machine
                                                   generator  
EDAN65,  2014,  Lecture  02                                       target  code  
                                                                                                                                      42  

L02.pdf:                                      Summary  quesHons  
•  What  is  a  formal  language?  
•  What  is  a  regular  expression?  
•  What  is  meant  by  an  ambiguous  lexical  deﬁniHon?  
•  Give  some  typical  examples  of  ambiguiHes  and  how  they  may  be  resolved.  
•  What  is  a  lexical  acHon?  
•  Give  an  example  of  how  to  construct  an  NFA  for  a  given  lexical  deﬁniHon  
•  Give  an  example  of  how  to  construct  a  DFA  for  a  given  NFA  
•  What  is  the  diﬀerence  between  a  DFA  and  and  NFA?  
•  Give  an  example  of  how  to  implement  a  DFA  in  Java.  
•  How  is  rule  priority  handled  in  the  implementaHon?  Longest  match?  EOF?  
   Whitespace?  Errors?  
•  What  are  lexical  states?  When  are  they  useful?  
You  can  start  on  Assignment  1  now.  But  you  will  have  to  wait  unHl  the  next  lecture  
for  the  parts  about  parsing.  
EDAN65,  2014,  Lecture  01  
                                                                                                                                       43  

L03.pdf:  EDAN65:  Compilers,  Lecture  03  
Context-­‐free  grammars,  
introduc@on  to  parsing  
         Görel  Hedin  
        Revised:  2015-­‐09-­‐07  

L03.pdf:     Course  overview  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac@c  analyzer  
                                              This  lecture                                    garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 ASribute                                                                                         heap  
                   Seman@c  analyzer  
 grammar
 objects  
                                            ASributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op@mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L03.pdf:               Analyzing  program  text  
                     AssignStmt  
                            Exp  
parse tree  
                               Add  
                            Exp      Exp  
tokens          ID EQ    ID PLUS ID SEMI

program text   sum =    sum       +   k      ;

                                                   3  

L03.pdf:  Recall:  Genera@ng  the  compiler:  
                                                                                                     text  
  Regular                          Scanner  generator                  Lexical  analyzer  
expressions
 JFlex                               (scanner)  
                                                                                                     tokens  
Context-­‐free                        Parser  generator               Syntac@c  analyzer  
 grammar
 Beaver                                (parser)  
                                                                                                     tree  
 ASribute                         ASribute  evaluator  
                                                                            Seman@c  analyzer  
 grammar
 generator  
              We  will  use  a  parser  generator  called  Beaver  
                                                                                                                4  

L03.pdf:Context-­‐Free  Grammars  
                               5  

L03.pdf:    Regular  Expressions  vs  Context-­‐Free  Grammars  
Example  REs:                        Example  CFG:  
WHILE = "while"
 Stmt -> WhileStmt

ID = [a-z][a-z0-9]*
 Stmt -> AssignStmt

LPAR = "("
 WhileStmt -> WHILE LPAR Exp RPAR Stmt

RPAR = ")"
 Exp -> ID

PLUS = "+"
 Exp -> Exp PLUS Exp

...
 ...

                                     An  RE  can  have  itera'on  
  
                               A  CFG  can  also  have  recursion  
               (it  is  possible  to  derive  a  symbol,  e.g.,  Stmt,  from  itself)  
                                                                                                              6  

L03.pdf:    Elements  of  a  Context-­‐Free  Grammar  
                     Example  CFG:  
                     Stmt -> WhileStmt

                     Stmt -> AssignStmt

                     WhileStmt -> WHILE LPAR Exp RPAR Stmt

                     AssignStmt -> ID EQ Exp SEMIC

                     …

                                            Produc'on  rules:  
                                             X -> s1 s2 … sn

                       where  sk  is  a  symbol  (terminal  or  nonterminal)  
  
                                   Nonterminal  symbols  
  
                            Terminal  symbols  (tokens)  
  
                                                  Start  symbol  
(one  of  the  nonterminals,  usually  the  le]-­‐hand  side  of  the  ﬁrst  produc@on)  
                                                                                                                  7  

L03.pdf:Shorthand  for  alterna@ves  
      Stmt -> WhileStmt

      Stmt -> AssignStmt

         is  equivalent  to  
 Stmt -> WhileStmt | AssignStmt

                                    8  

L03.pdf:                               Exercise  
 Construct  a  grammar  covering  the  following  program:  
    Example  program:  
    while (k <= n) {sum = sum + k; k = k+1;}



    CFG:  
    Stmt -> WhileStmt | AssignStmt | CompoundStmt

    WhileStmt -> "while" "(" Exp ")" Stmt

    AssignStmt -> ID "=" Exp ";"

    CompoundStmt -> ...

    Exp -> ...

    LessEq -> ...

    Add -> ...



  
(O]en,  simple  tokens  are  wriSen  directly  as  text  strings)  
                                                                                      9  

L03.pdf:                           Solu@on  
Construct  a  grammar  covering  the  following  program:  
   Example  program:  
   while (k <= n) {sum = sum + k; k = k+1;}



   CFG:  
   Stmt -> WhileStmt | AssignStmt | CompoundStmt

   WhileStmt -> "while" "(" Exp ")" Stmt

   AssignStmt -> ID "=" Exp ";"

   CompoundStmt -> "{" Stmt* "}"

   Exp -> LessEq | Add | ID | INT

   LessEq -> Exp "<=" Exp

   Add -> Exp "+" Exp



  
                                                                          10  

L03.pdf:                                     Parsing  
           Use  the  grammar  to  derive  a  tree  for  a  program:  
                                 Stmt                           Start  symbol  
Example  program:  
sum = sum + k;



                            sum = sum + k ;
 11  

L03.pdf:                                                  Parse  tree  
             Use  the  grammar  to  derive  a  parse  tree  for  a  program:  
                                                  Stmt              Start  symbol  
Example  program:  
sum = sum + k;



                                               AssignStmt  
                                                                       Nonterminals  are  
   A  parse  tree  includes  all           Exp                   inner  nodes  
   the  tokens  as  leafs.  
                                                            Add  
                                                      Exp   Exp  
                                             sum = sum + k ;
 Terminals  are  leafs           12  

L03.pdf:            Corresponding  abstract  syntax  tree  
                 (will  be  discussed  in  later  lecture)    
                                  AssignStmt  
Example  program:  
sum = sum + k;



                                                             An  abstract  syntax  tree  is  similar  
                                                             to  a  parse  tree,  but  simpler.  
  
                                                             It  does  not  include  all  the  tokens.  
                                         Add  
                        IdExp     IdExp   IdExp  
                          sum = sum + k ;
 13  

L03.pdf:                       EBNF  vs  Canonical  Form  
                                          (Extended)  Backus-­‐Naur  Form:  
EBNF:                                   •  Compact,  easy  to  read  and  write  
Stmt -> AssignStmt | CompoundStmt
 •  EBNF  has  alterna@ves,  repe@@on,  
AssignStmt -> ID "=" Exp ";"
 op@onals,  parentheses  (like  REs)  
CompoundStmt -> "{" Stmt* "}"
 •  Common  nota@on  for  prac@cal  use  
Exp -> Add | ID

Add -> Exp "+" Exp

                                          Canonical  form:  
Canonical  form:                      •  Core  formalism  for  CFGs  
Stmt -> ID "=" Exp ";"
 •  Useful  for  proving  proper@es  and  
Stmt -> "{" Stmts "}"
 explaining  algorithms  
Stmts -> ε

Stmts -> Stmt Stmts

Exp -> Exp "+" Exp

Exp -> ID

                                                                                                14  

L03.pdf:                                        Real  world  example:  
                               The  Java  Language  Speciﬁca@on  
                  Compila@onUnit:  
      [PackageDeclara@on]  {ImportDeclara@on}  {TypeDeclara@on}  
  
                  PackageDeclara@on:  
      {PackageModiﬁer}  package  Iden@ﬁer  {.  Iden@ﬁer}  ;  
  
                  PackageModiﬁer:  
      Annota@on  
  
                  …  
See  http://docs.oracle.com/javase/specs/jls/se8/html/index.html  
•  See  Chapter  2  about  the  Java  grammar  nota@on.  
•  Look  at  some  other  chapters  to  see  other  syntax  examples.  
                                                                                                  15  

L03.pdf:Formal  deﬁni@on  of  CFGs  
                                     16  

L03.pdf:Formal  deﬁni@on  of  CFGs  (canonical  form)  
 A context-free grammar G = (N, T, P, S), where

 N – the set of nonterminal symbols

 T – the set of terminal symbols

 P – the set of production rules, each with the form

          X -> Y1 Y2 … Yn

      where X ∈ N, and Yk ∈ N ∪ T

 S – the start symbol (one of the nonterminals). I.e., S ∈ N

 So, the left-hand side X of a rule is a nonterminal.



 And the right-hand side Y1 Y2 … Yn is a sequence of
 nonterminals and terminals.



 If the rhs for a production is empty, i.e., n = 0, we write

          X -> ε

                                                               17  

L03.pdf:   A  grammar  G  deﬁnes  a  language  L(G)  
A context-free grammar G = (N, T, P, S), where

N – the set of nonterminal symbols

T – the set of terminal symbols

P – the set of production rules, each with the form

          X -> Y1 Y2 … Yn

        where X ∈ N, and Yk ∈ N ∪ T

S – the start symbol (one of the nonterminals). I.e., S ∈ N

G defines a language L(G) over the alphabet T



T* is the set of all possible sequences of T symbols.



L(G) is the subset of T* that can be derived from the start
symbol S, by following the production rules P.

                                                              18  

L03.pdf:                              Exercise  
G = (N, T, P, S)
 L(G) = {




P = {


    Stmt -> ID "=" Exp ";",


    Stmt -> "{" Stmts "}" ,


    Stmts -> ε ,


    Stmts -> Stmt Stmts ,


    Exp -> Exp "+" Exp ,


    Exp -> ID


}





N={                      }





T={                     }





S =
 }

                                           19  

L03.pdf:                                       Solu@on  
G = (N, T, P, S)
 L(G) = {


 "{" "}",

P = {
 "{" "{" "}" "}",

    Stmt -> ID "=" Exp ";",
 ID "=" ID ";",

    Stmt -> "{" Stmts "}" ,
 "{" ID "=" ID ";" "}",

    Stmts -> ε ,
 ID "=" ID "+" ID ";",

    Stmts -> Stmt Stmts ,
 "{" "{" "}" "{" "}" "}",

    Exp -> Exp "+" Exp ,
 "{" ID "=" ID "+" ID ";" "}",

    Exp -> ID
 ID "=" ID "+" ID "+" ID ";",

}
 ...




N = {Stmt, Exp, Stmts}





T = {ID, "=", "{", "}", ";", "+"}





S = Stmt
 }

   The  sequences  in  L(G)  are  usually  called  sentences  or  strings  
                                                                                                20  

L03.pdf:Deriva@ons  
               21  

L03.pdf:                   Deriva@on  step  
If we have a sequence of terminals and nonterminals,
e.g.,



    X a Y Y b



we can replace one of the nonterminals, applying a
production rule. This is called a derivation step.
L03.pdf:                        Deriva@on  
A derivation, is simply a sequence of derivation steps, e.g.:



   γ0 => γ1 => … => γn     (n ≥ 0)



where each γi is a sequence of terminals and nonterminals

If there is a derivation from γ0 to γn, we can write this as



   γ0 =>* γn



So this means it is possible to get from the sequence γ0 to
the sequence γn by following the production rules.

                                                                 23  

L03.pdf:        Deﬁni@on  of  the  language  L(G)  
Recall that:



     G = (N, T, P, S)



     T* is the set of all possible sequences of T symbols.



     L(G) is the subset of T* that can be derived from the

     start symbol S, by following the production rules P.

Using the concept of derivations, we can formally define L(G)
as follows:



   L(G) = { w ∈ T* | S =>* w }



                                                              24  

L03.pdf:                              Exercise:  
     Prove  that  a  sentence  belongs  to  a  language  
Prove that
 belongs to the language of

 the following grammar:

   INT + INT * INT


                                 p1:
 Exp -> Exp "+" Exp

                                 p2:
 Exp -> Exp "*" Exp

                                 p3:
 Exp -> INT

Proof (by showing all the derivation steps from the start
symbol Exp):



Exp

=>









                                                                          25  

L03.pdf:                              Solu@on:  
     Prove  that  a  sentence  belongs  to  a  language  
Prove that
 belongs to the language of

 the following grammar:

   INT + INT * INT


                                 p1:
 Exp -> Exp "+" Exp

                                 p2:
 Exp -> Exp "*" Exp

                                 p3:
 Exp -> INT

Proof (by showing all the derivation steps from the start
symbol Exp):



Exp

=> Exp "+" Exp
 (p1)

=> INT "+" Exp
 (p3)

=> INT "+" Exp "*" Exp
 (p2)

=> INT "+" INT "*" Exp
 (p3)

=> INT "+" INT "*" INT
 (p3)

                                                                          26  

L03.pdf:      Le]most  and  rightmost  deriva@ons  
In a leftmost derivation, the          In a rightmost derivation, the
leftmost nonterminal is                rightmost nonterminal is
replaced in each derivation            replaced in each derivation
step, e.g.,:
 step, e.g.,:




Exp =>
 Exp =>

Exp "+" Exp =>
 Exp "+" Exp =>

INT "+" Exp =>
 Exp "+" Exp "*" Exp =>

INT "+" Exp "*" Exp =>
 Exp "+" Exp "*" INT =>

INT "+" INT "*" Exp =>
 Exp "+" INT "*" INT =>

INT "+" INT "*" INT
 INT "+" INT "*" INT

LL parsing algorithms use leftmost derivation.

LR parsing algorithms use rightmost derivation.

Will be discussed in later lectures.

                                                                      27  

L03.pdf:A  deriva@on  corresponds  to  building  a  parse  tree  
      Grammar:
 Exercise: build the parse tree

         Exp -> Exp "+" Exp
 (also called derivation tree).

         Exp -> Exp "*" Exp

         Exp -> INT

      Example derivation:



      Exp =>

      Exp "+" Exp =>

      INT "+" Exp =>

      INT "+" Exp "*" Exp =>

      INT "+" INT "*" Exp =>

      INT "+" INT "*" INT

                                                                          28  

L03.pdf:A  deriva@on  corresponds  to  building  a  parse  tree  
      Grammar:
 Parse tree (derivation tree):

         Exp -> Exp "+" Exp

         Exp -> Exp "*" Exp

         Exp -> INT

                                                Exp  
      Example derivation:


 Exp   "+"      Exp  
      Exp =>

      Exp "+" Exp =>
 INT  
      INT "+" Exp =>
 Exp   "*"   Exp  
      INT "+" Exp "*" Exp =>

      INT "+" INT "*" Exp =>

                                                  INT             INT  
      INT "+" INT "*" INT

                                                                            29  

L03.pdf:Ambigui@es  
               30  

L03.pdf:                                   Exercise:  
   Can  we  do  another  deriva@on  of  the  same  sentence,  
                  that  gives  a  diﬀerent  parse  tree?  
Grammar:
 Parse tree:

   Exp -> Exp "+" Exp

   Exp -> Exp "*" Exp

   Exp -> INT

Another derivation:



Exp =>











                                                                                 31  

L03.pdf:                                   Solu@on:  
   Can  we  do  another  deriva@on  of  the  same  sentence,  
                  that  gives  a  diﬀerent  parse  tree?  
Grammar:
 Parse tree:

   Exp -> Exp "+" Exp

   Exp -> Exp "*" Exp

                                                                Exp  
   Exp -> INT

Another derivation:
 Exp   "*"   Exp  


Exp =>
 INT  
Exp "*" Exp =>
 Exp   "+"   Exp  
Exp "+" Exp "*" Exp =>

INT "+" Exp "*" Exp =>
 INT             INT  
INT "+" INT "*" Exp =>

INT "+" INT "*" INT

              Which  parse  tree  would  we  prefer?  
                                                                                  32  

L03.pdf:      Ambiguous  context-­‐free  grammars  
A CFG is ambiguous if a sentence in the language can
be derived by two (or more) different parse trees.



A CFG is unambiguous if each sentence in the
language can be derived by only one parse tree.



(Swedish: tvetydig, otvetydig )



Note! There can be many different derivations that
give the same parse tree.

                                                     33  

L03.pdf:   How  can  we  know  if  a  CFG  is  ambiguous?  
If we find an example of an ambiguity, we know the
grammar is ambiguous.



There are algorithms for deciding if a CFG belongs
to certain subsets of CFGs, e.g. LL, LR, etc. (See later
lectures.) These grammars are unambiguous.



But in the general case, the problem is undecidable:
it is not possible to construct a general algorithm
that decides ambiguity for an arbitrary CFG.

Strategies for eliminating ambiguities, next lecture.  
                                                                      34  

L03.pdf:Parsing  
            35  

L03.pdf:              Diﬀerent  parsing  algorithms  
                           Unambiguous  
                              LR  
                               LL                    Ambiguous  
                      All  context-­‐free  grammars  
LL:
 LR:

Left-to-right scan
 Left-to-right scan

Leftmost derivation
 Rightmost derivation

Builds tree top-down
 Builds tree bottom-up

Simple to understand
 More powerful

                                                                           36  

L03.pdf:    CompoundStmt  
                                LL  and  LR  parsers:  
          IfStmt  
                                       main  idea  
        Id        Assign                            Id        Assign  
                                                                     Id  Id  
... if ID then ID = ID ; ID ...
 ... if ID then ID = ID ; ID ...

     LL(1): decides to build Assign                  LR(1): decides to build Assign
     after seeing the first token of                 after seeing the first token
     its subtree.
 following its subtree.

     The tree is built top down.
 The tree is built bottom up.

                               The token is called lookahead.

                        LL(k) and LR(k) use k lookahead tokens.  
                                                                                    37  

L03.pdf:                          Recursive-­‐descent  parsing  
A  way  of  programming  an  LL(1)  parser  by  recursive  method  calls  
      Assume  an  EBNF  grammar  with  exactly  one  produc@on  
      rule  for  each  nonterminal  symbol.  
  
      For  each    nonterminal,  a  method  is  constructed.  
  
      A  nonterminal  method  matches  tokens  and  calls  other  
      nonterminal  methods,  according  to  the  grammar.  
  
      If  the  lookahead  token  does  not  match,  an  error  is  
      reported.  
                                        A     -> B | C | D

                                        B    ->  e C f D

                                        C    ->  ...

                                        D    ->  ...
 38  

L03.pdf:Example  Java  implementa@on:  overview  
            statement -> assignment | compoundStmt

            assignment-> ID ASSIGN expr SEMICOLON

            compoundStmt -> LBRACE statement* RBRACE

            ...

  class Parser {

      private int token;
 // current lookahead token

      void accept(int t) {...}
 // accept t and read in next token

      void error(String str) {...}
 // generate error message

      void statement() {...}

      void assignment () {...}

      void compoundStmt () {...}

      ...















  }

                                                                          39  

L03.pdf:Example:  recursive  descent  methods  
            statement -> assignment | compoundStmt

            assignment-> ID ASSIGN expr SEMICOLON

            compoundStmt -> LBRACE statement* RBRACE

class Parser {

    void statement() {

        switch(token) {

            case ID: assignment(); break;

            case LBRACE: compoundStmt(); break;

            default: error("Expecting statement, found: " + token);

        }

    }

    void assignment() {

        accept(ID); accept(ASSIGN); expr(); accept(SEMICOLON);

    }

    void compoundStmt() {

        accept(LBRACE);

        while (token!=RBRACE) { statement(); }

        accept(RBRACE);

    }

    ...

}
 40  

L03.pdf:       Example:  Parser  skeleton  details  
           statement -> assignment | compoundStmt

           assignment-> ID ASSIGN expr SEMICOLON

           compoundStmt -> LBRACE statement* RBRACE

           expr -> ...

class Parser {

    final static int ID=1, WHILE=2, DO=3, ASSIGN=4, ...;

    private int token;
 // current lookahead token

    void accept(int t) {
 // accept t and read in next token

       if (token==t) {

           token = nextToken();

       } else {

           error("Expected " + t + " , but found " + token);

       }

    }

    void error(String str) {...}
 // generate error message

    private int nextToken() {...} // read next token from scanner

    void statement() ...

    ...



}

                                                                         41  

L03.pdf:         Are  these  grammars  LL(1)?  
 expr -> name params | name
 Common  preﬁx  
 expr -> expr "+" term
 Le]  recursion  
What  would  happen  in  a  recursive-­‐descent  parser?  
            Could  they  be  LL(2)?          LL(k)?  
                                                                         42  

L03.pdf:Dealing  with  common  preﬁx  of  limited  length:  
                          Local  lookahead  
       LL(2)  grammar:

       statement -> assignment | compoundStmt | callStmt

       assignment-> ID ASSIGN expr SEMICOLON

       compoundStmt -> LBRACE statement* RBRACE

       callStmt -> ID LPAR expr RPAR SEMICOLON

   void statement() ...

























                                                                   43  

L03.pdf:Dealing  with  common  preﬁx  of  limited  length:  
                                 Local  lookahead  
            LL(2)  grammar:

            statement -> assignment | compoundStmt | callStmt

            assignment-> ID ASSIGN expr SEMICOLON

            compoundStmt -> LBRACE statement* RBRACE

            callStmt -> ID LPAR expr RPAR SEMICOLON

   void statement() {

       switch(token) {

           case ID:

             if (lookahead(2) == ASSIGN) {

                 assignment();

             } else {

                 callStmt();

             }

             break;

           case LBRACE: compoundStmt(); break;

           default: error("Expecting statement, found: " + token);

       }

   }

                                                                     44  

L03.pdf:  Genera@ng  the  parser:  
                                                                    tokens  
Context-­‐free                           Syntac@c  analyzer  
                   Parser  generator  
 grammar
 (parser)  
                                                                    tree  
                                                                               45  

L03.pdf:   Beaver:  an  LR-­‐based  parser  generator  
                                                                 tokens  
 Context-­‐free  
  grammar,  
                         Beaver       Parser  in  Java  
with  seman@c  
ac@ons  in  Java
 tree  
                                                                            46  

L03.pdf:                             Example  beaver  speciﬁca@on  
           %class "LangParser";

           %package "lang";

           ...

           %terminals LET, IN, END, ASSIGN, MUL, ID, NUMERAL;



           %goal program; // The start symbol



           // Context-free grammar

           program = exp;

           exp = factor | exp MUL factor;

           factor = let | numeral | id;

           let = LET id ASSIGN exp IN exp END;

           numeral = NUMERAL;

           id = ID;

Later  on,  we  will  extend  this  speciﬁca@on  with  seman@c  ac@ons  to  build  the  syntax  tree.  
                                                                                                                                47  

L03.pdf:Regular  Expressions  vs  Context-­‐Free  Grammars  
                      RE
 CFG

Typical
L03.pdf:     The  Chomsky  hierarchy  of  formal  grammars  
         Grammar
 Rule patterns
 Type

          regular
 X -> aY or X -> a or X -> ε
 3

     context free
 X -> γ
 2

  context sensitive
 α X β -> α γ β
 1

         arbitrary
 γ -> δ
 0

Type(3)  ⊂  Type  (2)  ⊂  Type(1)  ⊂  Type(0)  
  
Regular  grammars  have  the  same  power  as  regular  expressions  
(tail  recursion  =  itera@on).  
  
Type  2  and  3  are  of  prac@cal  use  in  compiler  construc@on.  
Type  0  and  1  are  only  of  theore@cal  interest.  
                                                                                                49  

L03.pdf:     Course  overview  
                                                                           source  code  (text)  
                Regular                          Lexical  analyzer  
              expressions
 (scanner)  
                                                                           tokens  
              Context-­‐free                    Syntac@c  analyzer  
               grammar
 (parser)  
                                                                           AST  (Abstract  syntax  tree)  
               ASribute  
                                                  Seman@c  analyzer  
               grammar

What  we  have  covered:  
  Context-­‐free  grammars,  derivaGons,  parse  trees  
  Ambiguous  grammars  
  IntroducGon  to  parsing,  recursive-­‐descent  
  
You  can  now  ﬁnish  assignment  1  
                                                                                                                   50  

L03.pdf:                                     Summary  ques@ons  
•  Construct  a  CFG  for  a  simple  part  of  a  programming  language.  
•  What  is  a  nonterminal  symbol?  A  terminal  symbol?  A  produc@on?  A  start  
   symbol?  A  parse  tree?  
•  What  is  a  le]-­‐hand  side  of  a  produc@on?  A  right-­‐hand  side?  
•  Given  a  grammar  G,  what  is  meant  by  the  language  L(G)?  
•  What  is  a  deriva@on  step?  A  deriva@on?  A  le]most  deriva@on?  A  righmost  
   deriva@on?  
•  How  does  a  deriva@on  correspond  to  a  parse  tree?  
•  What  does  it  mean  for  a  grammar  to  be  ambiguous?  Unambiguous?  
•  Give  an  example  an  ambiguous  CFG.  
•  What  is  the  diﬀerence  between  an  LL  and  an  LR  parser?  
•  What  is  the  diﬀerence  between  LL(1)  and  LL(2)?  Or  between  LR(1)  and  LR(2)?  
•  Construct  a  recursive  descent  parser  for  a  simple  language.  
•  Give  typical  examples  of  grammars  that  cannot  be  handled  by  a  recursive-­‐
   descent  parser.  
•  Explain  why  context-­‐free  grammars  are  more  powerful  than  regular  
   expressions.  
•  In  what  sense  are  context-­‐free  grammars  "context-­‐free"?  
                                                                                                                 51  

L04.pdf:        EDAN65:  Compilers,  Lecture  04  
      Grammar  transforma=ons:  
Elimina=ng  ambigui=es,  adap=ng  to  LL  parsing  
                   Görel  Hedin  
                  Revised:  2015-­‐09-­‐08  

L04.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac=c  analyzer  
                                                                                                   garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 ASribute                                                                                         heap  
                   Seman=c  analyzer  
 grammar
 objects  
                                            ASributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op=mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L04.pdf:Ambiguous  grammars  
                          3  

L04.pdf:       Recall:  the  deﬁni=on  of  ambiguity  
Grammar:
 A  CFG  is  ambiguous  if  there  is  a  sentence  
  Exp -> Exp "+" Exp
 in  the  language  that  can  be  derived  by  
  Exp -> Exp "*" Exp
 two  (or  more)  diﬀerent  parse  trees.  
  Exp -> INT

            Exp                                                 Exp  
   Exp   "+"      Exp                              Exp   "*"     Exp  
   INT                                                                       INT  
              Exp   "*"   Exp          Exp   "+"   Exp  
              INT             INT          INT                INT  
                                                                                                              4  

L04.pdf:       Strategies  for  elimina=ng  ambigui=es  
We should try to eliminate ambiguities, without changing the
language.



First, decide which parse tree is the desired one.



Normal strategy:

Create an equivalent unambiguous grammar from which only the
desired parse tree can be derived.



Alternative strategy:

Use additional priority and associativity rules to instruct the
parser to derive the desired parse tree.

Works for some ambiguities.

Supported by some parser generators.

                                                                5  

L04.pdf:               Equivalent  grammars  
Two grammars, G1 and G2, are equivalent if they
generate the same language.



I.e., a sentence can be derived from one of the
grammars, iff it can be derived also from the other
grammar:



                   L(G1) = L(G2)



                                                    6  

L04.pdf:            Common  kinds  of  ambigui=es  
•  Operators  with  diﬀerent  priori=es:  
          a  +  b  *  c  ==  d,  ...  
•  Associa=vity  of  operators  of  the  same  priority:  
          a  +  b  –  c  +  d,  ...  
•  Dangling  else:  
          if  (a)  
          if  (b)  c  =  d;  
          else  e  =  f;  
                                                                         7  

L04.pdf:   Example  ambiguity:                                     Exp -> Exp "+" Exp

                                                               Exp -> Exp "*" Exp

Priority  (also  called  precedence)                   Exp -> INT

                    Two parse trees for INT "+" INT "*" INT

                    Exp                                            Exp  
        Exp       "+"     Exp                         Exp   "*"   Exp  
        INT                                                                  INT  
                      Exp   "*"   Exp        Exp   "+"   Exp  
                      INT             INT        INT             INT  
           prio("*") > prio("+")
 prio("+") > prio("*")

       (according to tradition)               (would be unexpected and confusing)  
                                                                                        8  

L04.pdf:Example  ambiguity:                               Exp
                                                      Exp
                                                             ->
                                                             ->
                                                                Exp "+" Exp

                                                                Exp "-" Exp

            Associa4vity                            Exp    -> Exp "**" Exp

                                                      Exp    -> INT

                    For operators with the same priority,

                    how do several in a sequence associate?

                  Exp                                    Exp  
         Exp   "+"    Exp                 Exp   "**"     Exp  
                           INT                  INT  
Exp   "-"   Exp                                      Exp   "**"   Exp  
INT             INT                                      INT             INT  
        Left-associative
 Right-associative

(usual for most operators)                 (usual for the power operator)  
                                                                                        9  

L04.pdf:Example  ambiguity:                                Exp -> Exp "<" Exp

                                                       Exp -> INT

    Non-­‐associa4vity  
           For some operators, it does not make sense to have

           several in a sequence at all. They are non-associative.

                                                     Exp  
                   Exp  
                                            Exp   "<"     Exp  
           Exp   "<"   Exp  
                                            INT  
                            INT                     Exp   "<"   Exp  
  Exp   "<"   Exp  
                                                      INT             INT  
  INT            INT  
                       We would like to forbid both trees.

              I.e., rule out the sentence from the langauge.  
                                                                                10  

L04.pdf:      Disambigua=ng  expression  grammars  
How can we change the grammar so that only the desired
trees can be derived?



Idea: Restrict certain subtrees by introducing new
nonterminals.

Priority: Introduce a new nonterminal for each priority level:
Term, Factor, Primary, ...



Left associativity: Restrict the right operand so it only can
contain expressions of higher priority



Right associativity: Restrict the left operand ...



Non-associativity: Restrict both operands

                                                               11  

L04.pdf:                        Exercise  
Ambiguous grammar:
 Equivalent unambiguous grammar:




Expr -> Expr "+" Expr


Expr -> Expr "*" Expr


Expr -> INT


Expr -> "(" Expr ")"











                                                            12  

L04.pdf:                                                        Solu=on  
     Ambiguous grammar:
 Equivalent unambiguous grammar:




     Expr -> Expr "+" Expr
 Expr -> Expr "+" Term

     Expr -> Expr "*" Expr
 Expr -> Term

     Expr -> INT
 Term -> Term "*" Factor

     Expr -> "(" Expr ")"
 Term -> Factor


 Factor -> INT

                                                                Factor -> "(" Expr ")"



Here,  we  introduce  a  new  nonterminal,  Term,  that  is  more  restricted  than  Expr.  
That  is,  from  Term,  we  can  not  derive  any  new  addi=ons.  
  
For  the  addi=on  produc=on,  we  use  Term  as  the  right  operand,  to  make  sure  no  new  
addi=ons  will  appear  to  the  right.  This  gives  le_-­‐associa=vity.  
  
For  the  mul=plica=on  produc=on,  we  use  Term,  and  the  even  more  restricted  
nonterminal  Factor  to  make  sure  no  addi=ons  can  appear  as  children  (without  using  
parentheses).  This  gives  mul=plica=on  higher  priority  than  addi=on.    
                                                                                                                                  13  

L04.pdf:Real-­‐world  example:  The  Java  expression  grammar  
  Expression -> LambdaExpression | AssignmentExpression

  AssignmentExpression -> ConditionalExpression | Assignment

  ConditionalExpression -> ...



  AdditiveExpression ->

        MultiplicativeExpression

     | AdditiveExpression + MultiplicativeExpression

     | AdditiveExpression – MultiplicativeExpression



  MultiplicativeExpression ->

        UnaryExpression

     | MultiplicativeExpression * UnaryExpression

     | ...



  UnaryExpression -> ...

  ...

  Primary -> PrimaryNoNewArray | ArrayCreationExpression

  PrimaryNoNewArray -> Literal | this | ( Expression ) | FieldAccess ...

       More  than  15  priority  levels.  
       See  the  Java  Language  Speciﬁca=on,  Java  SE  8,  Chapter  19,  Syntax  
       hSp://docs.oracle.com/javase/specs/jls/se8/html/jls-­‐19.html                                    14  

L04.pdf:                        The  "dangling  else"  problem  
              S -> "if" "(" E ")" S ["else" S]

              S -> ID "=" E ";"

              E -> ID

              Construct a         if (a)

              parse tree for:   if (b) c = d;

                                  else e = f;

The desired tree      S       Two possible parse trees!
 S  
                                        The grammar is

                                           ambiguous!  
if (a)
 if (a)

  if (b)
 if (b)

     c = d;
 S                                     S                c = d;

  else
 else

     e = f;
 e = f;

    if (a) if (b) c = d; else e = f;
 if (a) if (b) c = d; else e = f;

                                                                                            15  

L04.pdf:     Solu=ons  to  the  "dangling  else"  problem  
  Rewrite to equivalent unambiguous grammar

  - possible, but results in more complex grammar





  Use the ambiguous grammar

  -  use "rule priority", the parser can select the correct rule.

  -  works for the dangling else problem, but not for ambiguous
      grammars in general

  -  not all parser generators support it well





  Change the language

  -  e.g., add a keyword "fi" that closes the "if"-statement

  -  restrict the "then" part to be a block: "{ ... }".

  -  only an option if you are designing the language yourself.

The Java Language Specification rewrites the grammar to be unambiguous.  
                                                                            16  

L04.pdf:EBNF,  BNF,  Canonical  form  
                                       17  

L04.pdf:      Recall:  diﬀerent  nota=ons  for  CFGs  
A -> B d e C f
 Canonical  form  
A -> g A
 •  sequence  of  terminals  and  nonterminals  
                                BNF  (Backus-­‐Naur  Form)  
C -> D a b | b E F | a C
 •  alterna=ve  produc=ons  (  ...  |  ...  |  ...  )  
G -> H* i | (d E)+ F | [d C]
 EBNF  (Extended  Backus-­‐Naur  Form)  
                                •  repe44on  (*  and  +)  
                                •  op4onals  [...]  
                                •  parentheses  (...)  
                                                                                                         18  

L04.pdf:    Wri=ng  the  grammar  in  diﬀerent  nota=ons  
                          Equivalent BNF (Backus-Naur Form):





Canonical form:





Expr -> Expr "+" Term


Expr -> Term
 Use  alterna4ves  instead  of  several  
Term -> Term "*" Factor
 produc=ons  per  nonterminal.  
Term -> Factor

Factor -> INT

Factor -> "(" Expr ")"
 Equivalent EBNF (Extended BNF):












                          Use  repe44on  instead  of  recursion,  
                          where  possible.  
                                                                             19  

L04.pdf:    Wri=ng  the  grammar  in  diﬀerent  nota=ons  
                          Equivalent BNF (Backus-Naur Form):



                          Expr -> Expr "+" Term | Term

Canonical form:
 Term -> Term "*" Factor | Factor


 Factor -> INT | "(" Expr ")"

Expr -> Expr "+" Term


Expr -> Term
 Use  alterna4ves  instead  of  several  
Term -> Term "*" Factor
 produc=ons  per  nonterminal.  
Term -> Factor

Factor -> INT

Factor -> "(" Expr ")"
 Equivalent EBNF (Extended BNF):




                          Expr -> Term ("+" Term)*

                          Term -> Factor ("*" Factor)*

                          Factor -> INT | "(" Expr ")"



                          Use  repe44on  instead  of  recursion,  
                          where  possible.  
                                                                             20  

L04.pdf:          Transla=ng  EBNF  to  Canonical  form  
EBNF                                          Equivalent  canonical  form  
Top level repetition


X -> γ1 γ2* γ3




Top level alternative


X -> γ1 | γ2


Top level parentheses


X -> γ1 (...) γ2


Where  γk  is  a  sequence  of  terminals  and  nonterminals  
                                                                                    21  

L04.pdf:         Transla=ng  EBNF  to  Canonical  form  
EBNF                         Equivalent  canonical  form  
Top level repetition
 X -> γ1 N γ3

X -> γ1 γ2* γ3
 N -> ε

                                N -> γ2 N

Top level alternative
 X -> γ1

X -> γ1 | γ2
 X -> γ2

Top level parentheses
 X -> γ1 N γ2

X -> γ1 (...) γ2
 N -> ...

                                                                   22  

L04.pdf:                            Exercise:  
        Translate  from  EBNF  to  Canonical  form  
EBNF:
 Equivalent Canonical Form




Expr -> Term ("+" Term)*








                                                                 23  

L04.pdf:                           Solu=on:  
        Translate  from  EBNF  to  Canonical  form  
EBNF:
 Equivalent Canonical Form




Expr -> Term ("+" Term)*
 Expr -> Term N

                               N -> ε

                               N -> "+" Term N

                                                                 24  

L04.pdf:     Can  we  prove  that  these  are  equivalent?  
                               Equivalent Canonical Form



                 trivial     Expr -> Term N

                               N -> ε

                               N -> "+" Term N



EBNF:



Expr -> Term ("+" Term)*

                               Alternative Equivalent Canonical Form



            non-­‐trivial    Expr -> Expr "+" Term

                               Expr -> Term

                                                                       25  

L04.pdf:    Example  proof  
1. We start with this:
 2. We can move the repetition:

Expr -> Term ("+" Term)*
 Expr -> (Term "+")* Term

                           3. Eliminate the repetition:

                           Expr -> N Term

                           N -> ε

                           N -> N Term "+"

                           4. Replace N Term by Expr in
                           the third production:

                           Expr -> N Term

                           N -> ε

                           N -> Expr "+"

We would like this:
 5. Eliminate N:

Expr -> Expr "+" Term
 Expr -> Expr "+" Term

Expr -> Term
 Expr -> Term

                           Done!  
                                                            26  

L04.pdf:          Equivalence  of  grammars  
   Given two context-free grammars, G1 and G2.

               Are they equivalent?



               I.e., is L(G1) = L(G2)?

               Undecidable problem:
L04.pdf:Adap=ng  grammars  to  LL  parsing  
                                               28  

L04.pdf:                         Recall:  LL(1)  parsing  
 Assign  
                                                Assign -> ID = Exp ;

                                                Exp -> Name Params | Name | ...

        Exp                                   Name -> ID ( . ID )*

         ?    What node should be built?  
                                                Common prefix!

  ID = ID.ID; ID = ID.ID( ID );
 Cannot be handled by LL(1).

                                                This grammar is not even LL(k).  
LL(1): decides to build the node after
seeing the first token of its subtree.

The tree is built top down.

                                                                              29  

L04.pdf:              Elimina=ng  the  common  preﬁx  
Rewrite  to  an  equivalent  grammar  without  the  common  preﬁx    
  Exp -> Name Params | Name

With common prefix - not LL(1)

                                                                                          30  

L04.pdf:              Elimina=ng  the  common  preﬁx  
Rewrite  to  an  equivalent  grammar  without  the  common  preﬁx    
  Exp -> Name Params | Name
 Exp -> Name OptParams

                                                  OptParams -> Params | ε

With common prefix - not LL(1)
 Without common prefix - LL(1)

                   Eliminating a common prefix this way is
                            called "left factoring".

                                                                                          31  

L04.pdf:                                       Exercise  
If  two  produc=ons  of  a  nonterminal  can  derive  a  sentence  
      star=ng  in  the  same  way,  they  share  a  common  preﬁx.  
      A ->   s B

      A ->   s C

      B ->  t

      C ->  u

      A -> B s

      A -> B t

      B -> u v

      A ->   s B

      B ->  s C

      B ->  t C

      C ->   u

  Which  nonterminals  have  common  preﬁx  produc=ons?  
What  is  the  common  preﬁx?  Is  the  grammar  LL(1),  LL(2),  ...?  
                                                                                              32  

L04.pdf:                                       Solu=on  
If  two  produc=ons  of  a  nonterminal  can  derive  a  sentence  
      star=ng  in  the  same  way,  they  share  a  common  preﬁx.  
      A ->   s B
 A has two rules that can derive the prefix s

      A ->   s C
 The grammar is LL(2)

      B ->  t

      C ->  u

      A -> B s
 A has two rules that can derive the prefix u v

      A -> B t
 The grammar is LL(3)

      B -> u v

      A ->   s B
 This is not a common prefix problem. The two
      B ->  s C
 rules that start the same cannot be derived
      B ->  t C
 from the same nonterminal.

      C ->   u
 The grammar is LL(1)

  Which  nonterminals  have  common  preﬁx  produc=ons?  
What  is  the  common  preﬁx?  Is  the  grammar  LL(1),  LL(2),  ...?  
                                                                                              33  

L04.pdf:     The  common  preﬁx  can  be  indirect  
A -> B
 A has two rules that can derive the prefix t

A -> C
 The grammar is LL(2)

A -> D

B -> t s

C -> t v

D -> x

A -> B s
 A has two rules that can derive the prefix v u*

A -> B t
 So, the prefix can become arbitrarily long.

B -> B u
 The grammar is not LL(k), no matter what k we use.

B -> v
 We need to rewrite the grammar, or use another parsing
            method. (LR has no problem with common prefixes)

Which  nonterminals  have  common  preﬁx  produc=ons?  
                What  is  the  common  preﬁx?  
              Is  the  grammar  LL(1),  LL(2),  ...?  
                                                                    34  

L04.pdf:               Elimina=ng  the  common  preﬁx  
 Rewrite  to  an  equivalent  grammar  without  the  common  preﬁx    
A   ->  B

A   ->  C

B   -> t s

B   -> x D

B   -> y

C   -> t v

D   -> B C



Indirect
common
   prefix

                                                                                           35  

L04.pdf:               Elimina=ng  the  common  preﬁx  
 Rewrite  to  an  equivalent  grammar  without  the  common  preﬁx    
                                                                      A   -> t s

A   ->  B
 First, make the common prefix
                                                                      A   -> x D

A   ->  C
 directly visible:

                                                                      A   -> y

B   -> t s


                                                                      B   -> t s

B   -> x D
 Substitute all B right-hand sides
                                                                      B   -> x D

B   -> y
 into the A -> B rule

                                                                      B   -> y

C   -> t v


                                                                      A   -> t v

D   -> B C
 We can't remove the B rules since
                                                                      C   -> t v


 B is used in other places.

                                                                      D   -> B C





Indirect                 Similarly for the A -> C rule  
common                                                                   Direct
   prefix
 common
                                                                         prefix

             Then, eliminate the direct common prefix, as previously.  
                                                                                           36  

L04.pdf:                          Le_  recursion  
assign  
                                             assign -> ID "=" expr ";"

                                             expr -> expr "+" term | term

     expr                                  term -> ID

        ?   What node should be built?  
ID = ID + ID + ID ;

                          The grammar is left recursive.

                          The grammar is not LL(k).

                          An LL parser would go into endless recursion.



                          (LR parsers can handle left recursion.)  
                                                                            37  

L04.pdf:         Dealing  with  le_  recursion  in  LL  parsers  
                  Method  1:  Eliminate  the  le_  recursion  
                             (A  bit  cumbersome)    
 Left-recursive grammar.                   E -> E "+" T

 Not LL(k)
 E -> T

                                           T -> ID

 Rewrite to right-recursion!               E -> T "+" E

 But there is now a common
 E -> T

 prefix! Still not LL(k).
 T -> ID

 Eliminate the common prefix.
 E -> T E'

 The grammar is now LL(1)
 E' -> "+" E

                                           E' -> ε

                                           T -> ID

With a little work, it is possible to write code that builds a left-recursive AST,

even if the parse is right-recursive.

                                                                                   38  

L04.pdf:       Dealing  with  le_  recursion  in  LL  parsers  
                     Method  2:  Rewrite  to  EBNF  
                                  (Easy!)  
Left-recursive grammar.              E -> E "+" T

Not LL(k)
 E -> T

                                     T -> ID

Rewrite to EBNF!
 E -> T ( "+" T )*

                                     T -> ID

A left-recursive AST can easily be built during the iteration.

                                                                      39  

L04.pdf:Advice  when  using  an  LL-­‐based  parser  generator  
If the parser generator does not accept your grammar, the reason
might be



•  Ambiguity – usually eliminate it. In some cases, rule priority can
   be used.

•  Left recursion – can you use EBNF instead? Otherwise, eliminate.

•  Common prefix – is it limited? You can then use a local lookahead,
   for example 2. Otherwise, factor out the common prefix.



You might be able to solve the problem, but the grammar might
become large and less readable.

                                                                       40  

L04.pdf:              Diﬀerent  parsing  algorithms  
                           Unambiguous  
                              LR  
                               LL                    Ambiguous  
                      All  context-­‐free  grammars  
LL:
 LR:

Left-to-right scan
 Left-to-right scan

Leftmost derivation
 Rightmost derivation

Builds tree top-down
 Builds tree bottom-up

Simple to understand
 More powerful

                                                                           41  

L04.pdf:                          LL(k)  vs  LR(k)  
                              LL(k)                          LR(k)  
   Parses input
 Left-to-right

     Derivation
 Leftmost
 Rightmost

     Lookahead
 k symbols

  Build the tree
 top down
 bottom up

    Select rule
 after seeing its first
L04.pdf:                                 Summary  ques=ons  
•  What  does  it  mean  for  a  grammar  to  be  ambiguous?  
•  What  does  it  mean  for  two  grammars  to  be  equivalent?  
•  Exemplify  some  common  kinds  of  ambigui=es.  
•  Exemplify  how  expression  grammars  with  can  be  disambiguated.  
•  What  is  the  "dangling  else"-­‐problem,  and  how  can  it  be  solved?  
•  When  should  we  use  canonical  form,  and  when  BNF  or  EBNF?  
•  Translate  an  example  EBNF  grammar  to  canonical  form.  
•  Can  we  write  an  algorithm  to  check  if  two  grammars  are  equivalent?  
•  What  is  a  ”common  preﬁx”?  
•  Exemplify  how  a  common  preﬁx  can  be  eliminated.  
•  What  is  ”le_  factoring”?  
•  What  is  ”le_  recursion”?  
•  Exemplify  how  le_  recursion  can  be  eliminated  in  a  grammar  on  canonical  
   form.  
•  Exemplify  how  le_  recursion  can  be  eliminated  using  EBNF.  
•  Can  LL(k)  parsing  algorithms  handle  common  preﬁxes  and  le_  recursion?  
•  Can  LR(k)  parsing  algorithms  handle  common  preﬁxes  and  le_  recursion?  
                                                                                                                43  

L05A.pdf:    EDAN65:  Compilers,  Lecture  05  A  
             LL  parsing  
Nullable,  FIRST,  and  FOLLOW  
               Görel  Hedin  
              Revised:  2015-­‐09-­‐14  

L05A.pdf:                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   SyntacMc  analyzer   LL  parsing  
                                                                                                   garbage
 grammar
 (parser)          Nullable,  FIRST,  FOLLOW  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 ATribute                                                                                         heap  
                   SemanMc  analyzer  
 grammar
 objects  
                                            ATributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       OpMmizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                                target  code  
                                                                                                              2  

L05A.pdf:    Algorithm  for  construcMng  an  LL(1)  parser  
    Fairly simple.



    The non-trivial part: how to select the correct
    production p for X, based on the lookahead token.

           X                 p1: X -> ...

                               p2: X -> ...

                               Which tokens can occur in the FIRST position?



                               Can one of the productions derive the empty
...    t1 ...    tn tn+1 ...
 string? I.e., is it "NULLABLE"?

                               If so, which tokens can occur in the FOLLOW
                               position?

     FIRST       FOLLOW  
                                                                           3  

L05A.pdf:    Steps  in  construcMng  an  LL(1)  parser  
1.  Write the grammar on canonical form

2.  Analyze the grammar to construct a table.
L05A.pdf:                                   Example:  
              Construct  the  LL(1)  table  for  this  grammar:  
                   p1: statement -> assignment

                   p2: statement -> compoundStmt

                   p3: assignment -> ID "=" expr ";"

                   p4: compoundStmt -> "{" statements "}"

                   p5: statements -> statement statements

                   p6: statements -> ε

                                   ID     "="     ";"        "{"   "}"  
            statement  
            assignment  
            compoundStmt  
            statements  
For each production p: X -> γ, we are interested in:

  FIRST(γ) – the tokens that occur first in a sentence derived from γ.

  NULLABLE(γ) – is it possible to derive ε from γ? And if so:

  FOLLOW(X) – the tokens that can occur immediately after an X-sentence.

                                                                                    5  

L05A.pdf:                                   Example:  
              Construct  the  LL(1)  table  for  this  grammar:  
                    p1: statement -> assignment

                    p2: statement -> compoundStmt

                    p3: assignment -> ID "=" expr ";"

                    p4: compoundStmt -> "{" statements "}"

                    p5: statements -> statement statements

                    p6: statements -> ε

                                   ID     "="     ";"        "{"   "}"  
            statement            p1                              p2  
            assignment           p3  
            compoundStmt                                          p4  
            statements          p5                              p5   p6  
To construct the table, look at each production p: X -> γ.

Compute the token set FIRST(γ). Add p to each corresponding entry for X.

Then, check if γ is NULLABLE. If so, compute the token set FOLLOW(X),

and add p to each corresponding entry for X.

                                                                                    6  

L05A.pdf:                          Example:  
                   Dealing  with  End  of  File:  


            p1: varDecl -> type ID optInit

            p2: type -> "integer"

            p3: type -> "boolean" "=" expr ";"

            p4: optInit -> "=" INT

            p5: optInit -> ε

            ID   integer   boolean     "="     ";"   INT  
varDecl  
type  
optInit  
                                                                       7  

L05A.pdf:                          Example:  
                   Dealing  with  End  of  File:  
            p0: S -> varDecl EOF

            p1: varDecl -> type ID optInit

            p2: type -> "integer"

            p3: type -> "boolean" "=" expr ";"

            p4: optInit -> "=" INT

            p5: optInit -> ε

            ID   integer   boolean     "="     ";"   INT   EOF

S  
varDecl  
type  
optInit  
                                                                             8  

L05A.pdf:                           Example:  
                   Dealing  with  End  of  File:  
             p0: S -> varDecl EOF

             p1: varDecl -> type ID optInit

             p2: type -> "integer"

             p3: type -> "boolean" "=" expr ";"

             p4: optInit -> "=" INT

             p5: optInit -> ε

            ID   integer   boolean     "="     ";"   INT   EOF

S                   p0
 p0

varDecl             p1
 p1

type                p2
 p3

optInit                                     p4
 p5

                                                                             9  

L05A.pdf:          Example:  
      Ambiguous  grammar:  
        p1: E -> E "+" E

        p2: E -> ID

        p3: E -> INT

            "+"      ID   INT

E  
                                    10  

L05A.pdf:              Example:  
        Ambiguous  grammar:  
           p1: E -> E "+" E

           p2: E -> ID

           p3: E -> INT

               "+"       ID          INT

  E                     p1,  p2   p1,  p3  
        Collision in a table entry!

         The grammar is not LL(1)



An ambiguous grammar is not even LL(k) –

  adding more lookahead does not help.  
                                                      11  

L05A.pdf:                Example:  
Unambiguous,  but  le]-­‐recursive  grammar:  
           p1: E -> E "*" F

           p2: E -> F

           p3: F -> ID

           p4: F -> INT

                 "*"       ID    INT

    E  
    F  
                                                       12  

L05A.pdf:                  Example:  
Unambiguous,  but  le]-­‐recursive  grammar:  
               p1: E -> E "*" F

               p2: E -> F

               p3: F -> ID

               p4: F -> INT

                   "*"       ID      INT

      E                     p1,p2   p1,p2  
      F                      p3       p4  
            Collision in a table entry!

            The grammar is not LL(1)



 A grammar with left-recursion is not even LL(k) –

      adding more lookahead does not help.  
                                                       13  

L05A.pdf:                  Example:  
      Grammar  with  common  preﬁx:  
            p1: E -> F "*" E

            p2: E -> F

            p3: F -> ID

            p4: F -> INT

            p5: F -> "(" E ")"

          "*"     ID    INT   "("     ")"

E  
F  
                                                    14  

L05A.pdf:                          Example:  
             Grammar  with  common  preﬁx:  
                    p1: E -> F "*" E

                    p2: E -> F

                    p3: F -> ID

                    p4: F -> INT

                    p5: F -> "(" E ")"

                 "*"       ID      INT     "("    ")"

       E                  p1,p2   p1,p2   p1,p2  
       F                   p3       p4     p5  
                 Collision in a table entry!

                 The grammar is not LL(1)



        A grammar with common prefix is not LL(1).

Some grammars with common prefix are LL(k), for some k, –

                         but not this one.  
                                                                15  

L05A.pdf:   Summary:  construcMng  an  LL(1)  parser  
1.  Write the grammar on canonical form

2.  Analyze the grammar using FIRST, NULLABLE, and
    FOLLOW.

3.  Use the analysis to construct a table.
L05A.pdf:            S      Recall  main  parsing  ideas  
      A             X                                              A                       X  
                                                                                                B   C  
  t r u v r u r u ...
 t r u v r u r u ...

LL(1): decides to build X after seeing                         LR(1): decides to build X after seeing
the first token of its subtree.
 the first token following its subtree.

The tree is built top down.
 The tree is built bottom up.

                    For  each  producMon  X -> γ we  need  to  compute  
               FIRST(γ):  the  tokens  that  can  appear  ﬁrst  in  a  γ derivaMon  
                  NULLABLE(γ):  can  the  empty  string  be  derived  from  γ?  
                  FOLLOW(X):  the  tokens  that  can  follow  an  X  derivaMon  
                                                                                                            17  

L05A.pdf:Algorithm  for  construcMng  an  LL(1)  table  
initialize all entries table[Xi, tj] to the empty set.



for each production p: X -> γ

   for each t ∈ FIRST(γ)

     add p to table[X, t]

   if NULLABLE(γ)

     for each t ∈ FOLLOW(X)

           add p to table[X, t]

                 t1     t2    t3     t4  
    X1         p1     p2  
    X2                  p3    p3     p4  
If some entry has more than one element, then
the grammar is not LL(1).

                                                            18  

L05A.pdf:Exercise:  what  is  NULLABLE(X)?  
 Z -> d
 NULLABLE  
 Z -> X Y Z
 X  
 Y -> ε

 Y -> c
 Y  
 X -> Y
 Z  
 X -> a

                                             19  

L05A.pdf:SoluMon:  what  is  NULLABLE(X)  
 Z -> d
 NULLABLE  
 Z -> X Y Z
 X            true

 Y -> ε

 Y -> c
 Y            true

 X -> Y
 Z            false

 X -> a

                                           20  

L05A.pdf:               DeﬁniMon  of  NULLABLE  
                                 Informally:

     NULLABLE(γ): true if the empty string can be derived from γ

         where γ is a sequence of terminals and nonterminals

                    Formal definition, given G=(N,T,P,S)

NULLABLE(ε) == true
 (1)



NULLABLE(t) == false
 (2)

   where t ∈ T, i.e., t is a terminal symbol



NULLABLE(X) == NULLABLE(γ1) || ... || NULLABLE(γn)
 (3)

   where X -> γ1, ... X -> γn are all the productions for X in P



NULLABLE(sγ) == NULLABLE (s) && NULLABLE (γ)
 (4)

   where s ∈ N U T, i.e., s is a nonterminal or a terminal

             The equations for NULLABLE are recursive.

    How would you write a program that computes NULLABLE(X)?

     Just using recursive functions could lead to nontermination!

                                                                           21  

L05A.pdf:                      Fixed-­‐point  problems  
Computing NULLABLE(X) is an example of a fixed-point problem.



These problems have the form:



   x == f(x)



Can we find a value x for which the equation holds (i.e., a solution)?

x is then called a fixed point of the function f.

Fixed-point problems can (sometimes) be solved using iteration:

Guess an initial value x0, then apply the function iteratively, until the
fixed point is reached:



x1 := f(x0);

x2 := f(x1);

...

xn := f(xn-1);



until xn== xn-1



This is called a fixed-point iteration, and xn is the fixed point.

                                                                          22  

L05A.pdf: Implement  NULLABLE  by  a  ﬁxed-­‐point  iteraMon  
represent NULLABLE as an array nlbl[ ] of boolean variables

initialize all nlbl[X] to false



repeat

   changed = false

   for each nonterminal X with productions X -> γ1, ..., X -> γn do

     newValue = nlbl(γ1) || ... || nlbl(γn)

     if newValue != nlbl[X] then

          nlbl[X] = newValue

          changed = true

     fi

   do

until !changed



where nlbl(γ) is computed using the current values in nlbl[ ].

The computation will terminate because

- the variables are only changed monotonically (from false to true)

- the number of possible changes is finite (from all false to all true)

                                                                          23  

L05A.pdf:          Exercise:  compute  NULLABLE(X)  
                   nlbl[ ]  
Z -> d
 iter0   iter1    iter2   iter3  
Z -> X Y Z
 X            f

Y -> ε

Y -> c
 Y            f

X -> Y
 Z            f

X -> a

In each iteration, compute:  
for each nonterminal X with productions X -> γ1, ..., X -> γn

   newValue = nlbl(γ1) || ... || nlbl(γn)

where nlbl(γ) is computed using the current values in nlbl[ ].

                                                                           24  

L05A.pdf:          SoluMon:  compute  NULLABLE(X)  
                   nlbl[ ]  
Z -> d
 iter0   iter1    iter2   iter3  
Z -> X Y Z
 X            f
 f
 t
 t

Y -> ε

Y -> c
 Y            f
 t
 t
 t

X -> Y
 Z            f
 f
 f
 f

X -> a

In each iteration, compute:  
for each nonterminal X with productions X -> γ1, ..., X -> γn

   newValue = nlbl(γ1) || ... || nlbl(γn)

where nlbl(γ) is computed using the current values in nlbl[ ].

                                                                           25  

L05A.pdf:                       DeﬁniMon  of  FIRST  
                                  Informally:

   FIRST(γ): the tokens that can occur as the first token in sentences
                                derived from γ

                     Formal definition, given G=(N,T,P,S)

FIRST(ε) == ∅
 (1)



FIRST(t) == { t }
 (2)

    where t ∈ T, i.e., t is a terminal symbol



FIRST(X) == FIRST(γ1) ∪ ... ∪ FIRST(γn)
 (3)

    where X -> γ1, ... X -> γn are all the productions for X in P



FIRST(sγ) == FIRST(s) ∪ (if NULLABLE(s) then FIRST(γ) else ∅ fi)
 (4)

    where s ∈ N U T, i.e., s is a nonterminal or a terminal

                  The equations for FIRST are recursive.

                   Compute using fixed-point iteration.

                                                                            26  

L05A.pdf:      Implement  FIRST  by  a  ﬁxed-­‐point  iteraMon  
represent FIRST as an array FIRST[ ] of token sets

initialize all FIRST[X] to the empty set



repeat

   changed = false

   for each nonterminal X with productions X -> γ1, ..., X -> γn do

     newValue = FIRST(γ1) ∪ ... ∪ FIRST(γn)

     if newValue != FIRST[X] then

          FIRST[X] = newValue

          changed = true

     fi

   do

until !changed



where FIRST(γ) is computed using the current values in FIRST[ ].

The computation will terminate because

- the variables are changed monotonically (using set union)

- the largest possible set is finite: T, the set of all tokens

- the number of possible changes is therefore finite
 27  

L05A.pdf:             SoluMon:  compute  FIRST(X)  
Z -> d
 NULLABLE  
Z -> X Y Z
 X          t

Y -> ε

Y -> c
 Y          t

X -> Y
 Z          f

X -> a

                   FIRST[ ]  
                                iter0      iter1   iter2   iter3  
                   X          ∅

                   Y          ∅

                   Z          ∅

In each iteration, compute:  
for each nonterminal X with productions X -> γ1, ..., X -> γn

   newValue = FIRST(γ1) ∪ ... ∪ FIRST(γn)

where FIRST(γ) is computed using the current values in FIRST[ ].

                                                                           28  

L05A.pdf:             Exercise:  compute  FIRST(X)  
Z -> d
 NULLABLE  
Z -> X Y Z
 X          t

Y -> ε

Y -> c
 Y          t

X -> Y
 Z          f

X -> a

                   FIRST[ ]  
                                iter0      iter1     iter2     iter3  
                   X          ∅
 {a}
 {a, c}
 {a, c}

                   Y          ∅
 {c}
 {c}
 {c}

                   Z          ∅
 {a, c, d}
 {a, c, d}
 {a, c, d}

In each iteration, compute:  
for each nonterminal X with productions X -> γ1, ..., X -> γn

   newValue = FIRST(γ1) ∪ ... ∪ FIRST(γn)

where FIRST(γ) is computed using the current values in FIRST[ ].

                                                                                 29  

L05A.pdf:                     DeﬁniMon  of  FOLLOW  
                                  Informally:

    FOLLOW(X): the tokens that can occur as the first token following X,
           in any sentential form derived from the start symbol S.

                      Formal definition, given G=(N,T,P,S)

The nonterminal X occurs in the right-hand side of a number of
productions.



Let Y -> γ X δ denote such an occurrence, where γ and δ are arbitrary
sequences of terminals and nonterminals.



    FOLLOW(X) == U FOLLOW(Y -> γ X δ ),
 (1)

      over all occurrences Y -> γ X δ



    and where

    FOLLOW(Y -> γ X δ ) ==
 (2)

      FIRST(δ) ∪ (if NULLABLE(δ) then FOLLOW(Y) else ∅ fi)

                  The equations for FOLLOW are recursive.

                     Compute using fixed-point iteration.

                                                                              30  

L05A.pdf:   Implement  FOLLOW  by  a  ﬁxed-­‐point  iteraMon  
represent FOLLOW as an array FOLLOW[ ] of token sets

initialize all FOLLOW[X] to the empty set



repeat

   changed = false

   for each nonterminal X do

     newValue == U FOLLOW(Y -> γ X δ ), for each occurrence Y -> γ X δ

     if newValue != FOLLOW[X] then

          FOLLOW[X] = newValue

          changed = true

     fi

   do

until !changed



where FOLLOW(Y -> γ X δ ) is computed using the current values in
FOLLOW[ ].

Again, the computation will terminate because

- the variables are changed monotonically (using set union)

- the largest possible set is finite: T
 31  

L05A.pdf:                    Exercise:  compute  FOLLOW(X)  
     S  ->  Z $
 NULLABLE      FIRST  
     Z  ->  d
 X     t
 {a, c}

     Z  ->  X Y Z

     Y  ->  ε
 Y     t
 {c}

     Y  ->  c
 Z     f
 {a, c, d}

     X  ->  Y

     X  ->  a
 FOLLOW[ ]  
The grammar has                         iter0     iter1   iter2   iter3  
been extended with        X           ∅

end of file, $.  
                          Y           ∅

                          Z           ∅

     In each iteration, compute:  
     newValue ==      U FOLLOW(Y -> γ X δ ), for each occurrence Y -> γ X δ

     where FOLLOW(Y -> γ X δ ) is computed using the current values in
     FOLLOW[ ].

                                                                                  32  

L05A.pdf:                    SoluMon:  compute  FOLLOW(X)  
     S  ->  Z $
 NULLABLE   FIRST  
     Z  ->  d
 X    t
 {a, c}

     Z  ->  X Y Z

     Y  ->  ε
 Y    t
 {c}

     Y  ->  c
 Z    f
 {a, c, d}

     X  ->  Y

     X  ->  a
 FOLLOW[ ]  
The grammar has                         iter0     iter1     iter2     iter3  
been extended with        X           ∅
 {c}
 {a, c, d}
 {a, c, d}

end of file, $.  
                          Y           ∅
 {a, c, d}
 {a, c, d}
 {a, c, d}

                          Z           ∅
 {$}
 {$}
 {$}

     In each iteration, compute:  
     newValue ==      U FOLLOW(Y -> γ X δ ), for each occurrence Y -> γ X δ

     where FOLLOW(Y -> γ X δ ) is computed using the current values in
     FOLLOW[ ].

                                                                                        33  

L05A.pdf:                                        Summary  quesMons  
•  Construct  an  LL(1)  table  for  a  grammar.  
•  What  does  it  mean  if  there  is  a  collision  in  an  LL(1)  table?  
•  Why  can  it  be  useful  to  add  an  end-­‐of-­‐ﬁle  rule  to  some  grammars?  
•  How  can  we  decide  if  a  grammar  is  LL(1)  or  not?  
•  What  is  the  deﬁniMon  of  NULLABLE,  FIRST,  and  FOLLOW?  
•  What  is  a  ﬁxed-­‐point  problem?  
•  How  can  it  be  solved  using  iteraMon?  
•  How  can  we  know  that  the  computaMon  terminates?  
                                                                                                                34  

L05B.pdf:EDAN65:  Compilers,  Lecture  05  B  
 Abstract  grammars  
  
           Görel  Hedin  
         Revised:  2015-­‐09-­‐13  

L05B.pdf:     This  lecture  
                                                                             runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac'c  analyzer   LR  parsing                                        garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 ASribute                                                                                         heap  
                   SemanKc  analyzer  
 grammar
 objects  
                                            ASributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       OpKmizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  

L05B.pdf:Abstract  grammars  
L05B.pdf:  Parse  tree                               Abstract  tree  
     Stmt                                     AssignStmt  
                Includes  all  tokens                  Includes  important  tokens  
                                                              Simple  natural  structure  
  AssignStmt                                                        Typed  nodes  
          Exp  
               Add                                          Add  
          Exp   Exp  
                                              IdExp   IdExp   IdExp  
sum = sum + k ;
 sum        sum          k


L05B.pdf:                       Example:  Concrete  vs  Abstract  
     Concrete grammar                                         Abstract grammar  
     Exp -> Exp "+" Term
 Add: Exp -> Exp Exp

     Exp -> Term
 IdExp: Exp -> ID

     Term -> ID

                                                       Productions are named!  
                     Exp                                                       Add  
            Exp                                                    IdExp   IdExp  
                                                                       ID
 ID

         Term                Term  
           ID
 +
 ID

                                                              An  abstract  grammar  cannot  
Note!  Term,  Factor,  are  needed  to  make    be  ambiguous.  Term  and  
the  concrete  grammar  unambiguous.                  Factor  is  irrelevant  here.  

L05B.pdf:             Concrete  vs  Abstract  grammar  
                       Concrete Grammar
 Abstract Grammar

What does it           Describes the concrete   Describes the abstract
describe?
 text representation of   structure of programs

                       programs

Main use
 Parsing text to trees
 Model representing the
                                                program inside compiler.

Underlying formalism
 Context-free grammar
 Recursive data types

What is named?
 Only nonterminals        Both nonterminals and
                       (productions are usually productions.

                       anonymous)

What tokens occur in   all tokens corresponding usually only tokens with
the grammar?
 to "words" in the text
 values (identifiers,
                                                literals)

                       Independent of           Independent of parser
                       abstract structure
 and parser algorithm


L05B.pdf:            Abstract  grammar  vs.  OO  model  
Abstract grammar
 OO model
 Other terminology used
                                                  (algebraic datatypes)

   nonterminal
 superclass
 type, sort

    production
 subclass
 constructor, operator

                                                Exp

Abstract grammar  
Add: Exp -> Exp Exp

IdExp: Exp -> ID

                                         Add
 IdExp

  A canonical abstract grammar corresponds to a two-level class hierarchy!  

L05B.pdf:           Example  Java  implementaKon  
Abstract grammar  
Add: Exp -> Exp Exp

IdExp: Exp -> ID

                                abstract class Exp {

            Exp
 }

                                class Add extends Exp {

                                    Exp exp1, exp2;

                                }

                                class IdExp extends Exp {

    Add
 IdExp

                                    String ID;

                                }


L05B.pdf:                                 JastAdd  
  •  A compiler generation tool. Generates Java code.

  •  Supports ASTs and modular computations on ASTs.

  •  JastAdd: "Just add computations to the ast"

  •  Independent of the parser used.

  •  Developed at LTH, see http://jastadd.org

Parser specification                                   Parser  
  L.beaver
 Beaver
 *.ast

                                                           *.java

Abstract grammar                                            creates objects  
     *.ast

       *.ast

                                JastAdd
 *.ast

                                                           *.java

     *.ast
 AST classes  
      *.jrag

Computations  

L05B.pdf:                JastAdd  abstract  grammars  
          (compared  to    canonical  abstract  grammars)  
Program ::= Stmt*;

abstract Stmt;

Assignment : Stmt ::= IdExpr Expr;

IfStmt : Stmt ::= Expr Then:Stmt [Else:Stmt];

abstract Expr;

IdExpr : Expr ::= <ID:String>;

IntExpr : Expr ::= <INT:String>;

BinExpr : Expr ::= Left:Expr Right:Expr;

Add : BinExpr;

•  Classes instead of nonterminals and productions

•  Classes can be abstract (like in Java)

•  Arbitrarily deep inheritance hierarchy (not just two levels)

•  Support for optional, list, and token components

•  Components can be named

•  Right-hand side can be inherited from superclass (see BinExpr).

•  No parentheses! You need to name all node classes in the AST.


L05B.pdf:       Generated  Java  API,  ordinary  components  
abstract Stmt;

WhileStmt : Stmt ::= Cond:Expr Stmt;
 WhileStmt  
                                                 getCond()    getStmt()  
abstract class Stmt extends ASTNode {}
 Expr   Stmt  


                                                      Example AST  
class WhileStmt extends Stmt {

    Expr getCond();

    Stmt getStmt();

}

•  A general class ASTNode is used as implicit superclass.

•  A traversal API with get methods is generated.

•  If component names are given, they are used in the API (getCond).

•  Otherwise the type names are used (getStmt).


L05B.pdf:                     Generated  Java  API,  lists  
 Program ::= Stmt*;

                                                                     Program  
                                                                           getStmts()  
 class Program extends ASTNode {
 List<Stmt>  
     int getNumStmt(); // 0 if empty

     Stmt getStmt(int i); // numbered from 0

     List<Stmt> getStmts(); // iterator
 Stmt        Stmt             Stmt  
 }

                                                                  Example AST  
The list is represented by a List object
that can be used as an iterator:
 Or access a specific statement:

 Program p = ...;
 Program p = ...;

 for (Stmt s : p.getStmts()) {
 if (p.getNumStmt() >= 1) {

     ...
 Stmt s = p.getStmt(0);

 }
 ...

                                               }


L05B.pdf:                Generated  Java  API,  opKonals  
A ::= B [C];

                                                           A  
class A extends ASTNode {
 B         Opt<C>  
    B getB();

    boolean hasC();

    C getC();     //Exception if not hasC()
 C  
}

                                                      Example AST  
•  The traversal API includes a has method for the optional component.


L05B.pdf:                              Inheritance  
                                            ASTNode

       Abstract
       grammar  
       A ::= B [C];

       B ::= ...;
 A
 B
 C
 Opt
 List

       C ::= ...;

       D : A ::= ...;

                                  D

Low-­‐level  traversal  API  
Will stop also at Opt and List nodes.

Can be used for general traversals of the AST.

Otherwise, use the high-level API – much more readable.

class ASTNode extends SimpleNode {

    int getNumChild();

   ASTNode getChild(int i);

   ASTNode getParent(); // null for the root

}


L05B.pdf:ConnecKon  to  Beaver  
                                       Beaver  
  Beaver spec  
  a = b [c];
 {: return new A... :}

                                        LangParser
 beaver.Symbol

  b = ... ;
 {: return new B... :}

  c = ... ;
 {: return new C... :}

                                                  <<create>>  
  JastAdd abstract grammar  
                                                                   ASTNode

   A ::= B [C];

   B ::= ...;

   C ::= ...;

                                                      A
 B
 C
 Opt
 List

                                      JastAdd  

L05B.pdf:              Deﬁning  an  abstract  grammar  
This is object-oriented modeling!  
•  What kinds of objects are there in the AST?
L05B.pdf:                         Use  good  names!  
when you write...
 ...the following should make sense

A : B ::= ...
 An A is a special kind of B

C ::= D E F
 A C has a D, an E, and an F

D ::= X:E Y:E
 A D has one E called X and another E called Y

G ::= [H]
 A G may have an H

J ::= <K:T>
 A J has a K token of type T

L ::= M*
 An L has zero or more Ms

Examples of bad naming
 Good naming

(from inexperienced
programmers)

A ::= [OptParam];
 A ::= [Param];

OptParam ::= Name Type;
 Param ::= Name Type;

A ::= Stmts*;
 A ::= Stmt*:

abstract Stmts;
 abstract Stmt;

While : Stmts ::= Exp Stmt;
 While : Stmt ::= Exp Stmt;


L05B.pdf:             Design  simple  abstract  grammars!  
•  Abstract grammars should be clear and simple

•  Don't let parsing details creep into the abstract grammar

Bad abstract grammar
L05B.pdf:                     Design  a  parsing  grammar  
•  Design the abstract grammar first.

•  Then design a high-level concrete grammar, making it as similar as
   possible to the abstract grammar.

      •  Replace inheritance with alternative productions

      •  The grammar will probably be ambiguous

•  Then design a low-level concrete grammar, suitable for a particular
   parsing algorithm/tool.
L05B.pdf:                   SemanKc  acKons  in  parsers  
•  Code that is added to a parser, to perform actions during parsing.

•  Usually, to build the AST.

•  Old-style 1-pass compilers did the whole compilation as semantic actions.

•  Parser generators support semantic actions in the parser specification.


L05B.pdf:                           Beaver  example  
Abstract grammar
 High-level CFG

abstract Stmt;
 stmt -> ifStmt | assignment

IfStmt : Stmt ::= Expr Stmt;
 ifStmt -> IF "(" expr ")" stmt

Assignment : Stmt ::= IdExpr Expr;
 assignment -> ID ASSIGN expr

IdExpr : Expr ::= <ID:String>;

              beaver spec without semantic actions:

              %class "LangParser";

              %package "lang";

              ...

              %terminals IF, LPAREN, RPAREN, ID, ASSIGN;



              %goal stmt; // The start symbol



              // Context-free grammar

              stmt = ifStmt | assignment;

              ifStmt = IF LPAREN expr RPAREN stmt;

              assignment = ID ASSIGN expr;


L05B.pdf:                 Beaver  example                                     Abstract grammar

                                                                         abstract Stmt;

beaver spec with semantic actions:
 IfStmt : Stmt ::= Expr Stmt;

%class "LangParser";
 Assignment : Stmt ::= IdExpr Expr;

%package "lang";
 IdExpr : Expr ::= <ID:String>;

...

%terminals IF, LPAREN, RPAREN, ID, ASSIGN;



%goal stmt; // The start symbol



%typeof stmt = "Stmt";

%typeof ifStmt = "IfStmt";

%typeof assignment = "Assignment";



// Context-free grammar

stmt = ifStmt | assignment;

ifStmt = IF LPAREN expr.e RPAREN stmt.s; {: return new IfStmt(e, s); :}

assignment =

       ID.id ASSIGN expr.e; {: return new Assignment(new IdExpr(id),e); :}

seman/c  ac/ons  build  the  trees  
variables  capture  token  strings  and  subtrees  for  nonterminals  
the  nonterminals  return  objects  of  the  abstract  grammar  classes  

L05B.pdf:      Summary  quesKons:  Abstract  syntax  trees  
•  What  is  the  diﬀerence  between  an  abstract  and  a  concrete  syntax  tree?  
•  What  is  the  diﬀerence  between  an  abstract  and  a  concrete  grammar?  
•  What  is  the  correspondence  between  an  abstract  grammar  and  an  object-­‐
   oriented  model?  
•  OrientaKon  about  JastAdd  abstract  grammars,  traversal  API,  and  connecKon  to  
   Beaver.  
•  What  are  properKes  of  a  good  abstract  grammar?  
•  What  is  a  "semanKc  acKon"?  
•  How  can  Beaver  be  used  for  building  ASTs?  

L06A.pdf:EDAN65:  Compilers,  Lecture  06  A  
       LR  parsing  
            Görel  Hedin  
           Revised:  2015-­‐09-­‐14  

L06A.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac'c  analyzer   LR  parsing                                        garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 AQribute                                                                                         heap  
                   SemanIc  analyzer  
 grammar
 objects  
                                            AQributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       OpImizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L06A.pdf:LR  parsing  
                  3  

L06A.pdf:                 Recall  main  parsing  ideas  
          S  
    A           X                     A            X  
                                                        B   C  
 t r u v r u r u ...
 t r u v r u r u ...

LL(1): decides to build Assign         LR(1): decides to build Assign
after seeing the first token of        after seeing the first token
its subtree.
 following its subtree.

The tree is built top down.
 The tree is built bottom up.

                                                                      4  

L06A.pdf:         Recall  diﬀerent  parsing  algorithms  
                           Unambiguous  
                              LR  
                               LL                    Ambiguous  
                      All  context-­‐free  grammars               This  lecture  
LL:
 LR:

Left-to-right scan
 Left-to-right scan

Leftmost derivation
 Rightmost derivation

Builds tree top-down
 Builds tree bottom-up

Simple to understand
 More powerful

                                                                                            5  

L06A.pdf:                        Recall:  LL(k)  vs  LR(k)  
                                  LL(k)                          LR(k)  
    Parses input
 Left-to-right

      Derivation
 Leftmost
 Rightmost

      Lookahead
 k symbols

   Build the tree
 top down
 bottom up

     Select rule
 after seeing its first
L06A.pdf:                              LR  parsing  
Add the EOF token ($) and an extra start rule.



The parser uses a stack of symbols (terminals and nonterminals).



The parser looks at the current input token and decides to do one of
L06A.pdf:   Grammar:  
   p0: S -> Stmt $

                                 LR  parsing  example  
   p1: Stmt -> ID ":=" Exp
 Input:  
   p2: Exp -> ID
 ID := ID + ID $  
   p3: Exp -> Exp "+" ID

   Tree:        Stack:           Input:          Action:  


 ID := ID + ID $




















shift: push input to stack, read next token     reduce: pop production rhs, push lhs   8  

L06A.pdf:         Grammar:  
         p0: S -> Stmt $

                                                                          LR  parsing  example  
         p1: Stmt -> ID ":=" Exp
 Input:  
         p2: Exp -> ID
 ID := ID + ID $  
         p3: Exp -> Exp "+" ID

         Tree:                               Stack:                          Input:                                                    Action:  
    ID  :=  ID  +  ID  $  shift  ID  
ID  ID        :=  ID  +  ID  $  shift  :=  
      :=  ID  :=              ID  +  ID  $  shift  ID  
            ID  ID  :=  ID                    +  ID  $  reduce  Exp  -­‐>  ID  
            Exp  ID  :=  Exp                    +  ID  $  shift  +  
                  +  ID  :=  Exp  +                        ID  $  shift  ID  
                    ID  ID  :=  Exp  +  ID                              $  reduce  Exp  -­‐>  Exp  "+"  ID  
              Exp  ID  :=  Exp                              $  reduce  Stmt  -­‐>  ID  ":="  Exp  
      Stmt  Stmt                              $  accept    
Follow the reduction steps in reverse order. They correspond to a rightmost derivation.
 9  

L06A.pdf:                              LR(1)  items  
The parser uses a DFA (a deterministic finite automaton) to decide
whether to shift or reduce.



The states in the DFA are sets of LR items.

              LR(1) item:  
              X -> α • β
 t,s  
An LR(1) item is a production extended with:

•  A dot (•), corresponding to the position in the input sentence.

•  One or more possible lookahead terminal symbols, t,s
L06A.pdf:Grammar:  
p0: S -> E $

                                              ConstrucIng  state  1  
p1: E -> T "+" E

p2: E -> T
 First, take the start production and place
p3: T -> ID
 the dot in the beginning...

                                  Note that there is a nonterminal E right after
       S -> • E $
 ?
 the dot, and it is followed by a terminal $. Add
                                  the productions for E, with $ as the lookahead.

       S -> • E $
 ?
 Note that there is a nonterminal T right after
       E -> • T "+" E
 $
 the dot, and which is followed by either "+" or
       E -> • T
 $
 $. Add the productions for T, with "+" and $ as
                                  the lookahead. (We write them on the same line
                                  as a shorthand.)

 1   S -> •E$
 ?
 We have already added productions for all
       E -> • T "+" E
 $
 nonterminals that are right after the dot.
       E -> •T
 $
 Nothing more can be added.

       T -> • ID
 +,$
 We are finished constructing state 1.

       Adding new productions for nonterminals following the dot, until no more
       productions can be added, is called taking the closure of the LR item set.

                                                                                    11  

L06A.pdf:                      ConstrucIng  the  next  states  
Grammar:  
p0: S -> E $

p1: E -> T "+" E

p2: E -> T
 2  
p3: T -> ID
 E                      S -> E • $
 ?

 1   S -> •E$
 ?
 3  
                                     T  
       E -> • T "+" E
 $
 E -> T • "+" E
 $

       E -> •T
 $
 E -> T •
 $

       T -> • ID
 +,$

                              ID         4  
                                                 T -> ID •
 +,$

 Note that the dot is followed by E, T, and ID in state 1. For each of
 these symbols, create a new set of LR items, by advancing the dot
 passed that symbol. Then complete the states by taking the closure.

 (Nothing had to be added for these states.)
 12  

L06A.pdf:                         CompleIng  the  LR  DFA  
Grammar:  
p0: S -> E $

p1: E -> T "+" E

p2: E -> T
 2                                     6  
p3: T -> ID
 E                      S -> E • $
 ?
 E -> T "+" E •
 $

                                                                                                  E  
                                                                                5  
 1   S -> •E$
 ?
 3                             T         E -> T "+" • E
 $

       E -> • T "+" E
 $
 T         E -> T • "+" E
 $
 E -> • T "+" E
 $

       E -> •T
 $
 E -> T •
 $
 "+"         E -> • T
 $

       T -> • ID
 +,$
 T -> • ID
 +,$

                             ID         4                                          ID  
                                                T -> ID •
 +,$

 Complete the DFA by advancing the dot, creating new states,
 completing them by taking the closure. If there is already a state
 with the same items, we use that state instead.

                                                                                                           13  

L06A.pdf:                     ConstrucIng  the  LR  table  
• For each token edge t, from state j to
  state k, add a shift action "s k"
L06A.pdf:                     ConstrucIng  the  LR  table  
• For each token edge t, from state j to
  state k, add a shift action "s k"
L06A.pdf:                  Using  the  LR  table  for  parsing  
• Use a symbol stack and a state stack

• The current state is the state stack top.
 state   "+"       ID            $     E        T  
• Push state 1 to the state stack

• Perform an action for each token:
 1               s  4               g  2   g  3  
• Case Shift s:
 2                               a  
   • Push the token to the symbol stack
 3    s  5              r  p2  
   • Push s to the state stack

   • The current state is now s.
 4   r  p3              r  p3  
• Case Reduce p:
 5               s  4               g  6   g  3  
   • Pop symbols for the rhs of p
 6                          r  p1  
   • Push the lhs symbol X of p

   • Pop the same number of states

   • Let s1 = the top of the state stack

   • Let s2 = table[s1,X]

   • Push s2 to the state stack

   • The current state is now s2.

• Case Accept: Report successful parse

                                                                                                           16  

L06A.pdf:                                 Example  of  LR  parsing  
 Grammar:  
 p0: S -> E $

 p1: E -> T "+" E
 Parsing ID + ID $

 p2: E -> T

                                                                     State      Symbol       Input              ac'on  
 p3: T -> ID

                                                                      stack    stack  
Parse table:                                                     1                     ID  +  ID  $  
state   "+"
 ID
 $
 E
 T

  1                 s  4               g  2   g  3  
  2                                 a  
  3      s  5              r  p2  
  4     r  p3              r  p3  
  5                 s  4               g  6   g  3  
  6                            r  p1  
                                                                                                                       17  

L06A.pdf:                                 Example  of  LR  parsing  
 Grammar:  
 p0: S -> E $

 p1: E -> T "+" E
 Parsing ID + ID $

 p2: E -> T

                                                                     State              Symbol                   Input                         ac'on  
 p3: T -> ID

                                                                      stack             stack  
Parse table:                                                     1                                   ID  +  ID  $   shi\  4  
state   "+"
 ID
 $
 E
 T
 1  4             ID        +  ID  $   reduce  p3  
  1                 s  4               g  2   g  3   1  3             T        +  ID  $   shi\  5  
  2                                 a                          1  3  5        T  +            ID  $   shi\  4  
  3      s  5              r  p2                         1  3  5  4   T  +  ID                  $   reduce  p3  
  4     r  p3              r  p3                         1  3  5  3   T  +  T                  $   reduce  p2  
  5                 s  4               g  6   g  3   1  3  5  6   T  +  E                  $   reduce  p1  
  6                            r  p1                         1  2             E                  $   accept  
                                                                                                                                                          18  

L06A.pdf:                       Conﬂict  in  an  LR  table  
Grammar:  
                                         Parts of the parse table:  
p0: S -> E $

p1: E -> E "+" E
 state   ...
 "+"
 ...
 ...
 ...  
p2: E -> E "*" E

p3: E -> ID

                                           ...  
                                            3  
Parts of the DFA:                        ...  
    3   E -> E • "+" E
 ?

          E -> E "*" E •
 "+"

                      "+"              Fill in the parse table.  
    5  


 What is the problem?  
                                                                                     19  

L06A.pdf:                      Conﬂict  in  an  LR  table  
   Grammar:                           Parts of the parse table:  
  p0: S -> E $
 state   ...
 "+"
 ...
 ...
 ...  
  p1: E -> E "+" E

  p2: E -> E "*" E

  p3: E -> ID
 ...  
                                           3           s  5,  r  p2  
Parts of the DFA:                        ...  
   3   E -> E • "+" E
 ?

         E -> E "*" E •
 "+"

                                        There is a shift-reduce conflict.

                     "+"              The grammar is ambiguous.

                                        In this case, we can resolve the conflict
   5  
 by selecting one of the actions.




                                        To understand which one, think about
                                        what the top of the stack looks like.
                                        Think about what will happen later if we
                                        take the shift rule or the reduce rule.  
                                                                                                    20  

L06A.pdf:                     Analyzing  LR  conﬂicts  ...  
Example output from parser generator (CUP):

...
 Note! The dot is written as "(*)".

*** Shift/Reduce conflict found in state #5


   between expr ::= expr PLUS expr (*)
 Note! The parser generator
   and       expr ::= expr (*) PLUS expr
 automatically resolves the
   under symbol PLUS
 conflict by shifting.

   Resolved in favor of shifting.


...
 Is this what we want???  
Line up the dots in the state:  
expr -> expr PLUS expr •


expr ->                expr • PLUS expr


The top of stack and input may look like:  
... expr PLUS expr • PLUS expr ...

   top of stack        remaining input  
                                                                                  21  

L06A.pdf:                    ...  Analyzing  LR  conﬂicts  
   Line up the dots in the state:  
   expr -> expr PLUS expr •
 PLUS

   expr ->               expr • PLUS expr
 ?

           expr                                                  expr  
                         expr                            expr  
... expr PLUS expr • PLUS expr ...
 ... expr PLUS expr • PLUS expr ...

           If we shift                                      If we reduce  
                                  Which rule should we choose?  
                                                                                       22  

L06A.pdf:             Diﬀerent  kinds  of  conﬂicts  
   E -> E • "+" E
 ?
 A shift-reduce conflict.

   E -> E "*" E •
 "+"

   A -> B C •
 t
 A reduce-reduce conflict.

   D -> C •
 t

Shift-reduce conflicts can sometimes be solved with precedence rules.
In particular for binary expressions with priority and associativity.



For other cases, you need to carefully analyze the shift-reduce
conflicts to see if precedence rules are applicable, or if you need to
change the grammar.



For reduce-reduce conflicts, it is advisable to think through the
problems, and change the grammar.

                                                                        23  

L06A.pdf:Typical  precedence  rules  for  an  LALR  parser  generator  
  E -> E "==" E

  E -> E "**" E

  E -> E "*" E
 Shift-reduce conflicts are automatically
  E -> E "/" E
 resolved using the precedence rules.

  E -> E "+" E


  E -> E "-" E
 Operators in the same rule have the same
  E -> ID
 priority (e.g., PLUS, MINUS).

  E -> INT



 Operators in a later rule have higher priority
  precedence nonassoc EQ
 (e.g. TIMES has higher prio than PLUS.)

  precedence left PLUS, MINUS

  precedence left TIMES, DIV

  precedence right POWER

                                                                             24  

L06A.pdf:               How  the  precedence  rules  work  
   A rule is given the priority and associativity of its rightmost token.

   For two conflicting rules with different priority, the rule with the
   highest priority is chosen:

     E -> E • + E
 ?
 E -> E • * E
 ?

     E -> E * E •
 +
 E -> E + E •
 *

      Reduce is chosen
 Shift is chosen

 Two conflicting rules with the same priority have the same associativity.

 Left-associativity favors reduce.

 Right-associativity favors shift.

 Non-associativity removes both rules from the table (input following that
 pattern will cause a parse error).

E -> E + E •
 +
 E -> E ** E •
 **
 E -> E == E •
 ==

E -> E • + E
 ?
 E -> E • ** E
 ?
 E -> E • == E
 ?

Reduce is chosen
 Shift is chosen
 No rule is chosen

                                                                                         25  

L06A.pdf:          Diﬀerent  variants  of  LR(k)  parsers  
     Type                              Characteris'cs  
     LR(0)
 LR items without lookahead.

                                 Not very useful in practice.

      SLR
 Look at the FOLLOW set to decide where to put
   Simple LR
 reduce actions.

                              Can parse some useful grammars.

    LALR(1)
 Merges states that have the same LR items,
L06A.pdf:Diﬀerent  variants  of  LR  parsers  
                   Unambiguous  
                                            LR(k)  
                                  LR(1)  
                                                        Ambiguous  
                         LALR(1)  
          SLR  
LR(0)  
                                                      GLR  
                All  context-­‐free  grammars  
                                                                      27  

L06A.pdf:            Universal  parsing  algorithms  
GLR – Generalized LR



Can parse any context free grammar.



Including ambiguous grammars!



Returns a parse forest (all possible parse trees).
L06A.pdf:       Some  well-­‐known  parser  generators  
    Name                           Type,  host  language  
   JavaCC
 LL, Java

   ANTLR
 LL, Java (also earlier versions for C, C#, ...)

    yacc
 LALR, C, "yet another compiler compiler"

                              Developed for AT&T Unix in 1970.

    bison
 LALR, C++, GNU GPL

    CUP
 LALR, Java

   beaver
 LALR, Java

 SDF/SGLR
 Scannerless GLR, C, Java

For more examples, see

http://en.wikipedia.org/wiki/Comparison_of_parser_generators  
                                                                          29  

L06A.pdf:                        Summary  quesIons:  LR  parsing  
•  How  does  LR  diﬀer  from  LL  parsers?  
•  What  does  it  mean  to  shi\?  
•  What  does  it  mean  to  reduce?  
•  Explain  how  LR  parsing  works  on  an  example.  
•  What  is  an  LR  item?  
•  What  does  an  LR  state  consist  of?  
•  What  does  it  mean  to  take  the  closure  of  a  set  of  LR  items?  
•  What  do  the  edges  in  an  LR  DFA  represent?  
•  How  can  an  LR  table  be  constructed  from  an  LR  DFA?  
•  How  is  the  LR  table  used  for  parsing?  
•  What  is  meant  by  a  shi\-­‐reduce  conﬂict  and  a  reduce-­‐reduce  conﬂict?  
•  How  can  such  a  conﬂict  be  analyzed?  
•  How  can  precedence  rules  be  used  in  an  LR  parser?  
•  What  is  LR(0)  and  SLR  parsing?  
•  What  is  the  diﬀerence  between  LALR(1)  and  LR(1)?  
•  Explain  why  the  LALR(1)  algorithm  is  most  commonly  used  in  parser  generators.  
•  What  is  a  GLR  parser?  
                                                                                                                      30  

L06B.pdf:EDAN65:  Compilers,  Lecture  06  B  
            Visitors  
            Görel  Hedin  
           Revised:  2015-­‐09-­‐14  

L06B.pdf:     This  lecture  
                                                                                runtime system  
                                              source  code  (text)  
  Regular         Lexical  analyzer                                             activation
                                                                                                      stack  
expressions
 (scanner)                                                      records  
                                              tokens  
Context-­‐free   SyntacLc  analyzer  
                                                                                                     garbage
 grammar
 (parser)  
                                                                                                     collection  
                                              AST  (Abstract  syntax  tree)  
                                            Visitors                                                heap  
 ATribute                                 StaLc  aspects  
                   Seman&c  analyzer  
 grammar
 ATribute  grammars                      objects  
                                              ATributed  AST  
                     Intermediate  
                                                                                      Interpreter

                    code  generator  
                                              intermediate  code                                   code
                                                                                         Virtual      and
                       OpLmizer                                                       machine
 data  
                                              intermediate  code  
                      Target  code  
                                                                                       machine
                       generator  
                                                 target  code  
                                                                                                                2  

L06B.pdf:   Example  computaLons  on  an  AST  
                                                                  Name  analysis:  ﬁnd  the  
     ...  
                                                               declaraLon  of  an  idenLﬁer  
                    Mul  
                                                          Type  analysis:  compute  the  
                                                                type  of  an  expression  
          Div             IdExpr  
                                                    Expression  evaluaLon:  compute  the  
IdExpr          IdExpr                            value  of  a  constant  expression  
                                       Code  generaLon:  compute  an  intermediate  
                                          code  representaLon  of  the  program  
             Unparsing:  compute  a  text  
           representaLon  of  the  program  
                                                                                                      3  

L06B.pdf:Abstract grammar  
                               Exercise:  expression  evaluaLon  
abstract Expr;

BinExpr : Expr ::= Left:Expr Right:Expr;

Add : BinExpr;

Sub : BinExpr;

IntExpr : Expr ::= <INT:String>;

Generated AST classes  
abstract class Expr extends ASTNode {



}

class BinExpr extends Expr { Expr getLeft() {...} Expr getRight {...} }

class Add extends BinExpr {



}

class Sub extends BinExpr {



}

class IntExpr extends Expr {

    String getINT() {...}



}
 4  

L06B.pdf:Abstract grammar  
                                  SoluLon:  expression  evaluaLon  
abstract Expr;

                                                Problem 1: NEVER EDIT GENERATED CODE!!

BinExpr : Expr ::= Left:Expr Right:Expr;

                                                Problem 2: The code is not modular!

Add : BinExpr;
 We have to edit every AST class!

Sub : BinExpr;
 The computation of value() is a cross-cutting
IntExpr : Expr ::= <INT:String>;
 concern, leading to tangled code.  
Edited AST classes  
abstract class Expr extends ASTNode {

    abstract int value();

}

class BinExpr extends Expr { Expr getLeft() {...} Expr getRight {...} }

class Add extends BinExpr {

    int value() { return getLeft().value() + getRight().value(); }

}

class Sub extends BinExpr {

    int value() { return getLeft().value() - getRight().value(); }

}

class IntExpr extends Expr {

    String getINT() {...}

    int value() { return String.parseInt(getINT()); }

}
 5  

L06B.pdf:                  The  Expression  Problem  
•  We would like to

     •  define language constructs in a modular way.

     •  define computations in a modular way

     •  compose these modules as we like

     •  preferrably, with separate compilation of the modules

     •  and with full type safety (without need for casts)

                               Expr

Unparsing
 Value computation

for Add, Sub
 for Add, Sub

                        Add
 Sub

                                Let
 Unparsing and Value computation

                                            for Let

                                                                              6  

L06B.pdf:        Dealing  with  the  expression  problem  
•  Edit the AST classes (i.e., actually not solving the problem)

     •  Non-modular, non-compositional.

     •  It is always a VERY BAD IDEA to edit generated code!

     •  Sometimes used anyway in industry.

•  Visitors: an OO design pattern.

     •  Modularize through clever indirect calls.

     •  Not full modularization, not composition.

     •  Supported by many parser generators.

     •  Reasonably useful, commonly used in industry.

•  Static Aspect-Oriented Programming (AOP)

     •  Also known as inter-type declarations (ITDs)

     •  Use new language constructs (aspects) to factor out code.

     •  Solves the expression problem in a nice simple way.

     •  The drawback: you need a new language: AspectJ, JastAdd, ...

•  Advanced language constructs

     •  Use more advanced language constructs: virtual classes in gbeta,
        traits in Scala, typeclasses in Haskell, ...

     •  Drawbacks: More complex than static AOP. You need an advanced
        language. Not much practical experience (so far).

                This lecture: Visitors  
                                                                         7  

L06B.pdf:                            Visitors  
                How to modularize compilers in Java
L06B.pdf:                          A  simple  example  
Original code                           After adding the print method  
class Add extends Exp {
 class Add extends Exp {

    Exp e1, e2;
 Exp e1, e2;

}
 void print() {

class IntExp extends Exp {
 e1.print();

    int value;
 System.out.print("+");

}
 e2.print();

                                              }

                                          }

                                          class IntExp extends Exp {

                                              int value;

                                              void print() {

                                                   System.out.print(value);

                                              }

                                          }

Could we add the print methods, without changing the original code?  
                                                                              9  

L06B.pdf:Instead of:  
                            Main  idea  of  visitors  
                print()                                                       method call  
                                Add  
                     IntExp           IntExp  
Add some boilerplate code that allows
delegation to a Visitor object:  
accept(new PrintVisitor())                       visitAdd(this)  
                                Add  
                                                                                PrintVisitor  
                     IntExp           IntExp  
                                                          visitIntExp(this)  
                                                                                                 10  

L06B.pdf:                             Example  implementaLon  
 Original code                             General visitor  
 class Add extends Exp {
 interface Visitor {

     Exp e1, e2;
 void visitAdd(Add n);

     void accept(Visitor v) {
 void visitIntExp(IntExp n);

         v.visitAdd(this);
 }

     }

 }
 Modular addition of print  
 class IntExp extends Exp {
 class Print implements Visitor {

     int value;
 void visitAdd(Add n) {

     void accept(Visitor v) {
 n.e1.accept(this);

         v.visitIntExp(this);
 System.out.print("+");

     }
 n.e2.accept(this);

 }
 }

                                                 void visitIntExp(IntExp n) {

                                                     System.out.print(n.value);

General boilerplate code for visitors,
 }

can be generated from the grammar.         }

                                                                                  11  

L06B.pdf:            Many  implementaLons  use  Java  overloading  
                                   for  the  visit  methods  
    Original code                                       General visitor  
    class Add extends Exp {
 interface Visitor {

        Exp e1, e2;
 void visit(Add n);

        void accept(Visitor v) {
 void visit(IntExp n);

            v.visit(this);
 }

        }
 Modular addition of print  
    }

    class IntExp extends Exp {
 class Print implements Visitor {

        int value;
 void visit(Add n) {

        void accept(Visitor v) {
 n.e1.accept(this);

            v.visit(this);
 System.out.print("+");

        }
 n.e2.accept(this);

    }
 }

                                                              void visit(IntExp n) {

                                                                  System.out.print(n.value);

                                                              }

Tricky question: The accept methods all                   }

look the same! Why can't we define just
one accept method in the superclass, and                Answer: Because the calls go to different visit
                                                        methods: "this" has different types for the different
let all classes inherit it???                        calls. The visit methods are overloaded (same name
                                                        but different argument types).                  12  

L06B.pdf:                            Typical  Visitor  interface  
                        has  return  value  and  data  parameter  
 The Visitor interface  
 interface Visitor {

     Object visit(Add node, Object data);

     Object visit(IntExp node, Object data);

 }

The AST classes  
class Add extends Exp {

    ...

    Object accept(Visitor v, Object data) {

        return v.visit(this, data);

    }

}

class IntExp extends Exp {

    ...

    Object accept(Visitor v, Object data) {

        return v.visit(this, data);

    }

}

                                                                               13  

L06B.pdf:              Example  visitor:  expression  evaluaLon  
Tangled crosscutting code  
class Expr{
 class Add{
 class Sub{

    abstract int value();
 int value() {
 int value() { ... }

}
 return getLeft().value() +
 }

                                      getRight().value(); }

                              }
 class IntExpr{

                                                                        int value() { ... }

                                                                    }

Corresponding Visitor  
class Evaluator implements Visitor {

    Object visit(Add node, Object data) {

        return

                                                                  quite a lot of boilerplate  
          (Integer) node.getLeft().accept(this, data) +

          (Integer) node.getRight().accept(this, data);
 extra type casts  
    }

    Object visit(Sub node, Object data) { ... }

    Object visit(IntExpr node, Object data { ...}

}

Casts needed to access return and data values.  
(Could be solved by type parameters on the visitor interface.)
 14  

L06B.pdf:                   Making  the  client  code  simple  
               add  a  staLc  convenience  method  to  the  Visitor  
The client code we want to write:  
Expr e = ...;

int result = Evaluator.result(e);

Visitor  
class Evaluator implements Visitor {

    static int result(Expr node) {

        return (Integer) node.accept(new Evaluator(), null);

    }

    Object visit(Add node, Object data) {

        int n1 = (Integer) node.getLeft().accept(this, data);

        int n2 = (Integer) node.getRight().accept(this, data);

        return new Integer(n1+n2);

    }

    Object visit(Sub node, Object data) { ... }

    Object visit(IntExpr node, Object data { ...}

}

                                                                                      15  

L06B.pdf:                             Example:  unparser  
Tangled crosscutting code  
                                               class Add{
 class Sub{

class Expr{
 void unparse(Stream s) {
 ...

    abstract void unparse(Stream s);
 getLeft().unparse(s);
 }

}
 s.print("+");

Pass the stream as a parameter                       getRight().unparse(s);
 class IntExpr{

                                                   }
 ...

                                               }
 }

  Corresponding Visitor  
  class Unparser implements Visitor {

      Unparser(Stream s) { this.s = s; }

                                                             No need for stream parameter.

      Stream s;

                                                             Keep it in the visitor.

      Object visit(Add node, Object data) {

                                                             Nice!

          node.getLeft().accept(this, data);

          s.print("+");

          node.getRight().accept(this, data);

          return null;

      }

      ...

  }
 16  

L06B.pdf:            Adding  a  convenience  method  for  clients  
Client code  
Expr e = ...;

Stream s = ...;

Unparser.doit(e, s);

Visitor  
class Unparser implements Visitor {

    static void doit(Expr e, Stream s) {

        e.accept(new Unparser(s), null);

    }

    Unparser(Stream s) { this.s = s; }

    Stream s;

    Object visit(Add node, Object data) {

        node.getLeft().accept(this, data);

        s.print("+");

        node.getRight().accept(this, data);

        return null;

    }

    ...

}

                                                                       17  

L06B.pdf:                         One  more  example  
            Count  the  number  of  idenLﬁers  in  a  program  
Abstract grammar  
abstract Stmt;

IfStmt : Stmt ::= Cond:Exp Then:Stmt [Else:Stmt]

...

abstract Expr;

BinExpr : Expr ::= Left:Expr Right:Expr;

Add : BinExpr;

Sub : BinExpr;

IntExpr : Expr ::= <INT:String>;

IdExpr : Expr ::= <ID:String>

...

How can we implement the visitor?  
Problem: We need to write lots of boring traversal code...  
                                                                                18  

L06B.pdf:                                      SoluLon:  
                   Introduce  a  general  traversing  Visitor  
                             Visitor
 Interface, as before  
                        TraversingVisitor
 Default implementations that just
                                                 traverse the AST.

                                                 Could be generated from the grammar.

                                                  Override default traversal
                         CountIdentifiers

                                                  when needed.  
Some parser generators generate several different kinds of
visitors, for different kinds of traversals.  
                                                                                   19  

L06B.pdf:             ImplementaLon  of  TraversingVisitor  
class TraversingVisitor implements Visitor {



  private Object visitChildren(ASTNode node, Object data) {

        for (int i = 0; i < node.getNumChild(); ++i) {

            node.getChild(i).accept(this, data);

        }

        return data;

    }



    Object visit(IfStmt node, Object data) {

        return visitChildren(node, data);

    }

    Object visit(Add node, Object data) {

        return visitChildren(node, data);

    }

    Object visit(Sub node, Object data) {

        return visitChildren(node, data);

    }

    ...

}

                                                              20  

L06B.pdf:          CountIdenLﬁers  as  a  traversing  visitor  
Example use:  
Program p = ...

System.out.print("The number of identifiers is: ");

System.out.println(CountIdentifiers.result(p));

Visitor  
class CountIdentifiers extends TraversingVisitor {
 Only one visit
    int count = 0;
 method needed.

    static int result(Program root) {


        root.accept(new CountIdentifiers());
 Nice!

        return count;

    }

    Object visit(IdExpr node, Object data) {

        count++;

        return null;

    }

}

                                                                       21  

L06B.pdf:     RepresenLng  name  bindings  in  an  AST  
     {                                                                  Block  
    int  a;  
    a  =  3;  
     }                                                 VarDecl                            Assign  
                                                 IntType    IdDecl              IdUse         IntExp  
                                                               ID="a"             ID="a"        INT="3"  
                                                                                     decl  
Diﬀer  between  declaraLons  and  uses!  
  
IdDecl  for  declared  names  
IdUse  for  used  names  
  
An  aTribute  decl  represents  the  name  binding.  
                                                                                                                22  

L06B.pdf: CompuLng  name  bindings  imperaLvely  
                                                                          Block  
 {  
    int  a  =  3;  
    int  b  =  4;  
                                                                                                               Block  
    {                                  IdDecl        IdDecl  
        int  a;                   ID="a"        ID="b"  
        a  =  b;                                                         IdDecl  
    }                                                                             ID="a"  
 }  
                                                                                                    IdUse        IdUse  
Use  a  symbol  table  data  structure:                                                 ID="a"       ID="b"  
For  each  block,  a  map  from  visible  names  to  declaraLons.                decl          decl  
Use  a  stack  of  maps  to  handle  nested  blocks.  
Algorithm:  
Traverse  the  AST  
push/pop  symbol  table  when  entering/leaving  a  block  
add/lookup  idenLﬁers  when  encountering  IdDecls/IdUses  
                                                                                                                              23  

L06B.pdf:            Example  API  for  block  structured  symbol  table  
class  SymbolTable<M>  {  
               void  add(String  symbol,  M  meaning);  //  add  to  top  table  
  void  enterBlock();  //  push  new  table  
  void  exitBlock();    //  pops  top  table  
  M  lookup(String  symbol);  //  returns  the  meaning  of  the  symbol  
}  
Could  be  used,  for  example,  in  a  visitor:  
class  NameAnalysis  extends  TraversingVisitor  {  
    SymbolTable<IdDecl>  st  =  new  SymbolTable<IdDecl>();  
    void  visit(Block  node)  {  
        st.enterBlock();  
        visitChildren(node);  
        st.exitBlock();  
    }  
    void  visit(IdDecl  node)  {  
        st.add(node.getID(),  node);  
    }  
    void  visit(IdUse  node)  {  
        node.decl  =  st.lookup(node.getID());  
    }  
}                                                                                                       24  

L06B.pdf:                                             Summary  quesLons  
•  What  is  the  Expression  Problem?  
•  Why  is  solving  the  Expression  Problem  desirable  for  implemenLng  compilers?  
•  Why  is  it  a  bad  idea  to  edit  generated  code?  
•  Explain  how  the  Visitor  paTern  can  be  implemented.  
•  Implement  a  computaLon  over  the  AST  using  visitors.  
•  Add  a  convenience  method  to  the  visitor  to  make  it  easier  to  call  from  client  
     code.  
•  Why  can  traversing  visitors  be  useful?  
•  What  is  a  symbol  table?  
•  Why  use  both  IdDecl  and  IdUse  instead  of  just  one  AST  type?  
  
                                                                                                                               25  

L07A.pdf:          EDAN65:  Compilers,  Lecture  07  A  
Sta;c  Aspect-­‐Oriented  Programming  
                     Görel  Hedin  
                    Revised:  2015-­‐09-­‐21  

L07A.pdf:     This  lecture  
                                                                                runtime system  
                                              source  code  (text)  
  Regular         Lexical  analyzer                                             activation
                                                                                                      stack  
expressions
 (scanner)                                                      records  
                                              tokens  
Context-­‐free   Syntac;c  analyzer  
                                                                                                     garbage
 grammar
 (parser)  
                                                                                                     collection  
                                              AST  (Abstract  syntax  tree)  
                                            Visitors                                                heap  
 ASribute                                 Sta&c  aspects  
                   Seman&c  analyzer  
 grammar
 ASribute  grammars                      objects  
                                              ASributed  AST  
                     Intermediate  
                                                                                      Interpreter

                    code  generator  
                                              intermediate  code                                   code
                                                                                         Virtual      and
                       Op;mizer                                                       machine
 data  
                                              intermediate  code  
                      Target  code  
                                                                                       machine
                       generator  
                                                 target  code  
                                                                                                                2  

L07A.pdf:                                           Recall  
                                     Seman&c  analysis  
computa;ons  on  the  AST:  name  analysis,  type  analysis,  error  checking,  ...  
  
  
  
                                    Expression  problem  
How  can  we  add  both  computa;ons  and  language  constructs  modularly?  
  
  
  
                Solu&ons  to  the  expression  problem  
                       •  Solu;on  1:  Visitors  (previous  lecture)  
                           •  Solu;on  2:  Sta;c  AOP  (this  lecture)  
                                                                                                            3  

L07A.pdf:                 Example:  Prin;ng  an  AST  
                                  Ordinary  programming  
class Exp {

    abstract void print();
 Pros: Straightforward code

}


class Add extends Exp {
 Cons:

    Exp e1, e2;
 If we add a new operation, like computing
    void print() {
 the value, all classes need to be modified.
        e1.print();
 We get tangled code – many different
        System.out.print("+");
 concerns in the same class.

        e2.print();

    }

}

class IntExp extends Exp {

    int value;

    void print() {

        System.out.print(value);

    }

}

...

                                                                                     4  

L07A.pdf:                   Example:  Prin;ng  an  AST  
                               Visitor  solu;on  
class Exp {
 class Evaluator implements Visitor {

}
 void visit(Add node) {

class Add extends Exp {
 node.e1.accept(this);

    Exp e1, e2;
 System.out.print("+");

    void accept(Visitor v) {
 node.e2.accept(this);

        v.visit(this);
 }

    }
 void visit(IntExpr node) {

}
 System.out.print(node.value);

class IntExp extends Exp {
 }

    int value;
 }

    void accept(Visitor v) {

        v.visit(this);

    }
 Pros: Modular addition of new operation

}


...
 Cons: Clumsy code with lots of boilerplate
                                    (accept and visit methods). Cannot extend
                                    visitors easily if the language is extended.  
                                                                                     5  

L07A.pdf:                Example:  Prin;ng  an  AST  
                   Sta;c  Aspect-­‐Oriented  Programming  
class Exp {
 aspect Evaluator {

}
 abstract void Exp.print();

class Add extends Exp {
 void Add.print() {

    Exp e1, e2;
 e1.print();

}
 System.out.print("+");

class IntExp extends Exp {
 e2.print();

    int value;
 }

}
 void IntExp.print() {

...
 System.out.print(value);

                                             }

                                         }

Pros: Straightforward code. Modular addition of new operation. No problem to
extend the language – additional methods can be added in other aspect.



Cons: Cannot use Java. Need more advanced language like AspectJ or JastAdd.  
                                                                                6  

L07A.pdf:                   Inter-­‐type  declara;ons  
                            The  key  construct  in  sta;c  AOP  
class C {
 aspect A {

}
 T C.m() {
 inter-­‐type  declared  method  
                                   ...

class D {
 }

}
 int D.f = 3;
 inter-­‐type  declared  ﬁeld  
                           }

             is  equivalent  to:  
class C {

 T m() {

        ...

    }

}

class D {

 int f = 3;

}

                                                                                                             7  

L07A.pdf:Recall:  Dealing  with  the  expression  problem  
•  Edit the AST classes (i.e., actually not solving the problem)

     •  Non-modular, non-compositional.

     •  It is always a VERY BAD IDEA to edit generated code!

     •  Sometimes used anyway in industry.

•  Visitors: an OO design pattern.

     •  Modularize through clever indirect calls.

     •  Not full modularization, not composition.

     •  Supported by many parser generators.

     •  Reasonably useful, commonly used in industry.

•  Static Aspect-Oriented Programming (AOP)

     •  Also known as inter-type declarations (ITDs) or introduction

     •  Use new language constructs (aspects) to factor out code.

     •  Solves the expression problem in a nice simple way.

     •  The drawback: you need a new language: AspectJ, JastAdd, ...

•  Advanced language constructs

     •  Use more advanced language constructs: virtual classes in gbeta,
        traits in Scala, typeclasses in Haskell, ...

     •  Drawbacks: More complex than static AOP. You need an advanced
        language. Not much practical experience (so far).

                This lecture: Static AOP  
                                                                         8  

L07A.pdf:                          Sta;c  AOP  in  JastAdd  
     Abstract grammar  
           *.ast

             *.ast

                                       JastAdd
 *.ast

                                                               *.java

           *.ast
 Generated
            *.jrag
 Generates AST             tangled

Computation aspects
 classes and weaves
                                                            AST classes  
                                  in aspect code

  
                                                                            9  

L07A.pdf:           Example  aspect:  expression  evalua;on  
Abstract grammar  
abstract Expr;

BinExpr : Expr ::= Left:Expr Right:Expr;

Add : BinExpr;

Sub : BinExpr;

IntExpr : Expr ::= <INT:String>;

Aspect  
aspect Evaluator {

    abstract int Expr.value();

    int Add.value() { return getLeft().value() + getRight().value(); }

    int Sub.value() { return getLeft().value() – getRight().value(); }

    int IntExpr.value() { return String.parseInt(getINT()); }

}

Inter-type declarations: The value methods will be woven
into the classes (Expr, Add, Sub, IntExpr).

Also known as introduction.  
                                                                         10  

L07A.pdf:                      Another  example:  unparsing  
Abstract grammar  
abstract Expr;

BinExpr : Expr ::= Left:Expr Right:Expr;

Add : BinExpr;

Sub : BinExpr;

IntExpr : Expr ::= <INT:String>;

Aspect  
aspect Unparser {

    abstract void Expr.unparse(Stream s, String indent);

    void BinExp.unparse(Stream s, String indent) {

        getLeft().unparse(s,indent);

        s.print(operatorString());

        getRight().unparse(s,indent);

    }

    abstract String BinExp.operatorString();

    String Add.operatorString() { return "+"; }

    String Sub.operatorString() { return "-"; }

    void IntExpr.unparse(Stream s, String indent) { s.print(getINT()); }

}

                                                                           11  

L07A.pdf:                                      Weaving  the  classes  in  JastAdd  
toy.ast  
 abstract Expr;

 BinExpr : Expr ::= Left:Expr Right:Expr;

 Add : BinExpr;

 Sub : BinExpr;

 IntExpr : Expr ::= <INT:String>;

 Evaluator.jrag                                                                     class Expr extends
                                                                                         class BinExpr
                                                                                      ASTNode        {
 extends
 aspect Evaluator {

 Exprclass
                                                                                                 {
 Add extends
     abstract int Expr.value();

 void
                                                                                             BinExpr
                                                                                                 classunparse(...)
                                                                                                         Sub
                                                                                                          {
 extends
                                                                                                                    {

     int Add.value() { return getLeft().value() + getRight().value(); }

     int Sub.value() { return getLeft().value() – getRight().value(); }

                                                                            JastAdd


 int
                                                                                                 BinExpr
                                                                                                      value(){
 { return


 getLeft().value()
                                                                                                     int value() { +return
     int IntExpr.value() { return String.parseInt(getINT()); }


 getRight().value();
                                                                                                 getLeft().value()}
 -
 }
 }
 }
 String
                                                                                                 getRight().value(); }



 operatorString()
                                                                                                     String
                                                                                         }
 { return
                                                                                                 operatorString()
                                                                                                           "+"; }

                                                                                             }
 { return "-"; }

 Unparser.jrag                                                                                 }

 aspect Unparser {

     abstract void Expr.unparse(Stream s, String indent);

     void BinExp.unparse(Stream s, String indent) {
 Tangled
         getLeft().unparse(s,ind);

         s.print(operatorString());

                                                                                         generated code  
         getRight().unparse(s,ind);

     }

     abstract BinExp.operatorString();

     String Add.operatorString() { return "+"; }

     String Sub.operatorString() { return "-"}

     void IntExpr.unparse(Stream s, String indent) { s.print(getINT()); }

 }

           Untangled source code                                                                                       12  

L07A.pdf: Features  that  can  be  inter-­‐type  declared  or  
            factored  out  to  JastAdd  aspects  
•  Methods

•  Instance variables

•  "implements" clauses

•  "import" clauses

•  attribute grammars (see later lecture)

                                                                     13  

L07A.pdf:           Full  Aspect-­‐Oriented  Programming  
•  JastAdd supports only a small part of AOP, namely static AOP
   with inter-type declarations.

•  Asepct-oriented programming is a wider concept that usually
   focuses on dynamic behavior:

      •  A joinpoint is a point during execution where advice code can
         be added.

      •  A pointcut is a set of joinpoints that can be described in a
         simple way, e.g.,

            •  all calls to a method m()

            •  all accesses of a variable v

      •  Advice is code you can specify in an aspect and that can be
         added at joinpoints, either after, before, or around the
         joinpoint.

      •  Example applications:

            •  Add logging of method calls in an aspect (instead of
               adding print statements all over your code)

            •  Add synchronization code to basic code that is
               unsynchronized

                                                                       14  

L07A.pdf:                       Sta;c  aspects  vs  Visitors  
                          Static aspects            Visitors  
What can be               instance variables
 only methods

factored out from         methods

AST classes?            implements clauses

Type  safety?         full type precision
 Casts may be
                                                      needed, depending on
                                                      framework

Method  parameters    any number
 only one

Ease  of  use?      Very simple
 Clumsy, boilerplate
                                                      code needed.

Arbitrary               Yes
 No – you can extend
composi&on  of                                    a visitor, but not
modules?                                            combine two.

Separate                  Not for JastAdd. But        Yes

compilation?            could be implemented.

Mainstream OO             No – you need JastAdd,      Yes, use Java or any
language?               AspectJ, or similar
 other OO language.

                                                                           15  

L07A.pdf:                           Recall:  The  expression  problem  
         How  add  both  classes  and  computa;ons  in  a  modular  way?  
                                       Aspects with

    Ordinary OO              inter-type declarations
 The Visitor design pattern

             A
 A
 A.comp1
 A
 Visitor

                                                  B.comp1

           comp1
 C.comp1
 accept
 visit(A)

           comp2
 visit(B)

                                                                                          visit(C)

                                                  A.comp2

                                                  B.comp2

                                                  C.comp2

     B
 C
 B
 C
 B
 C
 Comp1
 Comp2

   comp1
 comp1
 accept
 accept
 visit(A)
 visit(A)

   comp2
 comp2
 visit(B)
 visit(B)

                                                                                  visit(C)
 visit(C)

Classes can be added                   Fully modular.
 Computations can be added, but
  modularly, but not                                           non-modular changes needed if
     computations.                                         classes are added. Complex code.  
                                                                                                              16  

L07A.pdf:                     The  interpreter  design  paSern  
                     Commonly  used  for  many  computa;ons  in  a  compiler.  
           Here  explained  using  Ordinary  OO.  Modularize  using  AOP  or  Visitors.  
Intent: Given a language, define a representation for its grammar along with an
interpreter that uses the representation to interpret sentences in the language.

                          [Gamma, Helm, Johnson, Vlissides, 1994]

                                                                          *  
                                        AbstractExpression

                                    interpret(Context)

          TerminalExpression
 NonterminalExpression

        interpret(Context)
 interpret(Context)

          AbstractExpression, TerminalExpression, NonterminalExpression,
              interpret, and Context are just ROLES in the pattern.

                      In our programs, we will use our own names.  
                                                                                                              17  

L07A.pdf: abstract Stmt;

                                             Example  use  of  Interpreter  
 Block : Stmt ::= Stmt*;
 Pattern roles:

 Assign : Stmt ::= <ID> Expr;


 abstract Expr;
 context: vars

 Add : Expr ::= Left:Expr Right:Expr;


 IdExpr : Expr ::= <ID>;
 interpret: execute for statements,
 IntExpr : Expr ::= <INT>;
 value for expressions

                Stmt
 Expr

        execute(vars)
 value(vars)

    Block
 Assign
 Add
 IdExpr
 IntExpr

execute(vars)
 execute(vars)
 value(vars)
 value(vars)
 value(vars)

      vars
 a map keeping track of the current values of variables

      execute
 executes a Stmt, changing and using the vars map

      value
 returns the value of an Expr, using the vars map

                                                                                      18  

L07A.pdf:       Example  implementa;on  using  JastAdd  aspects  
abstract Stmt;
 aspect Interpreter {

                                           abstract void Stmt.execute(Map<String, int> vars);

Block : Stmt ::= Stmt*;


Assign : Stmt ::= <ID> Expr;
 void Block.execute(Map<String, int> vars) {

abstract Expr;
 for (Stmt s : getStmts()) { s.execute(vars); }

Add : Expr ::= Left:Expr Right:Expr;
 }

                                           void Assign.execute(Map<String, int> vars) {

IdExpr : Expr ::= <ID>;
 int value = getExpr().value(vars);

IntExpr : Expr ::= <INT>;
 vars.put(getID(), value);

                                           }



                                           abstract int Expr.value(Map<String, int> vars);



                                           int Add.value(Map<String, int> vars) {

                                               return getLeft().value(vars) + getRight().value(vars);

                                           }

                                           int IdExpr.value(Map<String, int> vars) {

                                               return vars.get(getID());

                                           }

                                           int IntExpr.value(Map<String, int> vars) {

                                               return String.parseInt(getINT());

                                           }

                                       }

                                                                                                    19  

L07A.pdf:                                     Summary  ques;ons  
•  What  are  diﬀerent  ways  of  solving  the  Expression  Problem?  
•  What  is  an  intertype  declara;on?  
•  What  is  aspect-­‐oriented  programming?  
•  How  does  sta;c  AOP  diﬀer  from  dynamic  AOP?  
•  Implement  a  computa;on  over  the  AST  using  sta;c  aspects.  
•  What  are  advantages  and  disadvantages  of  sta;c  AOP  as  compared  to  Visitors?  
                                                                                                                    20  

L07B.pdf:       EDAN65:  Compilers,  Lecture  07  B  
Introduc=on  to  A>ribute  Grammars  
           synthesized,  inherited,  broadcas=ng  
                  Görel  Hedin  
                 Revised:  2015-­‐09-­‐21  

L07B.pdf:     This  lecture  
                                                                                runtime system  
                                              source  code  (text)  
  Regular         Lexical  analyzer                                             activation
                                                                                                      stack  
expressions
 (scanner)                                                      records  
                                              tokens  
Context-­‐free   Syntac=c  analyzer  
                                                                                                     garbage
 grammar
 (parser)  
                                                                                                     collection  
                                              AST  (Abstract  syntax  tree)  
                                            Visitors                                                heap  
 A>ribute                                 Inter-­‐type  declared  methods  
                   Seman&c  analyzer  
 grammar
 A.ribute  grammars                      objects  
                                              A>ributed  AST  
                     Intermediate  
                                                                                      Interpreter

                    code  generator  
                                              intermediate  code                                   code
                                                                                         Virtual      and
                       Op=mizer                                                       machine
 data  
                                              intermediate  code  
                      Target  code  
                                                                                       machine
                       generator  
                                                 target  code  
                                                                                                                2  

L07B.pdf:               Computa=ons  on  the  AST  
IMPERATIVE  COMPUTATIONS                          DECLARATIVE  COMPUTATIONS  
•  Deﬁne  methods  that  "do"  something.   •  Deﬁne  proper=es  of  nodes  
•  Side-­‐eﬀects                                    •  No  side-­‐eﬀects  
     •  Modify  objects                           •  Useful  for  compu=ng  
     •  Output  to  ﬁles                             •  Name  bindings  
•  Useful  for                                         •  Types  of  expressions  
     •  Execu=on/Interpreta=on                           •  Error  informa=on  
     •  Unparsing                                   •  Technique  
     •  Prin=ng  error  messages                     •  A>ribute  grammars  
•  Technique  
     •  Inter-­‐type  declared  methods    
     •  Visitors  
  
                                                                                               3  

L07B.pdf:                               Example  proper=es  
                                 Does  this  method  have  any  compile-­‐=me  errors?  
     int  gcd2(int  a,  int  b)  {                             What  is  the  type  of  this  expression?  
    if  (b  ==  0)  {  
        return  a;  
    }    
    return  gcd2(b,  a  %  b);  
     }    
What  is  the  declara=on  of  this  b?  
                                           A.ribute  grammars:  
                                           Express  these  proper=es  as  a#ributes  of  AST  nodes.  
                                           Deﬁne  the  a>ributes  by  equa,ons.  
                                           The  equa=ons  can  be  solved  automa=cally.                                  4  

L07B.pdf:                                               Simple  example  
                                               a>ributes  and  equa=ons  
             AST  node                                        eq  z=b.x+1  
       z  
                                                                  eq  c.y=z+c.v  
  
                                                                                    b             c  
             a>ribute  
                        z  
                                                             eq  x=2        eq  v=5  
                                                                             x                           y  
            equa=on:  
                                                                                                           v  
     eq  a0  =  f(a1,  ...,  an)  
                                                                           What  is  the  value  of  y?  
                                                                     Solve  the  equa=on  system!  
deﬁned  a>ribute  
                                                                    (Easy!  Just  use  subs=tu=on.)  
                  func=on  of  other  a>ributes  
                                                                                                                               5  

L07B.pdf:                                             Simple  example  
                                 synthesized  and  inherited  a>ributes  
deﬁnes  a>ribute  in  the  node  –  the  a>ribute  is  synthesized  
                                                                             eq  z=b.x+1  
   syn  z  
                                                                             eq  c.y=z+c.v  
deﬁnes  a>ribute  in  the  child  –  the  a>ribute  is  inherited              b          c  
                                                                       eq  x=2         eq  v=5  
                                                                                      syn  x                 inh  y  
                                                                                                                 syn  v  
Donald  Knuth  introduced  a>ribute  grammars  in  1968.  
The  term  "inherited"  is  not  related  to  inheritance  in  object-­‐orienta=on.  
Both  terms  originated  during  the  1960s.  
                                                                                                                                            6  

L07B.pdf:                                          Simple  example  
               declaring  a>ributes  and  equa=ons  in  a  (JastAdd)  grammar  
Abstract  grammar:  
                                                                                eq  z=b.x+1  
                                                                                                      A   syn  z  
A  ::=  B  C;                                                           eq  c.y=z+c.v  
B;  
C;  
                                                                                           getB            getC  
A>ribute  grammar  module:  
 aspect  SomeAttributes  {  
    syn  int  A.z();  
    syn  int  B.x();  
    syn  int  C.v();                                            eq  x=2   B                        C   eq  v=5  
    inh  int  C.y();                                                          syn  x              inh  y  
    eq    A.z()  =  getB().x()+1;                                                                 syn  v  
    eq    A.getC().v()  =  z()  +  getC().v();  
    eq    B.x()  =  2;  
    eq    C.v()  =  5;           uses  inter-­‐type  declara=ons  for  a>ributes  and  equa=ons  
 }  
  Note!  The  grammar  is  declara=ve.  The  order  of  the  equa=ons  is  irrelevant.  
  JastAdd  solves  the  equa=on  system  automa=cally.  
                                                                                                                                        7  

L07B.pdf:                                      Some  shorthands  
These  rules:  
syn  int  A.z();  
eq    A.z()  =  getB().x()+1;  
are  equivalent  to:  
 syn  int  A.z()  =  getB().x()+1;  
 and  we  could  also  use  method  body  syntax:  
 syn  int  A.z()  {  
    return  getB().x()+1;  
 }  
                                                                    8  

L07B.pdf:                       Equa=ons  must  be  free  from  
                     (externally  visible)  side  eﬀects  
While  this  looks  like  a  method,  execu=ng  it  has  no  side-­‐eﬀects,  so  this  is  ﬁne.  
syn  int  A.z()  {  
    return  getB().x()+1;  
}  
It  is  also  ﬁne  to  have  assignments  to  local  
variables,  like  this.  The  eﬀect  of  changing  r  
is  not  visible  amer  execu=ng  the  method.  
syn  int  A.z()  {  
    int  r  =  0;  
    r  =  getB().x()+1;  
    return  r;  
}  
                                                                                                                                9  

L07B.pdf:                   Equa=ons  must  be  free  from  
                (externally  visible)  side  eﬀects  
What  is  wrong  with  this  a>ribute  grammar?  
syn  int  A.x()  =  Globals.variable;  
  
syn  int  B.y()  {  
    Globals.variable++;  
    return  3;  
}  
                                                                10  

L07B.pdf:                      Equa=ons  must  be  free  from  
                  (externally  visible)  side  eﬀects  
What  is  wrong  with  this  a>ribute  grammar?  
   syn  int  A.x()  =  Globals.variable;  
  
   syn  int  B.y()  {  
    Globals.variable++;  
    return  3;  
   }  
Equa=ons  are  not  allowed  to  change  other  than  
local  data.  If  they  do,  they  are  not  equa=ons.  
  
Warning!  JastAdd  cannot  discover  if  you  have  side-­‐
eﬀects  in  your  equa=ons!  If  your  deﬁni=ons  rely  on  
global  data  that  is  changed,  the  wrong  results  will  
be  computed.  
                                                                                11  

L07B.pdf:                     Well-­‐formed  a>ribute  grammar  
  
Abstract  grammar:  
                                                                    An  a>ribute  grammar  is  well-­‐formed,  if  
A  ::=  B  C;  
                                                                    there  is  exactly  one  deﬁning  equa=on  
B;  
C;                                                                for  each  a>ribute  in  any  AST.  
  
A>ribute  grammar  module:                                    JastAdd  checks  this  at  compile  =me.  
 aspect  SomeAttributes  {  
    syn  int  A.z();  
    syn  int  B.x();  
    syn  int  C.v();  
    inh  int  C.y();  
    eq    A.z()  =  getB().x()+1;  
    eq    A.getC().v()  =  z()  +  getC().v();  
    eq    B.x()  =  2;  
    eq    C.v()  =  5;  
 }  
                                                                                                                            12  

L07B.pdf:                      Well-­‐deﬁned  a>ribute  grammar  
  
 An  a>ribute  grammar  is  well-­‐deﬁned,  
 if  it  has  a  computable  unique  solu=on  for  any  AST.  
  
 An  ordinary  a>ribute  grammar  is  well-­‐deﬁned  
 if  it  is  well-­‐formed  and  non-­‐circular.  
Is  this  a>ribute  grammar  well-­‐deﬁned?  
 aspect  SomeAttributes  {  
    syn  int  A.c()  =  d();  
    syn  int  A.d()  =  c();  
 }  
                                            Circular  a>ribute  grammar.  Well-­‐formed,  but  not  well-­‐deﬁned.  
 JastAdd  checks  circularity  at  run=me.  
  
 It  is  possible  to  allow  circular  a>ributes,  but  they  will  then  
 have  to  be  explicitly  declared  as  circular.  See  later  lecture.                                       13  

L07B.pdf:                                 Abstract  grammar  
                               deﬁnes  the  structure  of  ASTs  
Abstract  grammar:                                            Example  AST  for  "a  +  b  +  c"  
abstract  Exp;                                       (an  instance  of  the  abstract  grammar)  
Add  :  Exp  ::=  Left:Exp  Right:Exp;  
IdUse  :  Exp  ::=  <ID>;                                                          Add  
                                                                               Left
 Right

Class  diagram:  
                      Exp
 Add                              IdUse  
                                                                                                                  ID="c"  
                                                                   Left
 Right

   Left

             Add
 IdUse
 IdUse             IdUse  
 Right

                                                                   ID="a"            ID="b"  
          Legend:  
            Superclass
 Parent  node            The  terminal  symbols  (like  ID)  are  
                                                                  intrinsic  a>ributes  –    constructed  
                                       Child  node            when  building  the  AST.  They  are  not  
             Subclass
 deﬁned  by  equa=ons.  
                                      A>ribute=value  
                                                                                                                             14  

L07B.pdf:                               A>ribute  grammars  
                   extends  abstract  grammars  with  a>ributes  
Abstract  grammar:                                        Example  AST  for  "a  +  b  +  c"  
abstract  Exp;                                   (an  instance  of  the  abstract  grammar)  
Add  :  Exp  ::=  Left:Exp  Right:Exp;  
IdUse  :  Exp  ::=  <ID>;                                                       Add        type=...  
A>ribute  grammar  modules:                       type=...         Add                             IdUse  
                                                                                                              ID="c"  
 syn  IdDecl  IdUse.decl();  
                                                                                                              decl=...  
 eq  IdUse.decl()  =  ...;  
                                                                                                             type=...  
 syn  Type  Exp.type();                                 IdUse              IdUse  
 eq  Add.type()  =  ...;                               ID="a"             ID="b"  
 eq  IdUse.type()  =  ...;  
                                                              decl=...           decl=...  
                                                              type=...           type=...  
 Each  declared  a>ribute  ...                         ...  will  have  instances  in  the  AST  
                                                                                                                           15  

L07B.pdf:                         A>ributes  and  equa=ons  
Abstract  grammar:                                                            Example  AST  for  "a  +  b  +  c"  
abstract  Exp;                                                       (an  instance  of  the  abstract  grammar)  
Add  :  Exp  ::=  Left:Exp  Right:Exp;  
IdUse  :  Exp  ::=  <ID>;                                                                         Add  
                                                                                             Add                               IdUse  
                                                                                                                                  ID="c"  
 Think  of  a>ributes  as  "ﬁelds"  in  the  tree  nodes.  
  syn  Type  ASTClass.attribute();  
                                                                                  IdUse            IdUse  
                                                                                  ID="a"            ID="b"  
 Each  equa=on  deﬁnes  an  a>ribute  in  terms  of  
 other  a>ributes  in  the  tree.  
  eq  definedAttribute  =  function  of  other  attributes;  
 An  evaluator  computes  the  values  of  the  a>ributes  (solves  the  equa=on  system).  
 Think  of  the  equa=ons  as  "methods"  called  by  the  evaluator.  
                                                                                                                                             16  

L07B.pdf:                                  A>ribute  mechanisms  
Synthesized*  –  the  equa=on  is  in  the  same  node  as  the  a>ribute  
  
Inherited*  –  the  equa=on  is  in  an  ancestor  
  
Broadcas&ng*  –  the  equa=on  holds  for  a  complete  subtree  
  
Reference  –  the  a>ribute  can  be  a  reference  to  an  AST  node.  
  
Parameterized  –  the  a>ribute  can  have  parameters  
  
NTA  –  the  a>ribute  is  a  "nonterminal"  (a  fresh  node  or  subtree)  
  
Collec&on  –  the  a>ribute  is  deﬁned  by  a  set  of  contribu=ons,  instead  of  by  an  equa=on.  
  
Circular  –  the  a>ribute  may  depend  on  itself  (solved  using  ﬁxed-­‐point  itera=on)  
  
*  Treated  in  this  lecture  
                                                                                                                                        17  

L07B.pdf:                                     Synthesized  a>ributes  
Synthesized  a>ribute:                                                                                        A  
The  equa=on  is  in  the  same  node  as  the  a>ribute.  
                                                                                eq  s()  =  f(...);       B  
                                                                                                            s  =  ...  
For  compu=ng  proper=es  that  depend  on  informa=on  in  the  node  
or  its  children.  
  
Typically  used  for  propaga=ng  informa=on  upwards  in  the  tree.  
                                                                                                                              18  

L07B.pdf:                     Synthesized  a>ributes,  example  1  
A  ::=  B;                             Draw  the  a#ribute  and  its  value!  
B;  
syn  int  B.s();                                                  A  
eq  B.s()  =  3;  
                                                                        B  
                                                                                                 19  

L07B.pdf:                          Synthesized  a>ributes,  example  1  
 A  ::=  B;  
 B;  
 syn  int  B.s();                                                                                   A  
 eq  B.s()  =  3;  
Or  equivalently,  write  the  equa=on  directly  in  the  declara=on:                  B  
 syn  int  B.s()  =  3;                                                                        s  =  3  
Or  equivalently,  write  the  equa=on  as  a  method  body:  
 syn  int  B.s()  {                                      Nota  bene!  
    return  3;                                          The  method  body  must  be  free  of  
 }                                                             externally  visible  side-­‐eﬀects.  
 Don't  do  this!  
int  B.counter  =  0;  //  Ordinary  field   Warning!  
syn  int  B.s()  {                                       Side-­‐eﬀects  are  not  checked  by  JastAdd.  
    counter++;  //  Visible  side-­‐effect   The  a>ributes  will  get  inconsistent  values.  
    return  counter;  
}                                                                                                                           20  

L07B.pdf:                     Synthesized  a>ributes,  example  2  
A  ::=  B;                                                             Three  diﬀerent  ASTs.  
abstract  B;                                                   Draw  the  a#ributes  and  their  values!  
C  :  B;  
D  :  B;  
E  :  D;                                                               A                A                 A  
Diﬀerent  subclasses  can  have  diﬀerent  equa=ons.  
                                                                             C                D                 E  
syn  int  B.s();  
eq  C.s()  =  4;  
eq  D.s()  =  5;  
eq  E.s()  =  6;  
                                                                                                                           21  

L07B.pdf:                          Synthesized  a>ributes,  example  2  
A  ::=  B;  
abstract  B;  
C  :  B;  
D  :  B;  
E  :  D;                                                                            A               A             A  
Diﬀerent  subclasses  can  have  diﬀerent  equa=ons.  
                                                                                          C               D             E  
syn  int  B.s();                                                                   s  =  4     s  =  5   s  =  6  
eq  C.s()  =  4;  
eq  D.s()  =  5;  
eq  E.s()  =  6;  
Note  that  equa=ons  can  override  equa=ons  in  superclasses,  
in  analogy  to  how  methods  can  override  methods  in  OO  languages.  
  
JastAdd  checks  that  each  concrete  class  has  equa=ons  for  all  its  synthesized  a>ributes.  
  
A  synthesized  a>ribute  is  similar  to  a  side-­‐eﬀect  free  method,  but:  
•  its  value  is  cached  (memoized)  
•  circularity  is  checked  at  run=me  (results  in  excep=on)                                                           22  

L07B.pdf:                                       Inherited  a>ributes  
Inherited  a>ribute:                                        eq  getB().s()  =  f(...);          A  
The  equa=on  is  in  an  ancestor  
                                                                                                            B  
                                                                                                            C  
                                                                                                      s  =  ...  
For  compu=ng  a  property  that  depends  on  the  context  of  the  node.  
  
Typically  used  for  propaga=ng  informa=on  downwards  in  the  tree.  
                                                                                                                        23  

L07B.pdf:                        Inherited  a>ributes,  example  1  
A  ::=  B  C;                          Draw  the  a#ribute  and  its  value!  
B;  
C;  
                                                                     A  
inh  int  B.i();  
eq  A.getB().i()  =  2;  
                                                               B         C  
                                                                                                   24  

L07B.pdf:                        Inherited  a>ributes,  example  1  
A  ::=  B  C;  
B;  
C;  
                                                                       A  
inh  int  B.i();  
eq  A.getB().i()  =  2;  
                                                            B              C  
                                                       i  =  2  
                                                                                   25  

L07B.pdf:                     Inherited  a>ributes,  example  2  
A  ::=  Left:B  Right:B;                            Draw  the  a#ributes  and  their  values!  
B;  
                                                                                        A  
The  parent  can  specify  diﬀerent  equa=ons  
for  its  diﬀerent  children.  
inh  int  B.i();  
eq  A.getLeft().i()  =  2;                                               B           B  
eq  A.getRight().i()  =  3;  
                                                                                                                    26  

L07B.pdf:                          Inherited  a>ributes,  example  2  
 A  ::=  Left:B  Right:B;  
 B;  
                                                                                                                 A  
 The  parent  can  specify  diﬀerent  equa=ons  
 for  its  diﬀerent  children.  
 inh  int  B.i();  
 eq  A.getLeft().i()  =  2;                                                                   B                 B  
 eq  A.getRight().i()  =  3;                                                             i  =  2           i  =  3  
                                                                                                            Dot  
This  is  useful,  for  example,  when  deﬁning  scope  rules  
for  qualiﬁed  access.  The  lookup  a>ributes  should  have  
diﬀerent  values  for  the  diﬀerent  IdUses.                               IdUse                         IdUse  
                                                                                        ID="a"                         ID="a"  
                                                                                  lookup("a")  =  ...            lookup("a")  =  ...  
                                                                                                                                                   27  

L07B.pdf:                         Inherited  a>ributes,  example  3  
 A  ::=  Left:B  Right:B;                                    Draw  the  a#ributes  and  their  values!  
 B  ::=  C  D;  
 C;  
 D  ::=  E;  
 E;                                                                                                   A  
The  equa=ons  hold  for  the  complete  children  subtrees.  
                                                                                            B                     B  
 eq  A.getLeft().i()  =  2;  
 eq  A.getRight().i()  =  3;  
 inh  int  C.i();                                                               C         D         C         D  
 inh  int  E.i();  
                                                                                                  E                      E  
                                                                                                                                 28  

L07B.pdf:                         Inherited  a>ributes,  example  3  
 A  ::=  Left:B  Right:B;  
 B  ::=  C  D;  
 C;  
 D  ::=  E;  
 E;                                                                                                                A  
The  equa=ons  hold  for  the  complete  children  subtrees.  
                                                                                               B                                         B  
 eq  A.getLeft().i()  =  2;  
 eq  A.getRight().i()  =  3;  
 inh  int  C.i();                                                             C                   D                  C                  D  
 inh  int  E.i();                                                        i  =  2                               i  =  3  
                                                                                                          E                                         E  
                                                                                                     i  =  2                               i  =  3  
                                                                                                                                                                 29  

L07B.pdf:                         Inherited  a>ributes,  example  4  
 A  ::=  Left:B  Right:B;                                  Draw  the  a#ributes  and  their  values!  
 B  ::=  C  D;  
 C;  
 D  ::=  E;  
 E;                                                                                                 A  
An  equa=on  can  be  overruled  in  a  subtree.  
The  nearest  equa=on  holds.                                                     B                     B  
 eq  A.getLeft().i()  =  2;  
 eq  A.getRight().i()  =  3;                                                C         D         C         D  
 eq  B.getD().i()  =  i()  +  5;  
 inh  int  B.i();  
 inh  int  C.i();                                                                         E                      E  
 inh  int  E.i();  
                                                                                                                               30  

L07B.pdf:                         Inherited  a>ributes,  example  4  
 A  ::=  Left:B  Right:B;  
 B  ::=  C  D;  
 C;  
 D  ::=  E;  
 E;                                                                                                         A  
An  equa=on  can  be  overruled  in  a  subtree.  
                                                                   i  =  2        B                                         B        i  =  3  
The  nearest  equa=on  holds.  
 eq  A.getLeft().i()  =  2;  
 eq  A.getRight().i()  =  3;                                         C                   D                   C                 D  
 eq  B.getD().i()  =  i()  +  5;                            i  =  2                               i  =  3  
 inh  int  B.i();  
 inh  int  C.i();                                                                            E                                         E  
 inh  int  E.i();  
                                                                                              i  =  7                               i  =  8  
                                                                                                                                                           31  

L07B.pdf:                             Inherited  a>ributes,  example  5  
     A  ::=  B  C;  
     B  ::=  D;  
     C  ::=  D;  
                                                                          Draw  the  a#ributes  and  their  values!  
     D;  
                                                                                                       A  
There  must  be  an  equa=on  for  each  a>ribute  in  
any  possible  AST.  
  
What  is  the  problem  with  this  grammar?                                   B                      C  
     eq  B.getD().i()  =  6;  
     inh  int  D.i();                                                                  D                      D  
                                                                                                                                  32  

L07B.pdf:                                   Inherited  a>ributes,  example  5  
     A  ::=  B  C;  
     B  ::=  D;  
     C  ::=  D;  
     D;  
                                                                                                                A  
There  must  be  an  equa=on  for  each  a>ribute  in  
any  possible  AST.  
  
What  is  the  problem  with  this  grammar?                                         B                        C  
     eq  B.getD().i()  =  6;  
     inh  int  D.i();                                                                         D                       D  
                                                                                                i  =  6           i  =  ???  
Where  can  we  add  an  equa,on  to  solve  the  problem?  
  
In  C  or  A.  Or  in  their  superclass  ASTNode.  
                                                                                 This  a>ribute  has  no  equa=on!  
                                                                           JastAdd  will  ﬁnd  this  and  report  an  error.  
                                                                                                                                          33  

L07B.pdf:                           Broadcas=ng  of  inherited  a>ributes  
Tradi&onal  AG:                                                    JastAdd:  
Equa=on  for  inherited  a>ribute                              Equa=on  for  inherited  a>ribute  
must  be  in  the  immediate  parent.                      is  "broadcasted"  to  complete  subtree.  
Leads  to  "copy  rules".                                      No  "copy  rules"  are  needed.  
syn  b     A         eq  c.a=b                                           syn  b     A      eq  c.a=b  
         B               C           inh  a                                         B            C  
                                      eq  d.a=a  
                            D                                                                            D  
                                                      copy  rule  
                       inh  a                                                                        inh  a  
                                                                                                                             34  

L07B.pdf:                         Inherited  a>ributes,  example  6  
 A  ::=  B  C;  
 B  ::=  D;  
 C  ::=  D;  
                                                                                   Draw  the  a#ributes  and  their  values!  
 D;  
                                                                                                                A  
The  parent  can  write  an  equa=on  that  holds  for  all  children.  
 eq  A.getChild().i()  =  8;  
 inh  int  D.i();                                                                               B                      C  
                                                                                                      D                      D  
                                                                                                                                           35  

L07B.pdf:                         Inherited  a>ributes,  example  6  
 A  ::=  B  C;  
 B  ::=  D;  
 C  ::=  D;  
 D;  
                                                                                                               A  
The  parent  can  write  an  equa=on  that  holds  for  all  children.  
 eq  A.getChild().i()  =  8;  
 inh  int  D.i();                                                                           B                     C  
This  is  equivalent  to  wri=ng  an  equa=on  for  each  child:               D                   D  
 eq  A.getB().i()  =  8;                                                               i  =  8         i  =  8  
 eq  A.getC().i()  =  8;  
 inh  int  D.i();  
                                                                                                                                     36  

L07B.pdf:                       Inherited  a>ributes,  example  7  
 A  ::=  B*;                                                                  Draw  the  a#ributes  and  their  values!  
 B  ::=  C;  
 C;                                                                                                             A  
For  list  children,  an  index  can  be  used  in  the  equa=on                           List  
 eq  A.getB(int  index).i()  =  (index+1)  *  (index+1);  
 inh  int  C.i();  
                                                                                                       B         B           B  
                                                                                                       C         C           C  
                                                                                                                                            37  

L07B.pdf:                          Inherited  a>ributes,  example  7  
 A  ::=  B*;  
 B  ::=  C;  
 C;                                                                                                        A  
For  list  children,  an  index  can  be  used  in  the  equa=on                      List  
 eq  A.getB(int  index).i()  =  (index+1)  *  (index+1);  
 inh  int  C.i();  
                                                                                               B                B             B  
                                                                                                 C              C             C  
                                                                                            i  =  1    i  =  4   i  =  9  
This  is  useful,  for  example,  when  deﬁning  name  analysis  with  
declare-­‐before-­‐use  seman=cs.  
                                                                                                                                             38  

L07B.pdf:                                             Demand  evalua=on  
A>ributes  are  not  evaluated  un=l  demanded.                   Program  
Simple  recursive  caching  algorithm:  
If  not  cached  
    ﬁnd  the  equa=on                                                                localLookup("a")   3  
    compute  its  right-­‐hand  side                               Block         localLookup("b")   6  
    cache  the  value                                                                     lookup("b")         7  
ﬁ  
Return  the  cached  value  
                                                                     List                         List  
                                                            Decl                               Assign  
Example  program                               Type     IdDecl              IdUse                    IdUse  
demanding  a>ributes:                                      ID="a"             ID="a"                   ID="b"  
                                                                                     decl   1                   decl      4  
Program  p  =  ...  
Assign  a  =  p.getBlock().getStmt(0);                                    lookup("a")   2        lookup("b")            5  
System.out.println(a.getTo().decl());  
System.out.println(a.getFrom().decl());  
                                                                                                                                      39  

L07B.pdf:                                      Summary  ques=ons  
•  What  is  an  a>ribute  grammar?  
•  What  is  an  intrinsic  a>ribute?  
•  What  is  an  externally  visible  side-­‐eﬀect?  Why  are  they  not  allowed  in  the  
   equa=ons?  
•  What  is  a  synthesized  a>ribute?  
•  What  is  an  inherited  a>ribute?  
•  What  is  broadcas=ng?  
•  What  is  the  diﬀerence  between  a  declara=ve  and  an  impera=ve  speciﬁca=on?  
•  What  is  demand  evalua=on?  
•  Why  are  a>ributes  cached?  
You  can  now  do  Assignment  3.  
                                                                                                                       40  

L08.pdf:     EDAN65:  Compilers,  Lecture  08  
Reference  A<ribute  Grammars  
       AG  mechanisms,  SemanBc  analysis  
                 Görel  Hedin  
                Revised:  2015-­‐09-­‐22  

L08.pdf:     This  lecture  
                                                                                runtime system  
                                              source  code  (text)  
  Regular         Lexical  analyzer                                             activation
                                                                                                      stack  
expressions
 (scanner)                                                      records  
                                              tokens  
Context-­‐free   SyntacBc  analyzer  
                                                                                                     garbage
 grammar
 (parser)  
                                                                                                     collection  
                                              AST  (Abstract  syntax  tree)  
                                            Visitors                                                heap  
 A<ribute                                 StaBc  aspects  
                   Seman&c  analyzer  
 grammar
 A.ribute  grammars                      objects  
                                              A<ributed  AST  
                     Intermediate  
                                                                                      Interpreter

                    code  generator  
                                              intermediate  code                                   code
                                                                                         Virtual      and
                       OpBmizer                                                       machine
 data  
                                              intermediate  code  
                      Target  code  
                                                                                       machine
                       generator  
                                                 target  code  
                                                                                                                2  

L08.pdf:                                A<ribute  mechanisms  
Synthesized  –  the  equaBon  is  in  the  same  node  as  the  a<ribute  
  
Inherited  –  the  equaBon  is  in  an  ancestor  
  
Broadcas&ng  –  the  equaBon  holds  for  a  complete  subtree  
  
Reference  –  the  a<ribute  can  be  a  reference  to  an  AST  node.  
  
Parameterized  –  the  a<ribute  can  have  parameters  
  
NTA  –  the  a<ribute  is  a  "nonterminal"  (a  fresh  node  or  subtree)  
  
Collec&on  –  the  a<ribute  is  deﬁned  by  a  set  of  contribuBons,  instead  of  by  an  equaBon.  
  
Circular  –  the  a<ribute  may  depend  on  itself  (solved  using  ﬁxed-­‐point  iteraBon)  
  
                                                                                                                                        3  

L08.pdf:           Example  computaBons  on  an  AST  
     ...                                                                  Name  analysis:  ﬁnd  the  
                                                                         declaraBon  of  an  idenBﬁer  
                    Mul                                            Type  analysis:  compute  the  
                                                                          type  of  an  expression  
          Div             IdExpr                         Expression  evaluaBon:  compute  the  
                                                                value  of  a  constant  expression  
IdExpr          IdExpr  
                                             Code  generaBon:  compute  an  intermediate  
                                                 code  representaBon  of  the  program  
                              Unparsing:  compute  a  text  
                         representaBon  of  the  program  
                                                                                                                4  

L08.pdf:                                     SemanBc  analysis  
class  A  {                                 Name  analysis:  bind  each  use  of  
    int  f;                               an  idenBﬁer  to  its  declaraBon  
    int  m1(int  x)  {  
        return  x  *  f;          Type  analysis:  compute  the  type  
    }                                       of  each  expression  
}  
  
                                                  Error  checking:  ﬁnd  compile-­‐Bme  
class  B  extends  A  {  
                                                  errors  like  missing  declaraBons,  
    int  m2()  {  
                                                  wrong  type,  etc.  
        System.out.println(m1(3));  
    }    
}  
                                                                                                     5  

L08.pdf:Reference  and  parameterized  
         a<ributes  
  
       Name  analysis  
                                      6  

L08.pdf: Reference  a<ribute  grammars  (RAGs)  
Can  build  graphs  on  top  of  the  AST.  
       Trivial  example:  
                    A  
         B                      C  
        myC                    myB  
                           JastAdd  speciﬁcaBon:  
         A  ::=  B  C;                      aspect  Graph  {  
         B;      inh  C  B.myC();  
         C;      inh  B  C.myB();  
    eq    A.getB().myC()  =  getC();  
    eq    A.getC().myB()  =  getB();  
                                                    }  
                                                                                                         7  

L08.pdf:                            Parameterized  a<ributes  
 A  ::=  B*;                               Draw  some  isBefore  a-ributes  and  their  values!  
 B;  
                                                                                      A  
An  a<ribute  can  have  parameters.                                       List  
 inh  boolean  B.isBefore(int  i);  
 eq  A.getB(int  index).isBefore(int  i)  =  index  <  i;  
                                                                              B                         B  
                                                                                          B  
                                                                                                                 8  

L08.pdf:                            Parameterized  a<ributes  
 A  ::=  B*;  
 B;  
                                                                                                        A  
An  a<ribute  can  have  parameters.                                                         List  
 inh  boolean  B.isBefore(int  i);  
 eq  A.getB(int  index).isBefore(int  i)  =  index  <  i;  
                                                                                           B                                 B  
                                                                                                         B  
                                                                                             isBefore(0)  =  false  
                                                                                             isBefore(1)  =  false  
                                                                                              isBefore(2)  =  true  
                                                                                              isBefore(3)  =  true  
                                                                                                 isBefore(...)  =  ...  
There  is  one  a<ribute  instance  for  each  possible  parameter  combinaBon.  
PotenBally  inﬁnitely  many  a<ribute  instances.  
Only  the  accessed  ones  will  be  evaluated.  
                                                                                                                                     9  

L08.pdf:                                           Name  analysis  
                                                          Name  analysis:  bind  each  use  of  
                                                          an  idenBﬁer  to  its  declaraBon  
class  A  {  
    int  f;                                       Name  binding:  a  reference  from  
    int  m1(int  x)  {                        a  use  to  its  declaraBon  
        return  x  *  f;                  Scope  of  a  declara&on:  the  parts  
    }                                               of  the  program  where  it  is  visible.  
}  
                                                          Name  binding  rules:  also  known  as  
  
                                                          scope  rules  or  visibility  rules.  
class  B  extends  A  {  
    int  m2()  {                           Typically,  there  are  rules  for  
        System.out.println(m1(3));         •  blocks,  nesBng,  inheritance  
    }                                        •  name  collisions,  shadowing  
}                                                  •  declaraBon  order  
                                                        (insigniﬁcant  or  declare-­‐before-­‐use?)  
                                                     •  visibility  restricBons  (private,  public,  ...)  
                                                     •  qualiﬁed  access  (a.b)  
                                                     •  overloading,  namespaces  
                                                     •  ...  
                                                                                                                    10  

L08.pdf:                                  Name  binding:  Blocks  
class  A  {                                    Block:  a  syntacBc  unit  containing  
    int  f;                                  declaraBons  and  statements.  
    int  m1(int  x)  {    
        int  a  =  4;                Can  be  nested.  Called  block  strucure  or  
        int  f  =  a  +  5;      lexical  nes<ng.  
        return  x  *  f  +  b;    
    }                                          DeclaraBons  in  inner  blocks  shadow  
}                                                  declaraBons  in  outer  blocks  
    
class  B  extends  A  {                    DeclaraBon  ordering  can  be  
    int  m2()  {                           •  insigniﬁcant,  or  
        System.out.println(m1(3));         •  declare-­‐before-­‐use  
    }    
}  
  
...  
                                                                                                           11  

L08.pdf:                          Name  binding:  Inheritance  
class  A  {                                                             Inheritance  and  block  nesBng  
    int  x;                                                           can  be  combined.  
    class  AA  {  
        int  y;                                                   In  what  block  order  should  we  
    }                                                                   look  for  the  declaraBon  of  x?  
}  
                                                                            m  
class  B  extends  A  {                                             BB  
    int  y,  z;                                                     AA  
    class  BB  extends  AA  {                                   B  
        int  v;                                                   A  
        void  m()  {                                            globally  
            int  w  =  x  +  y  +  z  +  v;   Which  declaraBon  of  y  is  y  
        }                                                           bound  to?  
    }    
}  
                                                                              AA.y  
  
                                                                              since  inheritance  binds  Bghter  
...  
                                                                              than  lexical  nesBng.  
                                                                                                                               12  

L08.pdf:               Name  binding:  Qualiﬁed  access  
class  A  {  
    int  m()  {  ...  };  
}                                            Qualiﬁed  access  (dot  notaBon)  
    
class  B  extends  A  {              The  binding  of  m  depends  on  the  
    void  m()  {                     type  of  a.  
        A  a  =  new  B();  
        System.out.println(a.m());  
    }  
}  
  
...  
                                                                                                     13  

L08.pdf:                                                  Recall:  
 RepresenBng  name  bindings  in  an  AST  
 {                                                                      Block  
    int  a;  
    a  =  3;  
 }                                                     VarDecl                            Assign  
                                                 IntType    IdDecl              IdUse         IntExp  
IdDecl  for  declared  names                           ID="a"             ID="a"        INT="3"  
IdUse  for  used  names                                                      decl  
An  a<ribute  decl  represents  the  name  binding.  
                                                                                                                14  

L08.pdf:                                                          Recall:  
 CompuBng  name  bindings  imperaBvely  
 {                                                                                 Block  
    int  a;  
    a  =  3;  
 }                                                            VarDecl                                Assign  
                                                        IntType        IdDecl              IdUse         IntExp  
                                                                          ID="a"             ID="a"        INT="3"  
Use  a  symbol  table  data  structure:                                             decl  
For  each  block,  a  map  from  visible  names  to  declaraBons.  
Use  a  stack  of  maps  to  handle  nested  blocks.  
Algorithm:  
Traverse  the  AST  
push/pop  symbol  table  when  entering/leaving  a  block  
add/lookup  idenBﬁers  when  encountering  IdDecls/IdUses  
                                                                                                                           15  

L08.pdf:        Problems  with  the  imperaBve  approach  
•  Need  to  write  an  algorithm  that  computes  things  in  the  right  
     order.  
•  What  if  we  have  more  complex  name  binding  rules?  
     Need  a  more  elaborate  symbol  table.  
     The  algorithm  may  get  complex.  
•  What  if  we  extend  the  language?  
     Need  to  change  the  algorithm.  
  
SoluBon:  A<ribute  grammars  –  a  declaraBve  approach  
                                                                                                  16  

L08.pdf:                                        Name  analysis  using  RAGs  
Think  declara&vely!!  
What  a<ributes  would  I  like  the  nodes  to  have?  
Synthesized  –  deﬁned  in  the  node  
Inherited  –  deﬁned  in  a  parent                   Program  
                                                                    Block                eq  child.lookup(String)  =  ...  
                                          VarDecl                                                  Assign  
                              IntType            IdDecl                         IdUse                               IntExp  
                                                    ID="a"                        ID="a"                              INT="3"  
                                                                                   syn  decl   eq  decl  =  lookup(ID)  
                                                                           inh  lookup(String)  
                                                                                                                                      17  

L08.pdf:                                         The  Lookup  pa.ern  
                                    for  name  analysis  in  RAGs  
decl  –  the  name  binding  
lookup(String)  –  ﬁnds  the  declaraBon                        Program               eq  child.lookup(String)  =  NoDecl  
localLookup(String)  –  looks  locally  
eq  child.lookup(String)  –                                                         eq  child.lookup(String)  =  ...  
    delegates  to  localLookup  and  lookup  a<ributes,    Block        syn  localLookup(String)  
    according  to  scope  rules.                                             inh  lookup(String)  
                                                                                          eq  child.lookup(String)  =  ...  
                                                               Decl      Block        syn  localLookup(String)  
                                                                                         inh  lookup(String)  
                                                               Decl                             Use  
                                                                                                ID="a"  
                                                                                               syn  decl  
                                                                                       inh  lookup(String)  
General  pa<ern  for  name  analysis.  
Can  handle  block  structure,  inheritance,  qualiﬁed  access,  ...  
                                                                                                                                         18  

L08.pdf:         Example  implementaBon  in  JastAdd  
   Abstract  grammar:                                         A<ributes  and  equaBons:  
Program  ::=  Block;                                        syn  IdDecl  IdUse.decl()  =  lookup(getID());  
Block  :  Stmt  ::=  Decl*  Stmt*;    
Decl  ::=  Type  IdDecl;                                  inh  IdDecl  IdUse.lookup(String  s);  
IdDecl  ::=  <ID:String>;    
Type;                                                           eq  Block.getStmt().lookup(String  s)  {  
abstract  Stmt;      IdDecl  d  =  localLookup(s);  
Assign  :  Stmt  ::=  To:IdUse  From:IdUse;      if  (d  !=  null)  return  d;  
IdUse  ::=  <ID:String>;      return  lookup(s);  
                                                                  }  
  
                  Program                                       syn  IdDecl  Block.localLookup(String  s)  {  
    for  (Decl  d:  getDecls())  {  
        if  (d.getIdDecl().getID().equals(s))  
                      Block              return  d.getIdDecl();  
                                   syn  localLookup(String)  
    }  
                                  inh  lookup(String)  
    return  null;  
                                                                  }  
    Decl            Block      syn  localLookup(String)    
                                  inh  lookup(String)         inh  IdDecl  Block.lookup(String  s);  
  
                                                                  eq  Program.getBlock().lookup(String  s)  {  
    Decl                                 Use      return  null;  
                                         ID="a"                 }  
                                        syn  decl  
                                inh  lookup(String)                                                                       19  

L08.pdf:                                             Demand  evaluaBon  
A<ributes  are  not  evaluated  unBl  demanded.                   Program  
Simple  recursive  caching  algorithm:  
If  not  cached  
    ﬁnd  the  equaBon                                                                localLookup("a")   3  
    compute  its  right-­‐hand  side                               Block         localLookup("b")   6  
    cache  the  value                                                                     lookup("b")         7  
ﬁ  
Return  the  cached  value  
                                                                     List                         List  
                                                            Decl                               Assign  
Example  program                               Type     IdDecl              IdUse                    IdUse  
demanding  a<ributes:                                      ID="a"             ID="a"                   ID="b"  
                                                                                     decl   1                   decl      4  
Program  p  =  ...  
Assign  a  =  p.getBlock().getStmt(0);                                    lookup("a")   2        lookup("b")            5  
System.out.println(a.getTo().decl());  
System.out.println(a.getFrom().decl());  
                                                                                                                                      20  

L08.pdf:           More  eﬃcient  implementaBon  of  localLookup  
  syn  IdDecl  Block.localLookup(String  s)  {                                      What  happens  if  there  are  1000  
    for  (Decl  d:  getDecls())  {                                            elements  in  the  declaraBon  list?  
        if  (d.getIdDecl().getID().equals(s))                                   What  is  the  complexity?  
            return  d.getIdDecl();  
    }  
    return  unknownDecl();                                                         Linear  search  for  each  declaraBon  gives  
  }                                                                                        quadraBc  Bme  complexity:  O(n2)  
More  eﬃcient:                                   syn  IdDecl  Block.localLookup(String  s)  {  
    IdDecl  result  =  localMap().get(s);  
Use  a  local  hashmap  which      return  (result!=null)?result:unknownDecl();  
is  built  on  the  ﬁrst  access.        }  
Aler  that  each  access  is    
                                                     syn  Map<String,IdDecl>  Block.localMap()  {  
done  in  constant  Bme.      Map<String,IdDecl>  map  =  new  HashMap<String,IdDecl>();  
ResulBng  complexity:  O(n)      for  (Decl  d:  getDecls())  {  
        IdDecl  id  =  d.getIdDecl();  
        map.put(id.getID(),  id);  
    }  
    return  map;      
                                                     }  
                                                                                                                                                  21  

L08.pdf:Nonterminal  a<ributes  
  
  The  Null  Pa<ern  
                             22  

L08.pdf:                                 Nonterminal  a<ributes  (NTAs)  
     A  ::=  B;                                                    Draw  the  n  a-ribute  and  its  value!  
     B;  
     C  ::=  D;                                                                                     A  
     D;  
A  nonterminal  a<ribute  is  both  an  a<ribute  
and  a  nonterminal  (AST  node).                                                                B  
  
The  value  must  consist  of  fresh  nodes.  
(If  you  reuse  exisBng  nodes,  the  a<ributes  
may  get  inconsistent  values.)  
     syn  nta  C  B.n()  =  new  C(new  D());  
     Use  for  reifying  informaBon  (making  implicit  informaBon  explicit).  
     For  example,  primiBve  types,  predeﬁned  funcBons,  ...  
                                                                                                                                  23  

L08.pdf:                                 Nonterminal  a<ributes  (NTAs)  
     A  ::=  B;  
     B;  
     C  ::=  D;                                                                                        A  
     D;  
A  nonterminal  a<ribute  is  both  an  a<ribute  
                                                                                                             B   n  
and  a  nonterminal  (AST  node).  
  
The  value  must  consist  of  fresh  nodes.  
(If  you  reuse  exisBng  nodes,  the  a<ributes                                                           C  
may  get  inconsistent  values.)  
     syn  nta  C  B.n()  =  new  C(new  D());  
                                                                                                                          D  
     Use  for  reifying  informaBon  (making  implicit  informaBon  explicit).  
     For  example,  primiBve  types,  predeﬁned  funcBons,  ...  
     Warning!  
     If  you  reuse  exis<ng  nodes  for  NTAs,  the  AST  will  be  inconsistent.  
     JastAdd  does  not  check  this.  
                                                                                                                                24  

L08.pdf:                          Nonterminal  a<ributes  (NTAs)  
A  ::=  B;                                            Draw  the  x,  y,  and  z  a-ributes  and  their  values!  
B;  
C  ::=  D;                                                                                           A  
D;  
 syn  nta  C  B.n()  =  new  C(new  D());  
                                                                                                           B         n  
An  NTA  may  itself  have  a<ributes.  
inh  int  C.x();                                                                                                       C  
eq  B.n().x()  =  5;  
syn  int  B.y()  =  n().z()  *  3;  
syn  int  C.z()  =  x()  +  2;  
                                                                                                                              D  
                                                                                                                                      25  

L08.pdf:                          Nonterminal  a<ributes  (NTAs)  
A  ::=  B;  
B;  
C  ::=  D;                                                     A  
D;  
 syn  nta  C  B.n()  =  new  C(new  D());  
                                                            y=21   B   n  
An  NTA  may  itself  have  a<ributes.  
                                                                                        x=5  
inh  int  C.x();                                                           C  
                                                                                        z=7  
eq  B.n().x()  =  5;  
syn  int  B.y()  =  n().z()  *  3;  
syn  int  C.z()  =  x()  +  2;  
                                                                                  D  
                                                                                                26  

L08.pdf:                                  The  Null  object  pa.ern  
Use  a  real  object  instead  of  null.      syn  IdDecl  IdUse.decl()  =  lookup(getID());  
  
Give  the  object  suitable  behavior.            inh  IdDecl  IdUse.lookup(String  s);  
The  code  becomes  simpler.    
                                                            eq  Block.getStmt().lookup(String  s)  {  
    IdDecl  d  =  localLookup(s);  
    if  (!d.isUnknown())  return  d;  
    return  lookup(s);  
In  RAGs:  use  null  objects  for  missing   }  
declaraBons,  unknown  types,  etc.    
                                                            syn  IdDecl  Block.localLookup(String  s)  {  
    for  (Decl  d:  getDecls())  {  
        if  (d.getIdDecl().getID().equals(s))  
            return  d.getIdDecl();  
    }  
    return  unknownDecl();  
But  how  can  we  implement                      }  
unknownDecl()?    
                                                            inh  IdDecl  Block.lookup(String  s);  
  
                                                            eq  Program.getBlock().lookup(String  s)  {  
    return  unknownDecl();  
                                                            }  
See  h<p://en.wikipedia.org/wiki/Null_Object_pa<ern                                                                 27  

L08.pdf:                          Non-­‐terminal  a<ributes  (NTAs)  
An  NTA  is  both  a  node  and  an  a.ribute.  
                                                                                                             A   eq  child.a  =  ...    
The  right-­‐hand  side  of  its  deﬁning  equaBon  
must  be  a  fresh  object  (not  part  of  any  AST).  
                                                                                                               B  
Useful  for  reifying  implicit  constructs                                                                n  
(make  them  explicit  in  the  AST),  like:  
•  Missing  declaraBons  
                                                                                                         C                 N             an  NTA  
•  Unknown  types  
•  PrimiBve  types  and  funcBons                                                                                  inh  a  
                                                                             An  NTA  can  have  a<ributes.  
     syn  nta  N  B.n()  =  new  N();                          The  owning  node  (or  its  ancestors)  must  
                                                                             deﬁne  the  inherited  a<ributes  of  the  NTA.  
                                                                                                                                                       28  

L08.pdf:                            Non-­‐terminal  a<ributes  (NTAs)  
     An  NTA  is  both  a  node  and  an  a.ribute.  
                                                                                             Program  
     The  right-­‐hand  side  of  its  deﬁning  equaBon                                           unknownDecl  
     must  be  a  fresh  object  (not  part  of  any  AST).  
                                                                                                      Block             UnknownDecl  
     Add  an  UnknownDecl  object  to  the  AST  
     using  a  non-­‐terminal  a<ribute  
                                                                                           List                            List  
Extend  the  abstract  grammar:  
        UnknownDecl  :  IdDecl;  
                                                                                           Decl                        Assign  
Add  the  NTA:  
 syn  nta  UnknownDecl  Program.unknownDecl()  =  
    new  UnknownDecl("<Unknown>");  
                                                                                  Type      IdDecl            IdUse             IdUse  
                                                                                               ID="a"           ID="a"            ID="b"  
Implement  the  special  behavior:  
 syn  boolean  IdDecl.isUnknown()  =  false;                              But  how  can  we  make  the  
 eq  UnknownDecl.isUnknown()  =  true;  
                                                                                    UnknownDecl  object  known  
                                                                                    throughout  the  AST?                                  29  

L08.pdf:                               The  Root  A.ribute  pa<ern  
Intent:                                                                      syn  a  
Make  an  a<ribute  in  the  root  visible              Root   eq  child.a  =  a  
throughout  the  AST.  
                                                                       A  
Solu&on:  
Add  an  equaBon  in  the  root,  
propagaBng  the  value  to  the  children.  
                                                                B    C  
  
Expose  the  a<ribute  by  declaring  it  as  
inherited  where  it  is  needed.  
                                                              D              E  
Or  declare  it  in  ASTNode.  Then  it  will                  inh  a  
be  visible  in  all  nodes.  
                                                                                                           30  

L08.pdf:                          ImplemenBng  unknownDecl  
                                                                      Program  
Apply  the  Root  A<ribute  pa<ern:                                unknownDecl  
eq  Program.getBlock().unknownDecl()  =    
    unknownDecl();                             unknownDecl      Block           UnknownDecl  
  
inh  UnknownDecl  Block.unknownDecl();  
                                                             List                          List  
                                                             Decl                    Assign  
                                                    Type      IdDecl          IdUse             IdUse  
                                                                 ID="a"         ID="a"            ID="b"  
                                                                                                       decl  
                                                                                                                 31  

L08.pdf:Type  analysis  
                     32  

L08.pdf:                                               Type  analysis  
         Type  analysis:  compute  the  type  
         of  each  expression  
                                                                           Program  
Add  a  type  a<ribute  to  Expr                                         unknownDecl   unknownType  
syn  Type  Expr.type();  
                                                                                Block              UnknownDecl        ...  
Implement  it  for  IdUses  
                                                                                                              type  
 eq  IdUse.type()  =  decl().type();  
                                                                  List                             List  
Deﬁne  the  type  a<ribute  for  IdDecls  
inh  Type  IdDecl.type();  
eq  Decl.getIdDecl().type()  =  getType();  
eq  Program.unknownDecl().type()  =                       Decl                         Assign  
    unknownType();  
                                                         Type      IdDecl             IdUse             IdUse  
Deﬁne  unknownType  as  an  NTA  
                                                                      ID="a"            ID="a"             ID="b"  
...  
                                                                       type               decl              decl  
  
                                                                                            type              type  
                                                                                                                          33  

L08.pdf:                                                  Type  checking  
          Type  checking:  Check  if  types  
          are  used  correctly  
                                                                                                       Program  
First  a<empt:                                                                                               unknownDecl   unknownType  
  syn  boolean  Assign.compatibleTypes()  =  
    getTo().type().equals(getFrom().type());  
                                                                                                    Block               UnknownDecl        ...  
                                                                                                                                           type  
Second  a<empt:  
                                                                                           List                                 List  
syn  boolean  Assign.compatibleTypes()  =  
    getFrom().type().isUnknownType()  ||  
    getTo().type().isUnknownType()  ||  
    getTo().type().equals(getFrom().type());  
                                                                                          Decl                                Assign  
                                                                        Type                   IdDecl             IdUse              IdUse  
                                                                                                  ID="a"             ID="a"             ID="b"  
                                                                                                   type                decl              decl  
                                                                                                                        type               type  
Problem  with  ﬁrst  a<empt:  Missing  declaraBon  errors  will  give  type  checking  errors  as  well.  
Would  be  nicer  to  view  unknownType  as  compaBble  with  all  other  types.                                               34  

L08.pdf:CollecBon  a<ributes  
  
   Error  checking  
                           35  

L08.pdf:                                        CollecBon  a<ributes  
                                                                                                        A  
A  collecBon  a<ribute  is  deﬁned  by  contribuBons,  
instead  of  by  a  single  equaBon.  
                                                                                                        B  
Use  for  values  combined  from  many  small  parts                 collection  
spread  out  over  the  tree.                                                    s    C            D  
                                                                                                                 E  
Example  uses:  
                                                                                                           E  contributes  ...  
-­‐  collect  compile-­‐Bme  errors  in  a  program  
-­‐  collect  what  uses  are  bound  to  a  speciﬁc  declaraBon  
-­‐  count  the  number  of  if-­‐statements  in  a  method  
When  a  collecBon  a<ribute  is  accessed,  the  a<ribute  evaluator  will  automaBcally  
traverse  the  AST  and  ﬁnd  the  contribuBons.  
                                                                                                                               36  

L08.pdf:                                    CollecBon  a<ributes  
An  collec&on  a<ribute  has  a  composite  value.                                           A  
                                                                                 collec<on  
Contribu&on  rules  can  declare  elements  that                       a-ribute  
should  contribute  to  the  composite  value.                               t         B            C  
  
The  a<ribute  evaluator  will  automaBcally  
traverse  the  AST  starBng  from  a  given  root,  
and  add  the  contribuBons,  using  a  method  m                              D          E      contribu<on  
which  must  be  commuta&ve.                                                                         x  
                                                                                                           theB  
Declare  the  collecBon:  
coll  T  B.t()  [new  T()]  with  m  root  B;  
Declare  a  contribuBon                                        Propagate  theB  (Root  A<ribute  pa<ern):  
(suppose  E  has  an  a<ribute  x):                       inh  B  E.theB();  
E  contributes  x                                               eq  B.getChild().theB()  =  this;  
    when  condition  
    to  B.t()  
    for  theB();  
                                                                                                                                37  

L08.pdf:                     CollecBon  a<ributes,  example  1  
...  
IdDecl  ::=  <ID:String>;                           Program  
IdUse  ::=  <ID:String>;  
                                        ClassDecl                        ClassDecl  
                                  IdDecl    IdDecl                IdUse     IdUse  
                                   ID="b"    ID="a"                ID="a"    ID="a"  
                                                                        decl      decl  
                                                                                              38  

L08.pdf:                          CollecBon  a<ributes,  example  1  
...  
IdDecl  ::=  <ID>;                                                                                                      Program  
IdUse  ::=  <ID>;  
                                                                 ClassDecl                                                                   ClassDecl  
A  "uses"  a-ribute  contains  the  collec<on  of  
          IdUses  referring  to  the  IdDecl  
                                                         IdDecl      IdDecl                                                           IdUse     IdUse  
                                                          ID="b"      ID="a"                                                           ID="a"    ID="a"  
                                                        uses=  ∅
 uses={            ,            }           decl      decl  
coll  Set<IdUse>  IdDecl.uses()  [new  Set<IdUse>()]  with  add;  
  
IdUse  contributes  this  
to  IdDecl.uses()  
for  decl();  
                                                                                                                                                                  39  

L08.pdf:                       CollecBon  a<ributes,  example  2  
JastAdd  Java  grammar  
ClassDecl  ...  
MethodDecl  ...  
ConstructorDecl  ...  
                                                                     Program  
                                    ClassDecl                                                    ClassDecl  
                       MethodDecl             ConstructorDecl                 MethodDecl                   MethodDecl  
               Private                      Public                         Public                          Public  
ContribuBons  can  be  condiBonal.  
Example:  NPM  metric-­‐  Number  of  Public  Methods  and  constructors  in  a  class  
                                                                                                                            40  

L08.pdf:                          CollecBon  a<ributes,  example  2  
JastAdd  Java  grammar  
ClassDecl  ...  
MethodDecl  ...  
ConstructorDecl  ...  
                                                                          Program  
                   publicMethods=1
 ClassDecl                            publicMethods=2
 ClassDecl  
                          MethodDecl           ConstructorDecl                         MethodDecl          MethodDecl  
                    Private                    Public                            Public                    Public  
ContribuBons  can  be  condiBonal.  
Example:  NPM  metric-­‐  Number  of  Public  Methods  and  constructors  in  a  class  
coll  Counter  ClassDecl.publicMethods  ()  [new  Counter()]  with  add;  
  
MethodDecl  contributes  1  when  isPublic()  to  ClassDecl.publicMethods()  for  hostType();  
ConstructorDecl  contributes  1  when  isPublic()  to  ClassDecl.publicMethods()  for  hostType();        41  

L08.pdf:                                             Error  checking  
Error  checking:  collect  all  errors  
                                                                          Program  
                                                               errors            unknownDecl   unknownType  
We  would  like  an  a<ribute  
                                                                              Block              UnknownDecl              ...  
errors  in  the  root,  containing  all  
error  messages.                                                                                        type  
  
We  would  like  an  easy  way  to                List                             List  
"contribute"  diﬀerent  kinds  of  
errors  from  diﬀerent  nodes  in  
the  AST.                                                  Decl                          Assign  
                                                      Type       IdDecl             IdUse             IdUse  
                                                                    ID="a"            ID="a"             ID="b"  
                                                                     type               decl              decl  
                                                                                          type              type  
                                                                                                      contribute  error  
                                                                                                                              42  

L08.pdf:                          Example:  CollecBng  errors  
  Error  checking:  collect  all  errors  
                                                                              Program  
                                                                   errors            unknownDecl   unknownType  
  Declare  the  errors  collecBon:  
  coll  Set<String>  Program.errors()  
    [new  HashSet<String>()]                                            Block              UnknownDecl              ...  
    with  add                                                                                         type  
    root  Program;  
                                                                    List                             List  
Propagate  a  reference  to  the  Program  root:  
(Root  A<ribute  pa<ern):  
inh  Program  ASTNode.theProgram();                          Decl                          Assign  
eq  Program.getChild().theProgram()  =  this;  
                                                          Type       IdDecl             IdUse             IdUse  
Contribute  an  error                                             ID="a"            ID="a"             ID="b"  
                                                                         type               decl              decl  
IdUse  contributes  "Undeclared  variable"                                            type              type  
    when  decl().isUnknown()  
    to  Program.errors()                                                                          contribute  error  
    for  theProgram();  
                                                                                                                                  43  

L08.pdf:Circular  a<ributes  
                          44  

L08.pdf:  
                                          Circular  a<ributes  
  syn  Set<State>  State.succ()  =  ...;                                    StateMachine  
                                         State1                     State2               State3         State4  
                                     reachable={2,3}
 reachable={2,3}
 reachable={2,3}
 reachable=∅

What  states  are  reachable  from  state  k?     MathemaBcal  deﬁniBon:  
ImplementaBon  using  a  circular  a<ribute  
syn  Set<State>  State.reachable()  circular  [new  HashSet<State>()]  {  
    HashSet<State>  result  =  new  HashSet<State>();  
    for  (State  s  :  succ())  {  
        result.add(s);  
        result.addAll(s.reachable());  
    }  
    return  result;  
}  
A  circular  a<ribute  may  depend  (transiBvely)  on  itself.                                              45  

L08.pdf:                      Circular  a<ributes  -­‐  terminaBon  
Does  the  computaBon  terminate?  
Yes!  
The  values  (sets  of  states)  can  be  arranged  in  a  latce.  
The  latce  is  of  ﬁnite  height  (the  number  of  states  is  ﬁnite).  
The  equaBons  are  monotonic:  they  use  set  union.  
Warning!  JastAdd  does  not  check  this  property.  If  you  use  non-­‐monotonic  
equaBons  or  values  that  can  grow  unbounded,  you  might  get  nonterminaBon.  
ImplementaBon  using  a  circular  a<ribute  
syn  Set<State>  State.reachable()  circular  [new  HashSet<State>()]  {  
    HashSet<State>  result  =  new  HashSet<State>();  
    for  (State  s  :  succ())  {  
        result.add(s);  
        result.addAll(s.reachable());  
    }  
    return  result;  
}  
A  circular  a<ribute  may  depend  (transiBvely)  on  itself.                              46  

L08.pdf:                              Useful  latce  types  
Set  laOce  
Start  with  the  empty  set.                             Boolean  laOces  
Use  the  UNION  operator.                                  The  latce  is  of  ﬁnite  height:  
Make  sure  there  is  a  ﬁnite  set                  only  two  possible  elements  
of  possible  values  in  a  set.  
                                                                 TRUE                                   FALSE  
                                                               FALSE                                    TRUE  
                                                       Start  with  FALSE                          Start  with  TRUE  
                                                     Use  the  OR  operator               Use  the  AND  operator  
                                                                                                                                   47  

L08.pdf:                   Circular  a<ributes  –  beware  of  externally  
                                                   visible  side  eﬀects!  
It  is  ok  to  use  local  side  eﬀects:  
syn  Set<State>  State.reachable()  circular  [new  HashSet<State>()]  {  
    HashSet<State>  result  =  new  HashSet<State>();  
    for  (State  s  :  succ())  {  
        result.add(s);  
        result.addAll(s.reachable());  
    }  
    return  result;  
}  
Only  the  local  object  is  changed.  There  are  no  externally  visible  side  eﬀects.  This  is  ﬁne!  
Warning!  If  you  by  mistake  change  the  value  of  an  a<ribute,  e.g.  
...  s.reachable().add(...)  ...  
JastAdd  does  not  detect  this  error,  and  inconsistent  a<ribuBon  may  result.  
                                                                                                                                             48  

L08.pdf: There  are  many  ﬁxed-­‐point  problems  in  compilers  
                                and  program  analysis  tools  
  
•  Cyclic  class  hierarchy:  ﬁnd  out  if  a  class  inherits  from  itself  
•  Deﬁnite  assignment:  ﬁnd  out  if  every  variable  is  guaranteed  to  have  been  
     assigned  a  value  before  it  is  used.  
•  Call  graph  analysis:  for  example,  ﬁnd  methods  that  are  never  called  (dead  code)  
•  Data  ﬂow  analysis:  for  example,  ﬁnd  variables  that  are  never  used  (dead  code)  
•  Nullable,  FIRST,  and  FOLLOW  (if  your  "compiler"  is  actually  a  parser  generator)  
•  ...  
                                                                                                                           49  

L08.pdf:                                    Summary  quesBons:  
                              reference  a<ributes,  name  analysis  
•  What  is  a  reference  a<ribute  grammar?  
•  What  is  a  reference  a<ribute?  
•  What  is  a  parameterized  a<ribute?  
•  What  is  name  analysis?  
•  What  is  a  name  binding?  
•  What  does  scope  mean?  
•  Give  examples  of  some  typical  name  binding  rules.  
•  What  does  ”declare-­‐before-­‐use”  mean?  
•  What  is  qualiﬁed  access?  
•  How  does  the  Lookup  pa<ern  work?  
                                                                              50  

L08.pdf:                                         Summary  quesBons:  
                                               NTAs,  type  checking  
•  What  is  a  nonterminal  a<ribute  (NTA)?  
•  What  is  the  Null  Object  pa<ern?  
•  How  does  the  Root  A<ribute  pa<ern  work?  
•  Why  is  it  useful  to  implement  missing  declaraBons  and  unknown  types  as  AST  
   nodes?  
•  What  is  type  analysis  and  type  checking?  
•  How  can  unnecessary  error  propagaBon  be  avoided?  
                                                                                                                      51  

L08.pdf:                                       Summary  quesBons:  
                     CollecBon  a<ributes,  Error  checking,  Circular  a<ributes  
•  What  is  a  collecBon  a<ribute?  
•  How  can  a  collecBon  of  error  message  be  implemented?  
•  What  is  a  circular  a<ribute?  
•  How  is  a  circular  a<ribute  evaluated?  
•  How  can  you  know  if  the  evaluaBon  of  a  circular  a<ribute  will  terminate?  
•  Give  examples  of  properBes  that  can  be  computed  using  circular  a<ributes.  
                                                                                                                    52  

L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L09.pdf:
L10.pdf:EDAN65:  Compilers,  Lecture  10  
  Run;me  systems  
           Görel  Hedin  
        Revised:  2015-­‐09-­‐22  

L10.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac;c  analyzer  
                                                                                                   garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 AQribute                                                                                         heap  
                   Seman;c  analyzer  
 grammar
 objects  
                                            AQributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op;mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L10.pdf:                        Run;me  systems  
Organiza(on  of  data  
     •  Global/sta;c  data  
     •  Ac;va;ons  (method  instances)  
     •  Objects  (class  instances)  
  
Method  calls  
     •  Call  and  return  
     •  Parameter  transmission  
  
Access  to  variables  
     •  Local  variables  
     •  Non-­‐local  variables  
  
Object-­‐oriented  constructs  
     •  Inheritance  
     •  Overriding  
     •  Dynamic  dispatch  
     •  Garbage  collec;on  
                                               3  

L10.pdf:                                                      The  machine  
     Registers:  32  or  64  bits  wide              Memory:  Typically  byte  adressed  
r0                                                           0  
r1                                                           4  
...                                                          8  
r31                                                          12  
                                                               16  
Typically  a  small  number.                           ...  
For  example,  32  registers  
                                                               232-­‐4  
Some  have  dedicated  roles:                          Very  large  –  order  of  Mbyte  or  Gbyte.  
program  counter,  stack  pointer,  ...              Like  a  very  big  array.  
  
Some  are  general  purpose,  for                    Typically  divided  into  diﬀerent  segments:  
computa;ons                                                  global  data,  code,  stack,  heap.  
                                                                                                                              4  

L10.pdf:Example  memory  segments  
      activation
                   stack  
       records  
       objects   heap  
                   global data  
                   code (read only)
                                    5  

L10.pdf:                              Stack  of  ac;va;ons  
The data for each             activation  
method call is stored
                                              Some dedicated registers:  
in an activation            activation  
                                             FP – Frame Pointer. The first word of the current activation  
                              activation  
                                             SP – Stack Pointer. The first unused word of the stack  
              stack grows  
  Synonyms:
  activation record
  activation
  stack frame
  frame
  
  Swedish:                    code       PC – Program counter. The currently executing instruction.  
  ak;veringspost  
                                                                                                        6  

L10.pdf:                       Example  ac;va;on  layout  
   previous  frame      statlink   The  calling  method  pushes  arguments  on  the  stack.  
                            dynlink    The  return  value  is  placed  in  a  register.  
                            retaddr  
                              vars  
                             temps  
                              args     args:  Arguments  to  the  next  called  method.  
current  frame   FP   statlink   statlink:  Frame  of  enclosing  method/object  
                            dynlink    dynlink:  Frame  of  calling  method  
                            retaddr    retaddr:  Saved  PC  -­‐  where  to  jump  at  return  
                              vars     vars:  Local  variables  
                             temps     temps:  Temporary  variables  and  saved  registers  
                             (args)    args:  Arguments  to  the  next  called  method.  
                     SP  
                                                                                                                   7  

L10.pdf:                                              Frame  pointer  
                           Used  for  accessing  arguments  and  variables  in  the  frame  
void  p(int  a,  int  b)  {                                                         statlink  
    int  x  =  1;                                                                   dynlink  
    int  y  =  2;                                                                  retaddr  
    int  z  =  3;                                                                        ...  
    ...                                                                                         a  
}                                                                                                   b  
                                                                      p     FP              statlink  
                                                                                                dynlink  
                                                                                               retaddr  
                                                                                                      x  
                                                                                                      y  
                                                                                                      z  
                                                                                                     ...  
                                                                              SP  
                                                                                                               8  

L10.pdf:                                                 Stack  pointer  
                                Used  for  growing  the  stack,  e.g.,  at  a  method  call  
void  p(int  a,  int  b)  {  
    int  x  =  1;                                                                          statlink  
    int  y  =  2;                                                                          dynlink  
    int  z  =  3;                                                                         retaddr  
    q(4711);                                                                                          a  
}                                                                                                         b  
                                                                             p      FP             statlink  
                                                                                                       dynlink  
                                                                                                      retaddr  
                                                                                                            x  
                                                                                                            y  
                                                                                                            z  
                                                                                                           ...  
               The  argument  4711  is  pushed                                                  4711  
               on  the  stack  before  calling  q                         SP  
                                                                                                                    9  

L10.pdf:                                                     Dynamic  link  
                                      Points  to  the  frame  of  the  calling  method  
void  p1()  {  
    int  x  =  1;                                                      p1                  statlink  
    int  y  =  2;                                                                            dynlink  
                                                                                                       retaddr  
    void  p2()  {                                                                                   x  
        int  z  =  y+1;                                                                      y  
        p3();                                                            p2                  statlink  
    }                                                                                              dynlink  
                                                                                                       retaddr  
    void  p3(){                                                                                       z  
        int  t  =  x+3;  
    }                                                                        p3   FP           statlink  
                                                                                                       dynlink  
    p2();  y++;                                                                                  retaddr  
}                                                                                                            t  
                                                                                          SP  
                                  Used  for  restoring  FP  when  returning  from  a  call.  
                                                                                                                      10  

L10.pdf:                                                   Recursion  
                                     Several  ac;va;ons  of  the  same  method  
                                                                                       ...          statlink  
int  f(int  x)  {                                                                             dynlink  
    if  (x  <=  1)                                                                        retaddr  
        return  1;                                                                          x=3  
    else                                                                         f            statlink  
        return  x  *  f(x-­‐1);                                                       dynlink  
}                                                                                                   retaddr  
                                                                                                        x=2  
...                                                                                  f            statlink  
f(3);                                                                                               dynlink  
...                                                                                                 retaddr  
                                                                                                        x=1  
                                                                                       f     FP   statlink  
                                                                                                      dynlink  
                                                                                                      retaddr  
                                                                                               SP  
                                                                                                                   11  

L10.pdf:                                                                        Sta;c  link  
                                                Points  to  the  frame  of  the  enclosing  method.  
                                    Makes  it  possible  to  access  variables  in  enclosing  methods.  
void  p1()  {  
    int  x  =  1;                                                           p1                 statlink  
    int  y  =  2;                                                                                dynlink  
                                                                                                          retaddr  
    void  p2()  {                                                                                     x  
        int  z  =  y+1;                                                                         y  
        p3();                                                                 p2                 statlink  
    }                                                                                                  dynlink  
                                                                                                          retaddr  
    void  p3(){                                                                                         z  
        int  t  =  x+3;  
    }                                                                             p3   FP          statlink  
                                                                                                           dynlink  
    p2();  y++;                                                                                     retaddr  
}                                                                                                             t  
                                                                                                SP  
      The  methods  are  nested.  
   Supported  in  Algol,  Pascal,  
              but  not  in  C,  Java...                                                                           12  

L10.pdf:                                        Sta;c  link  in  OO  programs  
                                                  Corresponds  to  the  this  pointer.  
                                         Makes  it  possible  to  access  ﬁelds  in  the  object.  
class  A  {  
                                                                               ...                       statlink  
    int  x  =  1;  
                                                                                                           dynlink  
    int  y  =  2;  
                                                                                                           retaddr  
  
    void  ma()  {                                                    mb                        statlink  
        x  =  3;                                                                             dynlink  
    }                                                                                                retaddr  
}                                                                            ma   FP                 statlink  
                                                                                                           dynlink  
class  B  {                                                                                          retaddr  
    void  mb()  {  
                                                                                       SP  
        A  a  =  ...;  
        a.ma();  
    }  
}                                                                                                       A  object  
                                                                                                                          13  

L10.pdf:                                                     Access  to  local  variable  
void  p()  {                                                                       p   FP         statlink  
    int  x  =  1;                                                                               dynlink  
    int  y  =  2;                                                                               retaddr  
    y++;                                                                                                 x  
    ...                                                                                                  y  
}  
                                                                                               SP  
Assume  all  variables  can  be  stored  in  one  32  bit  word.  
  
The  compiler  enumerates  the  variables:  
nr(x)  =  0  
nr(y)  =  1  
  
Compute  oﬀset  rela;ve  FP  
oﬀset(y)  =  headersize  +  nr(y)*4  =  12+4  =  16  
Typical  assembly  code  for  y++  
ADD      FP  #16  R1    //  R1  is  now  the  address  to  y  
LOAD    R1  R2            //  R2  is  now  the  current  value  of  y  
INC      R2                  //  Increment  R2  
STORE  R2  R1            //  Store  the  new  value  to  memory                            14  

L10.pdf:                          Compu;ng  oﬀsets  for  variables  
void  p()  {                               The  compiler  can  reorder  variables  in  the  
    boolean  f1  =  true;            ac;va;on  to  make  eﬃcient  use  of  the  space.  
    int  x  =  1;    
    boolean  f2  =  false;       y  and  z  have  disjoint  life;mes.  
    if  (...)  {                       They  could  share  the  same  memory  cell.  
        int  y  =  2;    
        ...                            The  booleans  could  be  stored  in  consecu;ve  
    }                                      bytes,  or  bits.  
    else  {    
        int  z  =  3;          ...  
        ...  
    }  
    ...  
}  
                                                                                                                     15  

L10.pdf:                                                        Access  to  non-­‐local  variable  
void  p1()  {  
    int  x  =  1;                                                                   p1          statlink  
                                                                                                              dynlink  
    int  y  =  2;  
    void  p2()  {                                                                                   retaddr  
                                                                                                                  x  
        y++;  
    }                                                                                                       y  
                                                                                                                 ...  
    p2();  
}                                                                                             p2   FP   statlink  
                                                                                                              dynlink  
The  compiler  knows  that  y  is  declared  in  the  enclosing  block.  
                                                                                                              retaddr  
Follow  the  sta;c  link  once  to  get  to  the  enclosing  frame               SP  
LOAD    FP  R1            //  R1  is  now  the  address  to  
                                  //  p1's  frame  
  
ADD      R1  #16  R2    //  R2  is  now  the  address  to  y  
LOAD    R2    R3          //  Load  y  
INC      R3                  //  Increment  
STORE  R3    R2          //  Store  the  new  value  to  memory  
  
For  deeper  nes;ng,  follow  mul;ple  sta;c  links.  
                                                                                                                           16  

L10.pdf:                                                      Method  call  
  void  p1()  {                                                             2      int  p2(int  a,  int  b)  {  
    int  x,  y,  z;      ...  
    ...                                                                   3      ...  
    z  =  p2(x+1,  y*2);  1      ...  
    ...                                                                    4      return  ...  
                                           5      ...  
  }                                                                                      }  
1.  Transfer  the  arguments  and  the  sta;c  link.    
        Store  the  return  address  in  a  register  and  jump  to  code  of  the  called  procedure.  
2.  Allocate  the  new  ac;va;on  and  move  FP.  
3.  Run  the  code  for  p2.  
4.  Store  the  return  value  in  a  register.  
        Deallocate  the  ac;va;on.  Move  FP  back.  
        Jump  back  to  the  return  address.  
5.  Save  the  return  value  if  needed.  
        Con;nue  execu;ng  in  p1.  
                                                                                                                                       17  

L10.pdf:              Step  1:  Transfer  arguments  and  call.  
p1   FP            statlink                              p1   FP              statlink  
                       dynlink                                                        dynlink  
                       retaddr                                                        retaddr  
                          x                                                              x  
                          y                                                              y  
                          z                                                              z  
                                                                                           a  
       SP                                                                                b  
                                                                                        statlink  
                                                                     SP  
        •  Push  arguments  and  sta;c  link.  
              (The  sta;c  link  can  be  viewed  as  an  implicit  argument.)  
        •  Compute  the  return  address  (e.g.,  PC+4)  and  store  it  in  a  register.  
        •  Jump  to  the  called  method  code.  
              (Usually  use  a  CALL  instruc;on  for  doing  these  two  things.)  
                                                                                                                    18  

L10.pdf:              Step  2:  Allocate  the  new  ac;va;on  
p1   FP     statlink                                 p1                  statlink  
                dynlink                                                        dynlink  
                retaddr                                                        retaddr  
                     x                                                             x  
                     y                                                             y  
                     z                                                             z  
                     a                                                             a  
                     b                                                             b  
                statlink                                 p2   FP           statlink    
      SP                                                                       dynlink  
                                                                                 retaddr  
                                                                                    ...  
                                                                                    ...  
                                                                  SP  
                  •      push  the  dynamic  link  (current  FP)  
                  •      set  FP  to  the  new  frame  
                  •      push  the  return  address  (is  in  a  register  from  the  call  instruc;on)  
                  •      push  space  for  new  variables  and  temps                                               19  

L10.pdf:Step  3:  Run  the  code  for  p2  
    p1                  statlink  
                          dynlink  
                          retaddr  
                                x  
                                y  
                                z  
                                a  
                                b  
    p2   FP           statlink    
                          dynlink  
                          retaddr  
                               ...  
                               ...  
           SP  
                  run  the  code  for  p2    
                                                          20  

L10.pdf:           Step  4:  Deallocate  and  return  
p1          statlink       p1   FP             statlink  
              dynlink                                dynlink  
              retaddr                                retaddr  
                    x                                       x  
                    y                                       y  
                    z                                       z  
                    a                                      a  
                   b                                       b  
p2   FP   statlink            SP             statlink    
              dynlink                                dynlink  
              retaddr                                retaddr  
                   ...                                   ...  
                   ...  
       SP                    •     Store  the  return  value  in  a  register.  
                               •     Dealloc  ac;va;on:  Move  SP  back  to  FP.  
                               •     Move  FP  back  by  using  the  dynamic  link.  
                               •     Jump  back  to  the  return  address.  
                                     (Usually  do  all  this  through  a  special  
                                     RETURN  instruc;on)                                          21  

L10.pdf:Step  5:  Con;nue  execu;ng  in  p1  
        p1   FP            statlink  
                               dynlink  
                               retaddr  
                                   x  
                                   y  
                                   z  
                                   a  
                                  b  
               SP               ...  
        •     Save  the  return  value  if  needed.  
        •     Con;nue  execu;ng  in  p1  
                                                                  22  

L10.pdf:     What  the  compiler  needs  to  compute  
For  variables  and  argument  uses  
        •  The  oﬀsets  to  use  (rela;ve  to  the  Frame  Pointer)  
        •  The  number  of  sta;c  levels  to  use  (0  for  locals)  
  
For  method  calls  
        •  The  number  of  sta;c  levels  to  use  (0  for  local  methods)  
  
For  method  declara(ons  
        •  The  space  needed  for  local  declara;ons  and  temporaries    
                                                                                                     23  

L10.pdf:            Registers  typically  used  for  op;miza;on  
Store  data  in  registers  instead  of  in  the  ac;va;on:  
            •  The  return  value  
            •  The  n  ﬁrst  arguments  
            •  The  sta;c  link  
            •  The  return  address  
  
If  a  new  call  is  made,  these  registers  must  not  be  corrupted!  
Calling  conven(ons:  
Conven;ons  for  how  arguments  are  passed,  e.g.,  in  speciﬁc  registers  or  in  the  
ac;va;on  record.  
Conven;ons  for  which  registers  must  be  saved  by  caller  or  callee:  
  
Caller-­‐save  register:  The  caller  must  save  the  register  before  calling.  
  
Callee-­‐save  register:  The  called  method  must  save  these  registers  before  using  
them,  and  restoring  them  before  return.  
                                                                                                                      24  

L10.pdf:Many  diﬀerent  variants  on  ac;va;on  records  
Sta(c  link  or  not:  Can  treat  it  as  an  implicit  argument  when  it  is  needed.  
Dynamic  link  or  not:  Can  let  the  compiler  compute  it  for  each  method.  
Stack  pointer:  Point  to  ﬁrst  empty  word,  or  last  used  word?  
Arguments:  Treat  them  as  part  of  the  calling  or  called  frame?  
Argument  order:  Forwards  or  backwards  order  in  the  frame?  
Direc(on:  Let  the  stack  grow  towards  larger  or  smaller  addresses?  
Allocate  space  for  vars  and  temps:  In  one  chunk,  or  push  one  var  at  a  ;me.  
...  
  
  
Machine  architectures  omen  have  instruc;ons  suppor;ng  a  speciﬁc  ac;va;on  
record  design.  E.g.,  dedicated  FP  and  SP  registers,  and  CALL,  RETURN  instruc;ons  
that  manipulate  them.  
                                                                                                                            25  

L10.pdf:                                        Summary  ques;ons  
•  What  is  the  diﬀerence  between  registers  and  memory?  
•  What  typical  segments  of  memory  are  used?  
•  What  is  an  ac;va;on?  
•  Why  are  ac;va;ons  put  on  a  stack?  
•  What  are  FP,  SP,  and  PC?  
•  What  is  the  sta;c  link?  Is  it  always  needed?  
•  What  is  the  dynamic  link?  
•  What  is  meant  by  the  return  address?  
•  How  can  local  variables  be  accessed?  
•  How  can  non-­‐local  variables  be  accessed?  
•  How  does  the  compiler  compute  oﬀsets  for  variables?  
•  What  happens  at  a  method  call?  
•  What  informa;on  does  the  compiler  need  to  compute  in  order  to  generate  
   code  for  accessing  variables?  For  a  method  call?  
•  What  is  meant  by  ”calling  conven;ons”?  
                                                                                                               26  

L11.pdf:EDAN65:  Compilers,  Lecture  11  
  Code  genera<on  
           Görel  Hedin  
        Revised:  2015-­‐10-­‐05  

L11.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac<c  analyzer  
                                                                                                   garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 APribute                                                                                         heap  
                   Seman<c  analyzer  
 grammar
 objects  
                                            APributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op<mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L11.pdf:                   Recall:  example  ac<va<on  layout  
void  g()  {                          g          statlink  
    ...                                            dynlink  
    p(1,2);                                        retaddr  
    ...                                               ...  
}                                                          a  
                                                                         arguments  
                                                          b  
void  p(int  a,  int  b)  {                  statlink  
                                           p    FP  
    int  x  =  1;                            dynlink  
    int  y  =  2;                            retaddr  
    int  z  =  3;                                x  
    ...                                                y      local  variables  
}                                                          z  
                                                            t1        temporaries  
                                                            t2  
                                                  SP  
                                                                                             3  

L11.pdf:                                    Genera<ng  code  
       Source  code             AST       Intermediate  code   Machine  code  
if  (v1+v2!=v3)            
    v1  =  v3-­‐1;      
v4  =  v2;      
...        
    
    
    
        
  
  
  
                                                                                             4  

L11.pdf:                                        Genera<ng  code  
       Source  code                 AST                  Intermediate  code                   Machine  code  
if  (v1+v2!=v3)        ADD  v1  v2  t1      MOV      1(FP)  R1  
    v1  =  v3-­‐1;      JEQ  t1  v3  L1      ADD      2(FP)  R1  
v4  =  v2;      SUB  v3    1  t2      MOV      R1  5(FP)  
...        MOV  t2  v1      CMP      5(FP)  3(FP)  
                                                                   L1:      JEQ      L1  
    MOV  v2  v4      MOV      3(FP)  R1  
    ...      SUB      1  R1  
          MOV      R1  6(FP)  
    MOV      6(FP)  1(FP)  
                                                                                                        L1:  
  Intermediate  code:      MOV      2(FP)  4(FP)  
  •  Expressions  are  broken  down  to  one  opera<on  per  instruc<on,  
                                                                                                            Variable    addresses  
         introducing  temporary  variables  for  each  non-­‐trivial  expression.  
  •  Variables  have  high-­‐level  symbolic  names.                                                  v1      1(FP)  
                                                                                                                v2      2(FP)  
  •  Control  structures  are  implemented  using  branch  instruc<ons  that   v3      3(FP)  
         jump  to  labels.                                                                                v4      4(FP)  
                                                                                                                t1      5(FP)  
  Machine  code  (assembly  code):                                                                      t2      6(FP)  
  •  Many  opera<ons  can  only  be  done  on  registers.  
  •  Values  in  memory  need  to  be  loaded  to  registers  before  performing  the  opera<on.  
  •  Variable  names  are  replaced  by  addresses,  typically  rela<ve  to  the  frame  pointer.  
                                                                                                                                                  5  

L11.pdf:Two  kinds  of  intermediate  code  
                                                  Three  address  code  
    ADD  v1  v2  t1  
    JEQ  t1  v3  L1  
                                      AST      SUB  v3    1  t2  
    MOV  t2  v1  
         Source  code            L1:  
  if  (v1+v2!=v3)      MOV  v2  v4  
    v1  =  v3-­‐1;      ...  
  v4  =  v2;      
  ...  
                                                   Stack  code  
      
  
  
  
  
  
  
  
  
  
  
  
  
  
                                                                                        6  

L11.pdf:                            Two  kinds  of  intermediate  code  
                                                                                          Three  address  code  
    ADD  v1  v2  t1  
    JEQ  t1  v3  L1  
                                                                              AST      SUB  v3    1  t2  
    MOV  t2  v1  
                                                 Source  code            L1:  
                                          if  (v1+v2!=v3)      MOV  v2  v4  
    v1  =  v3-­‐1;      ...  
                                          v4  =  v2;      
                                          ...  
                                                                                           Stack  code  
        PUSH  v1  
Three  address  code      PUSH  v2  
    ADD  
Each  instruc<on  typically  has  three  operands:  
    PUSH  v3  
          op  src1  src2  dest      JEQ    L1  
      PUSH  v3  
Uses  temporary  variables.      PUSH    1  
    SUB  
Close  to  ordinary  register-­‐based  machine.      POP    v1  
Good  for  op<miza<on.                                                               L1:  
    PUSH  v2  
Stack  code      POP    v4  
Uses  a  value  stack  instead  of  temporary  variables.      ...  
  
Commonly  used  for  interpreters  and  virtual  machines.  
                                                                                                                                7  

L11.pdf:          Translate  to  three  address  code  
                         Source  code                                              Three  address  code  
                     a  =  (b  +  c)  *  (d  +  e)      ADD  b  c  t1  
    ADD  d  e  t2  
    MUL  t1  t2  t3  
    MOV  t3  a  
                                                                       One  new  temporary  for  each  nontrivial  value.  
Why  not  try  to  reuse  the  temporaries?  
    ADD  b  c  t1  
And  remove  useless  MOVs?      ADD  d  e  t2  
In  principle,  two  temps  would  suﬃce  here:      MUL  t1  t2  a  
                                                             Minimizing  the  number  of  temporaries  (not  meaningful).  
Typically,  the  intermediate  code  is  op<mized  at  a  later  stage.  The  op<miza<ons  transform  
the  code  and  introduce  new  temporaries.  Temporaries  are  op<mized  as  a  ﬁnal  step,  as  part  
of  register  alloca<on.  Trying  to  minimize  the  number  of  temporaries  at  the  code  genera<on  
stage  is  therefore  meaningless.  
                                                                                                                                          8  

L11.pdf:                                  Translate  three  address  code  to  
                                        AT&T  x86-­‐64  assembly  code  
 Source  code                                          3  address  code               Variable    addresses                  stack  grows  
void  m(int  a,  int  b)  {      ...                          a      16(%rbp)  
    int  c,  d;      ADD  a  b  t1          b      24(%rbp)       lower  
    ...      MOV  t1  c               c      -­‐8(%rbp)   addresses  
    c  =  a  +  b      ...                          d    -­‐16(%rbp)  
    ...                                                                                      t1  -­‐24(%rbp)  
}  
                                                                                                                                   rsp           t1  
Registers  and  instruc?ons                                                                                                                    d  
rsp:  stack  pointer  (points  to  top  of  stack)                                                                                    c  
rbp:  base  pointer  (frame  pointer)                                                                                    rbp        dynlink  
rip:  instruction  pointer  (program  counter)  
rax,  rbx:  general  registers                                                                                                          retaddr  
                                                                                                                                                   a  
addq  val,  reg    #  reg  +  val  -­‐>  reg  (q:  quad  word  64  bits)  
                                                                                                                                                     b  
Assembly  code                                                                                                                                 ...  
    ...                                                                                                                                   dynlink  
    subq  $24,  %rsp            #  Make  room  on  stack  for  c,  d,  t1  
    ...  
    movq  16(%rbp),  %rax    #  a  -­‐>  rax                                        higher  
    addq  24(%rbp),  %rax              #  b  +  rax  -­‐>  rax                               addresses  
    movq  %rax,  -­‐24(%rbp)            #  rax  -­‐>  t1  
    movq  -­‐24(%rbp),  -­‐8(%rbp)    #  t1  -­‐>  c  
    ...                                                                                                                                                   9  

L11.pdf:                                            Translate  to  assembly  code  
 Source  code                                 Three  address  code   Variable  addresses  
d  =  (a  +  b)  *  (a  +  c)      
    
    
    
  
  
Unop?mized  assembly  code:    
  
  
  
  
  
  
  
  
  
  
  
                                                                                                         10  

L11.pdf:                                            Translate  to  assembly  code  
 Source  code                                      Three  address  code                     Variable  addresses  
d  =  (a  +  b)  *  (a  +  c)      ADD  a  b  t1                 a          -­‐8(%rbp)  
    ADD  a  c  t2                 b        -­‐16(%rbp)  
    MUL  t1  t2  t3               c        -­‐24(%rbp)  
    MOV  t3  d                      d        -­‐32(%rbp)  
                                                                                                      t1      -­‐40(%rbp)  
                                                                                                      t2      -­‐48(%rbp)  
Unop?mized  assembly  code:                                                                     t3      -­‐56(%rbp)  
    movq    -­‐8(%rbp),  %rax  
      #  a  -­‐>  rax  
  
    addq    -­‐16(%rbp),  %rax            #  b  +  rax  -­‐>  rax  
  
    movq    %rax,  -­‐40(%rbp)            #  rax  -­‐>  t1  
  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
  
    addq    -­‐24(%rbp),  %rax            #  c  +  rax  -­‐>  rax  
  
    movq    %rax,  -­‐48(%rbp)            #  rax  -­‐>  t2  
  
    movq    -­‐40(%rbp),  %rax            #  t1  -­‐>  rax  
  
    imulq  -­‐48(%rbp),  %rax            #  t2  *  rax  -­‐>  rax  
  
    movq    %rax,  -­‐56(%rbp)            #  rax  -­‐>  t3  
  
    movq    -­‐56(%rbp),  -­‐32(%rbp)  #  t3  -­‐>  d  
                                                                                                                                          11  

L11.pdf:                         Can  the  use  of  registers  be  op<mized?  
 Source  code                                     Three  address  code                      Variable  addresses  
d  =  (a  +  b)  *  (a  +  c)      ADD  a  b  t1                 a          -­‐8(%rbp)  
    ADD  a  c  t2                 b        -­‐16(%rbp)  
    MUL  t1  t2  t3               c        -­‐24(%rbp)  
    MOV  t3  d                      d        -­‐32(%rbp)  
                                                                                                      t1      -­‐40(%rbp)  
                                                                                                      t2      -­‐48(%rbp)  
Unop?mized  assembly  code:  11  memory  accesses,  7  vars                           t3      -­‐56(%rbp)  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
    addq    -­‐16(%rbp),  %rax            #  b  +  rax  -­‐>  rax  
    movq    %rax,  -­‐40(%rbp)            #  rax  -­‐>  t1  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
    addq    -­‐24(%rbp),  %rax            #  c  +  rax  -­‐>  rax  
    movq    %rax,  -­‐48(%rbp)            #  rax  -­‐>  t2  
    movq    -­‐40(%rbp),  %rax            #  t1  -­‐>  rax  
    imulq  -­‐48(%rbp),  %rax            #  t2  *  rax  -­‐>  rax  
    movq    %rax,  -­‐56(%rbp)            #  rax  -­‐>  t3  
    movq    -­‐56(%rbp),  -­‐32(%rbp)  #  t3  -­‐>  d  
 Op?mized  assembly  code:  
      
  
  
  
  
                                                                                                                                       12  

L11.pdf:                         Can  the  use  of  registers  be  op<mized?  
 Source  code                                                 Three  address  code                       Variable  addresses  
d  =  (a  +  b)  *  (a  +  c)      ADD  a  b  t1                  a          -­‐8(%rbp)  
    ADD  a  c  t2                  b        -­‐16(%rbp)  
    MUL  t1  t2  t3                c        -­‐24(%rbp)  
    MOV  t3  d                       d        -­‐32(%rbp)  
                                                                                                                   t1      -­‐40(%rbp)  
                                                                                                                   t2      -­‐48(%rbp)  
Unop?mized  assembly  code:  11  memory  accesses,  7  vars                                        t3      -­‐56(%rbp)  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
    addq    -­‐16(%rbp),  %rax            #  b  +  rax  -­‐>  rax  
    movq    %rax,  -­‐40(%rbp)            #  rax  -­‐>  t1  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
    addq    -­‐24(%rbp),  %rax            #  c  +  rax  -­‐>  rax  
    movq    %rax,  -­‐48(%rbp)            #  rax  -­‐>  t2  
    movq    -­‐40(%rbp),  %rax            #  t1  -­‐>  rax  
    imulq  -­‐48(%rbp),  %rax            #  t2  *  rax  -­‐>  rax  
    movq    %rax,  -­‐56(%rbp)            #  rax  -­‐>  t3  
    movq    -­‐56(%rbp),  -­‐32(%rbp)  #  t3  -­‐>  d  
 Op?mized  assembly  code:  4  memory  accesses,  4  vars  
    movq    -­‐8(%rbp),  %rax      #  a  -­‐>  rax  
    movq    %rax,  %rbx                      #  rax  -­‐>  rbx  
    addq    -­‐16(%rbp),  %rax            #  b  +  rax  -­‐>  rax  
    addq    -­‐24(%rbp),  %rbx            #  c  +  rbx  -­‐>  rbx  
    imulq  %rax,  %rbx                      #  rax  *  rbx  -­‐>  rbx  
    movq    %rbx,  -­‐32(%rbp)            #  rax  -­‐>  d                                                               13  

L11.pdf:                                                Register  alloca<on  
Accessing  memory  is  slow.  Typical  numbers:  
  
Add  instruc<on  opera<ng  on  registers:  1  ns  
Access  to  L1  cache:  5  ns  
Access  to  memory:  100  ns  
  
Goal  of  register  alloca<on:  
Try  to  keep  as  many  variables  and  temporaries  as  possible  in  registers,  
"spilling"  as  few  of  them  as  possible  to  memory.  
  
Good  algorithms  exist,  based  on  graph  coloring.  
See  course  on  Op<mizing  Compilers,  EDA230.  
  
In  assignment  6,  we  will  not  op<mize  the  code.  
                                                                                                             14  

L11.pdf:                                           Control  structures  
 Source  code                                       3  address  code  
void  m()  {                                      m:  
    int  x,  s;        ...  
    ...                                           m_1:  
    while  (x  >  1)  {        JLE  x  1  m_2        #  if  x  <=  1  jump  to  m_2  
        s  =  s  +  x;        ADD  s  x  t1          #  s  +  x  -­‐>  t1  
    }        MOV  t1  s              #  t1  -­‐>  s  
    ...        JMP  m_1                #  jump  to  label  m_1  
}                                                     m_2:  
      ...  
Note:  
Flip  the  condi<on  to  get  simpler  code  
All  labels  must  be  unique  in  the  program  
                                                                                                                                                         15  

L11.pdf: Source  code  
void  m()  {  
                                                                          Control  structures                                                                             Variable  addresses  
    int  x,  s;                                                                                                                                                     x            -­‐8(%rbp)  
    ...                                                                                                                                                                 s          -­‐16(%rbp)  
    while  (x  >  1)  {                                                                                                                                         t1        -­‐24(%rbp)  
        s  =  s  +  x;  
    }  
    ...  
}  
3  address  code                                     x86  assembly  code  
m:                                                       m:    
      ...        
m_1:                                                     m_1:  
      JLE  x  1  m_2        cmpq  -­‐8(%rbp),  $1          #  Compare  x  and  1  
          jle  m_2                              #  Jump  if  previous  cmp  was  less-­‐or-­‐equal  
      ADD  s  x  t1        movq  -­‐16(%rbp),  %rax    #  s  -­‐>  rax  
        addq  -­‐8(%rbp),  %rax      #  x  +  rax  -­‐>  rax  
        movq  %rax,  -­‐24(%rbp)    #  rax  -­‐>  t1  
      MOV  t1  s        movq  -­‐24(%rbp),  -­‐16(%rbp)    #  t1  -­‐>  s  
      JMP  m_1                        jmp  m_1  
m_2:                                                     m_2:  
      ...        ...  
                                                           New  instruc?ons  used  
                                                           cmpq  a,  b:  compares  a  and  b,  sets  condition  codes  
                                                           jle  lbl:      jumps  to  label  lbl  if  le  condition  code  is  set  
                                                           jmp  lbl:      jumps  to  label  lbl                                                                                                       16  

L11.pdf:                                                       Method  call  
 Source  code                         3  address  code  
      int  x,  y;        
      ...    
      y  =  p(x+1,  2);    
      ...    
  
  
  
  
  
                 Original  situa<on                Passing  the  args   Calling  p   17  

L11.pdf:                                                        Method  call  
 Source  code                         3  address  code  
      int  x,  y;      ...  
      ...      ADD  x  1  t1  #  Eval  arg  1  
      y  =  p(x+1,  2);      MOV  2  t2      #  Eval  arg  2  
      ...      MOV  t2  a2    #  Pass  arg  2  
    MOV  t1  a1    #  Pass  arg  1  
    CALL  p          #  Do  the  call  
    MOV  rv  t3    #  Save  the  return  value  
    MOV  t3  y  
    ...  
                                                                                                          rsp    retaddr  
                                                rsp                           a1                                   a1  
                                                                                a2                                   a2  
rsp                        t3                                               t3                                   t3  
                             t2                                               t2                                   t2  
                             t1                                               t1                                   t1  
                               y                                                y                                   y  
                               x                                                x                                   x  
rbp                    dynlink              rbp                     dynlink                       rbp    dynlink  
                 Original  situa<on                     Passing  the  args                              Calling  p   18  

L11.pdf:                                                      Method  call  
  Source  code  
      int  x,  y;                                      Calling  conven?ons:  
      ...  
      y  =  p(x+1,  2);                              Args  pushed  in  reverse  order  on  stack  
      ...                                                  Return  value  stored  in  RAX  register  
 3  address  code                  Assembly  code  
    ...        
    ADD  x  1  t1    
    
    
    MOV  2  t2    
    MOV  t2  a2      
    MOV  t1  a1      
    CALL  p    
    
    MOV  rv  t3    
    MOV  t3  y    
    ...    
Variable  alloca?on                               New  instruc?ons  used  
                                                  pushq  v:  pushes  a  value  to  the  stack  (moves  rsp)  
                                                  call  m:  pushes  the  return  address  and  jumps  to  m  
  
  
                                                                                                                                  19  

L11.pdf:                                                             Method  call  
  Source  code  
      int  x,  y;                                                                     Calling  conven?ons:  
      ...  
      y  =  p(x+1,  2);                                                             Args  pushed  in  reverse  order  on  stack  
      ...                                                                                 Return  value  stored  in  RAX  register  
 3  address  code                  Assembly  code  
    ...      ...  
    ADD  x  1  t1      movq  -­‐8(%rbp),  %rax    #  x  -­‐>  rax  
      addq  $1,  %rax                          #  1  +  rax  -­‐>  rax  
      movq  %rax,  -­‐24(%rbp)            #  rax  -­‐>  t1  
    MOV  2  t2      movq  $2,  -­‐32(%rbp)    #  2  -­‐>  t2  
    MOV  t2  a2        pushq  -­‐32(%rbp)                      #  push  arg  2  
    MOV  t1  a1        pushq  -­‐24(%rbp)                      #  push  arg  1  
    CALL  p      call  p2                                      #  call  p  
      addq  $16,  %rsp                        #  pop  arguments  
    MOV  rv  t3      movq  %rax,  -­‐40(%rbp)            #  rax  -­‐>  t3  (save  return  val)  
    MOV  t3  y      movq  -­‐40(%rbp),  -­‐16(%rbp)  #  t3  -­‐>  y  
    ...      ...  
Variable  alloca?on                                           New  instruc?ons  used  
  x        -­‐8(%rbp)                                   pushq  v:  pushes  a  value  to  the  stack  (moves  rsp)  
  y        -­‐16(%rbp)                                  call  m:  pushes  the  return  address  and  jumps  to  m  
  t1      -­‐24(%rbp)  
  t2      -­‐32(%rbp)  
  t3      -­‐40(%rbp)                                                                                                                                    20  

L11.pdf:                                     Method  ac<va<on  and  return  
   Source  code                         3  address  code  
  int  p(int  a,  int  b)  {    p:  
    int  r;      START            #  Start  of  activation  
    ...      SPACE  2        #  Make  space  for  2  vars  and  temps  
    return  r+1      ...  
  }      ADD  r  1  t1  #  Compute  the  value  to  return  
    MOV  t1  rv    #  Store  the  return  value  
    RETURN          #  Return  to  the  caller        
                                                                                                        rsp                    t1  
                                                                                                                                  r  
                                     rsp, rbp                dynlink                                rbp           dynlink  
rsp             retaddr                                   retaddr                                                 retaddr  
                         a                                           a                                                        a  
                        b                                            b                                                        b  
                        ...                                         ...                                                      ...  
rbp             dynlink                                   dynlink                                                  dynlink  
                At  label  p                         Aher  START                                      Aher  alloca<ng  space   21  

L11.pdf:                                 Method  ac<va<on  and  return  
  Source  code  
 int  p(int  a,  int  b)  {  
    int  r;  
    ...  
    return  r+1  
 }  
 3  address  code                   Assembly  code  
 p:    
    START    
    
    SPACE  2    
    ...    
    ADD  r  1  t1    
    
    
    MOV  t1  rv    
    RETURN    
    
    
Variable  addresses                        New  instruc?ons  used  
                                           popq  r:  pops  top  of  stack,  and  stores  it  to  reg  r  
                                           ret:  pops  the  return  address  and  jumps  to  it  
  
  
                                                                                                                                      22  

L11.pdf:                                      Method  ac<va<on  and  return  
  Source  code  
 int  p(int  a,  int  b)  {  
    int  r;  
    ...  
    return  r+1  
 }  
 3  address  code                   Assembly  code  
 p:                                     p:                                          #  Label  for  p  
    START      pushq  %rbp                      #  Push  the  dynamic  link  
      movq  %rsp,  %rbp            #  Set  the  new  frame  pointer  
    SPACE  2      subq  $16  %rsp                #  Make  space  for  2  vars  and  temps  
    ...      ...  
    ADD  r  1  t1      movq  -­‐8(%rbp),  %rax    #  r  -­‐>  rax  
      addq  $1,  %rax                #  1  +  rax  -­‐>  rax  
      movq  %rax,  -­‐16(%rbp)  #  rax  -­‐>  t1  
    MOV  t1  rv      movq  -­‐16(%rbp),  %rax  #  t1  -­‐>  rax  
    RETURN      movq  %rbp,  %rsp            #  move  back  the  stack  pointer  
      popq  %rbp                        #  restore  the  frame  pointer  
      ret  
Variable  addresses                                   New  instruc?ons  used  
  a          16(%rbp)                         popq  r:  pops  top  of  stack,  and  stores  it  to  reg  r  
  b          24(%rbp)                         ret:  pops  the  return  address  and  jumps  to  it  
  r          -­‐8(%rbp)  
  t1      -­‐16(%rbp)  
                                                                                                                                                                23  

L11.pdf:                                     Summary  ques<ons  
•  What  is  the  diﬀerence  between  intermediate  code  and  assembly  code?  
•  Men<on  two  kinds  of  typical  intermediate  code.  When  are  they  useful?  
•  Why  is  it  not  meaningful  to  minimze  the  number  of  temporaries  in  
   intermediate  code?  
•  What  is  register  alloca<on?  
•  Given  a  source  program,  sketch  intermediate  three  address  code.  
•  Given  a  source  program,  sketch  x86  assembly  code.  
                                                                                                          24  

L12.pdf:  EDAN65:  Compilers,  Lecture  12  
More  on  code  genera>on  
             Görel  Hedin  
          Revised:  2015-­‐10-­‐06  

L12.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac>c  analyzer  
                                                                                                   garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 AQribute                                                                                         heap  
                   Seman>c  analyzer  
 grammar
 objects  
                                            AQributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op>mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L12.pdf:                                             Genera>ng  code  
                                 AST                                                                  Assembly  code  
Source  code                                  Intermediate  code  
    movq  16(%rbp),  %rax  
    ADD  a  b  t1    addq  24(%rbp),  %rax  
 c  =  a  +  b  
    MOV  t1  c    movq  %rax,  -­‐24(%rbp)  
    movq  -­‐24(%rbp),  -­‐8(%rbp)  
    
  Intermediate  code:  
  •  Where  most  op>miza>ons  are  done  
  Assembly  code:  
  •  For  given  machine,  opera>ng  system,  assembler,  and  calling  conven>ons  
  In  assignment  6  
  •  Generate  AT&T  assembly  code  for  x86-­‐64,  using  simple  calling  conven>ons  
  •  No  intermediate  code  –  we  generate  the  assembly  code  directly  from  the  AST.               3  

L12.pdf:                                                                      AT&T  x86-­‐64  assembly  code  
 Source  code                                                                                                                              stack  grows  
void  m(int  a,  int  b)  {  
    int  c,  d;                                                                                                          lower  
    ...                                                                                                                    addresses  
    c  =  a  +  b  
    ...  
}  
                                                                                                                                    rsp           t1  
                                                                                                                                                    d  
Assembly  code                                                                                                                                   c  
m:                                        #  Label  for  the  method  
                                                                                                                                    rbp        dynlink  
    pushq  %rbp                    #  Push  the  dynamic  link  
    movq  %rsp,  %rbp          #  Set  the  new  frame  pointer                                                    retaddr  
    subq  $24,  %rsp            #  Make  room  on  stack  for  c,  d,  t1  
    ...  
                                                                                                                                                     a  
    movq  16(%rbp),  %rax    #  a  -­‐>  rax                               b  
    addq  24(%rbp),  %rax              #  b  +  rax  -­‐>  rax                                                    ...  
    movq  %rax,  -­‐24(%rbp)            #  rax  -­‐>  t1                                                             dynlink  
    movq  -­‐24(%rbp),  -­‐8(%rbp)    #  t1  -­‐>  c  
    ...  
  
    movq  %rbp,  %rsp          #  Move  back  the  stack  pointer                                   higher  
    popq  %rbp                      #  Restore  the  frame  pointer                        addresses  
    ret                                  #  Return  to  the  calling  method  
                                                                                                                                                             4  

L12.pdf:     Genera>ng  code  for  diﬀerent  constructs  
Expression  evalua:on,  using  temporaries,  local  variables,  formal  arguments  
  
Method  call,  passing  arguments  and  return  values  
  
Method  ac:va:on  and  return,  se_ng  up  a  new  frame,  restoring  it  
  
Control  structures,  labels  and  branching  
                                                                                                    5  

L12.pdf:                                                                        Explicit  temps  
  (like  in  previous  lecture)  
 Source  code                                                              Main  idea:  
a  =  b  *  (c  +  d)                                            •  Each  opera>on  puts  its  result  in  a  new  temp    
  
                                                                               Code  genera>on  for  binary  opera>on:  
Variable  addresses                                                        •  generate  code  for  le`  op  (result  at  some  address)  
a            -­‐8(%rbp)                                          •  generate  code  for  right  op  (result  at  some  address)  
b          -­‐16(%rbp)  
c          -­‐24(%rbp)                                             •  move  le`  op  to  %rax  
d          -­‐32(%rbp)                                             •  perform  opera>on  on  right  op  and  %rax  
t1        -­‐40(%rbp)                                                •  move  %rax  into  new  temp  
t2        -­‐48(%rbp)  
                                                                                                               Code  genera>on  for  assignment:  
x86  assembly  code,  explicit  temps                                                                •  generate  code  for  right-­‐hand  side  
    movq    -­‐24(%rbp),  %rax                #  c  -­‐>  rax                       (result  at  some  address)  
    addq    -­‐32(%rbp),  %rax                #  d  +  rax  -­‐>  rax    •  move  result  to  le`  var  
    movq    %rax,            -­‐40(%rbp)      #  rax  -­‐>  t1  
    movq    -­‐16(%rbp),  %rax                #  b  -­‐>  rax  
    imulq  -­‐40(%rbp),  %rax                #  t1  *  rax  -­‐>  rax      Code  genera>on  for  IdUse:  
    movq    %rax,            -­‐48(%rbp)      #  rax  -­‐>  t2               •  No  code  needed.  
    movq    -­‐48(%rbp),  -­‐8(%rbp)        #  t2  -­‐>  a  
                                                                                                                                                                  6  

L12.pdf:                                                                                       Stacking  of  temps  
                                                                                        an  alterna>ve  to  explicit  temps  
 Source  code  
a  =  b  *  (c  +  d)                                                                         Main  idea:  
                                                                                                            •  each  expression  puts  its  result  in  rax  
  
Variable  addresses                                                                                     Code  genera>on  for  binary  opera>on  
a            -­‐8(%rbp)                                                                       •  generate  code  for  le`  op  (result  in  rax)  
b          -­‐16(%rbp)  
c          -­‐24(%rbp)  
                                                                                                            •  push  rax  
d          -­‐32(%rbp)                                                                          •  generate  code  for  right  op  (result  in  rax)  
                                                                                                            •  pop  le`  op  into  rbx  
                                                                                                            •  op  rbx  rax  (result  in  rax)  
x86  assembly  code,  temps  on  stack                                                                             Code  genera>on  for  assignment:  
    movq    -­‐16(%rbp),  %rax          #  b  -­‐>  rax  
                                                                                                                               •  generate  code  for  right-­‐hand  side  
    pushq  %rax                                #  push  rax                              (result  in  rax)  
    movq    -­‐24(%rbp),  %rax          #  c  -­‐>  rax                                            •  move  rax  to  le`  var  
    pushq  %rax                                #  push  rax    
    movq    -­‐32(%rbp),  %rax          #  d  -­‐>  rax  
    popq    %rbx                                #  pop  rbx                      Code  genera>on  for  IdUse:  
    addq    %rbx,            %rax          #  rbx  +  rax  -­‐>  rax                 •  move  value  into  rax  
    popq    %rbx                                #  pop  rbx  
    imulq  %rbx,            %rax          #  rbx  *  rax  -­‐>  rax  
    movq  %rax,              -­‐8(%rbp)  #  rax  -­‐>  a  
                                                                                                                                                                                   7  

L12.pdf:                                Explicit  or  stacked  temps?  
Code  genera>on  is  simpler  for  stacked  temps  –  we  don't  need  to  
compute  addresses  for  temps.  
  
But:  to  generate  code  for  method  calls,  we  need  to  evaluate  the  
arguments  from  right  to  le`,  to  push  them  in  the  appropriate  order  on  
the  stack.  Not  all  languages  allow  this.  
  
If  evalua>ng  the  arguments  have  side  eﬀects,  the  evalua>on  order  can  
make  a  diﬀerence.  
  
Some  languages,  like  Java,  deﬁne  the  evalua>on  order  on  arguments  
from  le`  to  right.  
  
In  assignment  6,  we  will  use  stacked  temps.  (For  SimpliC  it  is  ok  to  
evaluate  the  arguments  from  right  to  le`.)  
                                                                                                                8  

L12.pdf:                            Example  code  genera>on  
aspect  CodeGeneration  {  
    public  void  Program.genCode(PrintStream  s)  {  
        ...  
    }  
  
    public  void  Add.genCode(PrintStream  s)  {  
        getLeft().genCode(s);    
        s.println("pushq  %rax");  
        getRight().genCode(s);  
        s.println("popq  %rbx");  
        s.println("addq  %rbx,  %rax");  
    }  
  
    ...  
  
    public  void  IdUse.genCode(PrintStream  s)  {  
        s.println("movq  "  +  decl().address()  +  ",  %rax");  
    }  
  
    ...  
  
}  
                                                                                        9  

L12.pdf:                         Genera>ng  code  from  the  AST  
Deﬁne  suitable  node  proper>es,  using  aQributes,  to  make  the  code  genera>on  easy.  
  
Then  write  the  code  genera>on  as  a  recursive  method,  prin>ng  the  code  to  a  ﬁle.  
  
What  proper>es  do  we  need?  
•  The  address  of  each  variable  declara>on,  for  example  "-­‐8(%rbp)".  
•  The  number  of  local  variables  of  a  method  (to  reserve  space  on  the  stack).  
•  The  address  of  each  formal  argument,  for  example,  "16(%rbp)".  
•  Unique  labels  for  each  control  structure.  
                                                                                                                              10  

L12.pdf:                       Compu>ng  addresses  of  declara>ons  
                                                            using  aQributes  
      Main  idea:  
      •  Enumerate  the  variable  declara>ons  inside  each  func>on,  giving  them  
             local  indexes:  1,  2,  ...  
      •  Transla>ng  to  the  address  is  then  simple:  "-­‐8(%rbp)",  "-­‐16(%rbp)",  ...    
                                 Func>onDecl  
                                                List  
                                                                                                   How  can  locIndex  be  
                                                                                                   computed  using  aQributes?    
        VarDecl                         While                              VarDecl  
       locIndex  =  1                                                 locIndex  =  4  
                                                                                                   Impera>vely,  it  would  be  
                                                      Block                                      simple:  traverse  the  tree  in  
                                                                                                   preorder,  and  give  each  
                                                                                                   VarDecl  an  increasing  index.  
                                                         List  
 VarDecl                       Assign                          VarDecl                        Assign  
locIndex  =  2                                              locIndex  =  3  
                                                                                                                                                11  

L12.pdf:                             Compu>ng  locIndex  declara>vely  
Main  idea:  
•  Give  all  nodes  a  locIndex,  the  locIndex  of  the  latest  VarDecl  in  a  preorder  traversal.  
•  Normally  the  same  as  for  the  previous  node  in  the  traversal.  
•  But  0  for  the  root,  and  one  more  for  each  VarDecl.  
                                                                                       syn  int  ASTNode.locIndex();  
                                                                                       eq  ASTNode.locIndex()  =  prev().locIndex();  
                        Func>onDecl           locIndex=0                           eq  Program.locIndex()  =  0;  
                                                                                       eq  VarDecl.locIndex()  =  prev().locIndex()  +  1;  
                            List  
                                                                                                compu>ng  the  number  of  locals    
  VarDecl                While      locIndex=1                VarDecl                   syn  int  Func>onDecl.numLocals()  =    
locIndex  =  1                                            locIndex  =  4        last().locIndex();    
                            Block          locIndex=1  
                              List  
                                                                                                                But  how  are  prev()    and  
  VarDecl                    Assign              VarDecl                   Assign                       last()  deﬁned?  
                                                    locIndex  =  3     locIndex=3  
 locIndex  =  2        locIndex=2                                                                                                                  12  

L12.pdf:                      Compu>ng  prev  declara>vely  
Preorder  traversal:  Visit  the  nodes  in  the  order  A,  B,  C,  D,  E,  F,  G  
  
Each  node  n  has  
•  a  prev  aQribute,  the  previous  node  in  a  preorder  traversal.  
•  a  prev(i)  aQribute,  the  previous  node  before  traversing  the  i'th  child  of  n.  
•  a  last  aQribute,  the  last  aQribute  in  a  preorder  traversal  of  the  n  subtree.  
                      A                               inh  ASTNode  ASTNode.prev();  
  
                                                        eq  ASTNode.getChild(int  i).prev()  =  
          B                      E        prev(i);  
  
                                                        syn  ASTNode  ASTNode.prev(int  i)  =  
    C         D          F         G        i=0  ?  this  :  getChild(i-­‐1).last();    
  
                                                        syn  ASTNode  ASTNode.last()  =    
      prev(getNumChild());  
E.prev()  ==  A.prev(1)  ==  B.last()  ==  B.prev(2)  ==  D.last()  ==  D.prev(0)  ==  D  
                                                                                                                             13  

L12.pdf:                   Alterna>ve  solu>on  using  a  map  aQribute  
 •  Deﬁne  an  aQribute  
      syn  HashMap<VarDecl,  Integer>  FunctionDecl.localsMap();  
 •  Compute  it  by  traversing  the  func>on    with  a  method  
      void  addLocals(HashMap<VarDecl,  Integer>  map,  Counter  c)  ...  
 •  Use  the  Root  AQribute  paQern  to  give  each  VarDecl  access  to  the  map,  and  let  them  
     look  up  their  index.  
                                        Func>onDecl           localsMap<VarDecl,  Integer>  
                                                                                                         The  addLocals  method  is  
                                                                                                         impera>ve,  but  the  side  
                                              List                                                     eﬀects  do  not  escape  
                                                                                                         outside  the  localsMap  
                                                                                                         equa>on,  so  that  is  ok.  
                  VarDecl                 While                            VarDecl  
                 locIndex  =  1                                       locIndex  =  4  
                                                   Block  
                                                       List  
 VarDecl                              Assign                   VarDecl                       Assign  
locIndex  =  2                                              locIndex  =  3  
                                                                                                                                            14  

L12.pdf:                                          Compu>ng  unique  labels  
Main  idea:  
•  Give  each  statement  a  "pathname"  rela>ve  to  the  func>on.  
•  E.g.,  3_2  means  the  2nd  statement  in  the  3rd  statement  in  the  func>on.  
•  Generate  labels  like  m_3_2_whilestart  and  m_3_2_whileend  
void  m(int  a)  {                       m:  
    int  x  =  1;      ...  
    int  y;                              m_3_whilestart:  
    while  (a  >  x)  {      ...  
        y  =  a*2;                 m_3_2_ifend:  
        if  (y  >  3)  {      ...  
            ...                    m_3_whileend:  
        }      ...  
    }    
}  
     Compute  the  "pathnames"  in  a  similar  way  as  the  unique  
     variable  names  were  implemented  in  assignment  5.  
                                                                                                                  15  

L12.pdf:                                                    An  example  assembly  program                                                                    Generated  by:  
.global  _start                          #  global  segment  
.data                                            #  data  segment  (for  global  data)  
...  
.text                                            #  text  segment  (for  code,  write  protected)  
_start:                                        #  execution  starts  here                                         Program  
                call  fstart_main      #  call  the  main  program                                                                node  
                movq  %rax,  %rdi        #  use  the  result  as  the  exit  code  
                movq  $60,  %rax  
                syscall                        #  call  system  exit  
  
fstart_main:                              #  pushing  the  frame  for  the  main  function  
                pushq  %rbp  
                movq  %rsp,  %rbp  
                subq  $0,  %rsp  
                                                                                                                                                                FunctionDecl  
                ...                                #  the  code  of  the  main  function              node  
fend_main:                                  #  popping  the  frame  for  the  main  function  
                movq  %rbp,  %rsp  
                popq  %rbp  
                ret  
  
fstart_p:                                                                                                                                                     FunctionDecl  
                ...                                                                                                                                node  
fend_p:  
  
...  
                                                                                                                                                                             16  

L12.pdf:What  happens  a`er  compila>on?  memory  
                                                            p.s  
      source                                       assembly                                          activation
                            compiler                                                                                 stack  
       code
 code
 records  
                                p.o                                                          p  
                              object                                                    executable  
 assembler                                            linker                                           objects   heap  
                               code
 code

as  p.s  –o  p.o                             ld  p.o  –o  p  
                             library  
                           object  code
 static
                                                                                                          ...           data  
                                                                                                          0000 0001
                                                                                                          0176 0024
                                                                                                          0024 7050
  •  object  code  contains  global  symbols                                                    2530 0000
        and  relocatable  addresses                                                                 0000 0010     code  
                                                                                            loader      2444 5512
                                                                                                          0000 0010
  •  in  executable  code  global  symbols  and                                   ./p       ...
        relocatable  addresses  have  been  
        replaced  by  absolute  addresses  
                                                                                                          machine
                                                    EDAN65,  2014,  Lecture  01  
                                                                                                                          17  

L12.pdf:                                   Summary  ques>ons  
•  What  informa>on  needs  to  be  computed  before  genera>ng  code?  
•  How  do  explicit  temporaries  work?  How  do  stacked  temporaries  work?  What  
   are  the  advantages  and  disadvantages  of  these  implementa>on  techniques?  
•  How  can  local  variable  numbers  be  computed  using  aQributes?  
•  How  can  unique  labels  be  computed?  
•  What  is  the  diﬀerence  between  a  text  and  a  data  segment  in  an  assembly  
   program?  
•  What  needs  to  be  done  to  run  a  program  in  assembly  code?  
                                                                                                                     18  

L13.pdf:   EDAN65:  Compilers,  Lecture  13  
  Run;me  systems  for  
object-­‐oriented  languages  
           Görel  Hedin  
          Revised:  2015-­‐10-­‐12  

L13.pdf:     This  lecture  
                                                                              runtime system  
                                            source  code  (text)  
  Regular         Lexical  analyzer                                           activation
                                                                                                    stack  
expressions
 (scanner)                                                    records  
                                            tokens  
Context-­‐free   Syntac;c  analyzer  
                                                                                                   garbage
 grammar
 (parser)  
                                                                                                   collection  
                                            AST  (Abstract  syntax  tree)  
 ASribute                                                                                         heap  
                   Seman;c  analyzer  
 grammar
 objects  
                                            ASributed  AST  
                     Intermediate  
                                                                                    Interpreter

                    code  generator  
                                            intermediate  code                                   code
                                                                                       Virtual      and
                       Op;mizer                                                     machine
 data  
                                            intermediate  code  
                      Target  code  
                                                                                     machine
                       generator  
                                              target  code  
                                                                                                              2  

L13.pdf:           Some  inﬂuen;al  OO  languages  
dynamic  typing  
                                                                                    Self  
                                     Smalltalk  
           SIMULA                                                                                        Java  
                                                                     C++  
sta-c  typing  
                          1970                          1980                           1990                   2000  
Dynamic  typing  
At  run;me,  every  object  has  a  type  
  
Sta-c  typing  
At  run;me,  every  object  has  a  type.  
At  compile-­‐;me,  every  variable  has  a  type.  
At  run;me,  the  variable  points  to  an  object  of  at  least  that  type.                     3  

L13.pdf:Example  memory  segments  
     activations   stack  
       objects     heap  
                     global data  
                     code (read only)
                                      4  

L13.pdf:                   Typical  memory  usage  for  OO  languages  
activation –
data for a method instance                           Dedicated registers:  
                     stack                          SP – Stack Pointer (top of stack)  
                                 activations  
                                                      FP – Frame Pointer (start of current activation frame)  
objects –
data for a class instance  
                                                      HP – Heap Pointer (where to allocate next object)  
                     heap        objects  
global data –
                                 global data  
class descriptors, etc.  
code –
                                    code            PC – Program counter. The currently executing instruction.  
methods, constructors, etc.  
The figure shows typical use for statically loaded languages like Simula and C++. For languages with
dynamic loading (like Java, Smalltalk, ...), class descriptors and code are placed on the heap, rather
than in the global data and code segments.
To support threads, each thread has its own stack. Typical stack size: 1 MB. Typical heap size: 80 MB.  
                                                                                                                 5  

L13.pdf:                The  heap  
stack   heap  
            L
                                L     live object  
            L
                                      dead object  
            L
                                      pointer  
                                       root pointer  
                           Live objects are those
            L              reachable from root pointers.
                           Dead objects can be garbage
            L
                           collected.
                           Fragmentation: unused
                           memory inside the heap  
                                                         6  

L13.pdf:                                              Typical  layouts  
        activations                   objects      class descriptors   code of method  
              temps                     class               super    m:  
               vars      pushq  ...  
                                         GCinfo             method1      movq  ...  
             dynlink  
                                         ﬁeld1              method2      subq  ...  
             retaddr                   ﬁeld2                   ...      ...  
             statlink  
               args  
                                            ...            sta;c  var1  
              temps                                        sta;c  var2  
               vars                                              ...  
             dynlink  
                                                    An object
                                                    Has pointer to the class descriptor (for accessing methods).
A method activation
                                                    GCinfo is used by the garbage collector.
The static link ("this" pointer) is viewed as an
                                                    Can have fields that point to objects.
extra argument.
Uses static link to access fields and methods.
                                                    A class descriptor
Variables, args and temps can point to objects.
                                                    Can access super class through the super pointer.
                                                    Has pointers to its methods.
                                                    Can have static variables.                                  7  

L13.pdf:                                    Inheritance  of  ﬁelds,  preﬁxing  
          source code                   A-object                   B-object                C-object  
            class  A  {  
    int  fa1;             class                     class                          class  
    int  fa2;           GCinfo                     GCinfo                        GCinfo  
            }                                fa1                       fa1    from A  
                                                                                                            fa1     from A  
                                               fa2                       fa2                            fa2  
                                                                            a     from B                 a      from B  
 class  B  extends  A  {  
    int  fb;  
                                                                                                             fc     from C  
 }  
                                                                                       Field    addresses  
class  C  extends  B  {         Prefixing
    int  fc;                      Fields of the superclass are                  fa1      16(obj)  
}                                       placed in front of local fields               fa2      24(obj)  
                                          ("prefixing"). Each field is thus             fb        32(obj)  
                                          located at an offset computed at              fc        40(obj)  
                                          compile time, regardless of the
                                          dynamic type of the object.
                                                                                                                            8  

L13.pdf:                                     Access  to  ﬁelds  (single  inheritance)  
            source code  
  class  A  {  
    int  fa1;                                     m  frame  
                                                                                B  object  
    int  fa2;                                      temps  
                                                                                         class  
    void  m()  {                                     vars                                              The code for m knows the static
                                                                                      GCinfo  
        fa1  =  fa2;     %rbp             dynlink                                                type of the object (A), but not the
                                                                                           fa1  
        ...                                                                                              dynamic type (B or C in this case).
                                                            retaddr                      fa2  
    }  
                                                            statlink                       a  
  }                                                                                                                Because of prefixing, the code for
                                                                args  
                                                                                                                     m can access fa1 and fa2 through
                                                             temps  
                                                                                                                     an efficient indirect access, using
                                                                 vars          C  object                       a fixed offset, without knowing the
  class  B  extends  A  {                         dynlink  
                                                                                         class                     dynamic type of the object.
    int  fb;  
  }                                                       p  frame              GCinfo  
                                                                                           fa1  
                                                                                           fa2  
                                                                                             a  
 class  C  extends  B  {                                                           fc  
    int  fc;  
 }  
void  p(A  a)  {                    #  Example  code,  assuming  statlink  ("this")  is  at  16(%rbp):  
    a.m();                            A-­‐m:  
}      ...  
    movq  16(%rbp),  %rax          #  this  -­‐>  rax    
    movq  24(%rax),  16(%rax)  #  fa2  -­‐>  fa1                                           9  

L13.pdf:                  Access  to  ﬁelds  (mul;ple  inheritance,  C++)  
                     source code  
                                                                                                 C  object          C  descr  
class  A  {                    class  B  {  
                                                                       m  frame                class    
    int  fa1;      int  fb1;  
                                                                                                      fa1                   ...     interior
    int  fa2;      int  fb2;                  rA  
                                                                                                      fa2         pointer  
}                                  }                                    rB  
                                                                            rC                   class  
                                                                       dynlink                      a1  
                                                                                                                        B  descr  
                                                                                                      a2  
   class  C  extends  A,  B  {                                                             fc        subobject  
    int  fc;                                                                                                       ...  
   }    
                                                             Interior pointers and subobjects
           void  m()  {  
    A  rA  =  new  C();             Parts of the class hiearchy are treated like single inheritance:
    B  rB  =  rA;                     rA and rC point to the full C object.
    C  rC  =  rA;  
           }                                               For remaining parts, allocate subobjects inside the main object.
                                                             rB points to the interior of the C object, to the B subobject.
                                                             Gives problems for garbage collector:
                                                             The GC needs to identify full objects. Solvable, but expensive.
                                                                                                                                              10  

L13.pdf:                                          Dynamic  dispatch  
                          (Calling  methods  in  presence  of  inheritance  and  overriding)  
                                          A object                       A descr                      code  
           source code  
                                            class                           ...    A-­‐ma:  
 class  A  {  
                                               ...      ...  
    void  ma()  {    
        ...    
    }    
 }                                      B object                       B descr  
  
                                            class      B-­‐mb:  
                                                                              ...    ...  
                                               ...    
 class  B  extends  A  {      
    void  mb()  {    C-­‐ma:  
        ...    ...  
    }                                                              C descr  
 }                                      C object  
  
                                            class                           ...  
                                               ...    
class  C  extends  B  {  
    //  overrides  A.ma  
    void  ma()  {             Two common implementation methods:
        ...  
    }  
                                            - virtual tables (Uses static typing. Simula, C++)
}                                         - hash table (For dynamic typing. Smalltalk, ...)
                                                                                                                   11  

L13.pdf:           source code  
                                                     Virtual  tables  
                                                      Used  in  Simula,  C++,  ...  
 class  A  {  
    void  ma()  {                  A object                   A descr                     code  
        ...  
                                                  class                       super    A-­‐ma:  
    }  
 }                                                ...                        ma    ...  
  
  
                                                                           B descr    
 class  B  extends  A  {             B object    
    void  mb()  {  
                                                  class                       super    B-­‐mb:  
        ...    ...  
    }                                        ...                        ma  
  
 }                                                                             mb    
  C-­‐ma:  
  ...  
                                                                           C descr  
class  C  extends  B  {              C object  
    //  overrides  A.ma                                               super  
    void  ma()  {                       class                        ma  
        ...                               ...                        mb  
    }                                                                                    Method    addresses  
}  
                                                                                                ma      8(class)  
                  Virtual tables                                                                mb      16(class)  
                  Class descriptor contains virtual table (often called "vtable").
                  Pointers to superclass methods are placed in front of locally declared methods ("prefixing").
                  Each method pointer is located at an offset computed at compile time, using the static type.
                                                                                                                            12  

L13.pdf:                         Calling  a  method  via  the  virtual  table  
 class  A  {                                                                   A-object                                    A-descr                       code  
    void  ma()  {  
                                                                                                class                               super    A-­‐ma:  
        ...  
    }                         C-­‐ma       dynlink                                        ...                               ma    ...  
  
 }                                                retaddr    
                                                    statlink                                                                     B-descr    
                                        m         dynlink                          B-object    
 class  B  extends  A  {  
                                                                                                class                               super    B-­‐mb:  
    void  mb()  {                        retaddr    ...  
                                                                                                     ...                               ma  
        ...                                     a    
    }                                                                                                                             mb  
 }  
                                                    dynlink    
  C-­‐ma:  
                                                                                      C-object                                   C-descr    ...  
                                                                                                class                               super  
class  C  extends  B  {                                                                    ...                               ma  
    //  overrides  A.ma  
    void  ma()  {  
                                          Method call                                                                                    mb  
                                          Follow pointer to object.
        ...                     Follow pointer to class descriptor. Add offset for method.
    }                               Follow pointer to method.
}  
                                           m:    
    ...  
void  m(A  a)  {      movq  16(%rbp),  %rax        #  a  -­‐>  rax    
    a.ma();  
    pushq  %rax                          #  push  the  static  link  (this)  
}  
    movq  (%rax),  %rax            #  class  descriptor  -­‐>  rax  
    callq  8(%rax)                    #  call  ma                                                13  

L13.pdf:                     Dynamic  dispatch  through  hash  table  
 methods and vars have                                                            A  descr  
 no static types                                          A  object                                   code  
                                                                class           super    A-­‐s:  
 class  A  {  
    method  s()  {...}                                 ...           "s"  -­‐>    ...  
    method  t()  {...}                                                  "t"  -­‐>    
 }    
                                            m  
  
                                                            B  object         B  descr  
                                        dynlink    
                                        retaddr               class            super    A-­‐t:  
 class  B  extends  A  {    ...  
    method  t()  {...}       statlink                ...            "s"  -­‐>  
  
 }                                         r                                   "t"  -­‐>    
                                        dynlink           C  object         C  descr  
  C-­‐u:  
                                                                                                    ...  
class  C  {                                               class            super    
    method  u()  {...}                                  ...           "u"  -­‐>  
  
    method  s()  {...}    
                                                                                   "s"  -­‐>    C-­‐s:  
}  
  ...  
                                     Method call                                 hashtable  
                                     Follow pointer to object.
class  ...  {                  Follow pointer to class descriptor. Lookup method pointer in hashtable.
    method  m(r)  {  
        r.s();  
                                     Does not rely on static types.
    }  
                                     Can be used for dynamically typed languages.
}                                  Slow if not optimized.                                                          14  

L13.pdf:                 Comparison,  dynamic  dispatch  
Virtual  tables  
Can  implement  mul;ple  inheritance  by  adap;ng  preﬁxing,  
similarly  to  ﬁeld  access.  
Cannot  be  used  for  dynamically  typed  languages.  
Fast  calls  –  only  an  indirect  jump.  
  
Hash  tables  
No  problem  with  mul;ple  inheritance.  
Can  be  used  for  dynamically  typed  languages.  
Slow  calls  –  need  to  do  hash  table  lookup.  
  
                                                                             15  

L13.pdf:                 Op;miza;on  of  OO  languages  
Common  conven-onal  op-miza-on  techniques  (for  C):  
Inlining  (avoid  calls,  get  more  code  to  op;mize  over)  
Common  subexpression  elimina;on  
Move  loop  invariant  code  to  outside  of  the  loop  
  
Diﬃcult  to  op-mize  OO  with  conven-onal  techniques  
Many  small  methods  –  not  much  to  op;mize  in  each  
Virtual  methods  slower  to  call  
Virtual  methods  diﬃcult  to  inline  –  actual  method  not  known  un;l  run;me  
  
If  methods  could  be  inlined...  
...  we  could  save  the  expensive  calls  
...  we  would  get  larger  code  chunks  to  op;mize  over  
                                                                                                             16  

L13.pdf:     Approaches  to  op;miza;on  of  OO  code  
Sta-c  compila-on  approaches  
Analysis  of  complete  programs:  "whole  world  analysis"  
Find  methods  to  be  inlined.  Then  op;mize  further.  
Not  used  in  prac;ce:  cannot  be  used  with  dynamic  loading.  
  
Dynamic  compila-on  approaches  
Inline  methods  at  run;me  (self-­‐modifying  code)  
Dynamic  compila;on  and  op;miza;on  (at  run;me)  
Use  simple  conven;onal  op;miza;on  techniques  
(must  be  fast  enough  at  run;me)  
Very  successful  in  prac;ce  (Java,  CLR,  Javascript,  ...)  
Can  beat  op;mized  C  for  some  benchmarks.  
                                                                                         17  

L13.pdf:     Other  important  op;miza;ons  in  OO  
Dynamic  type  tests  (casts,  instanceOf)  
  
Synchroniza-on  and  thread  switches  
  
Garbage  collec-on  
                                                       18  

L13.pdf:       Interpreta;on  vs  Compila;on  in  Java  
Interpre-ng  JVM  
portable  but  slow  
  
JIT  –  Just-­‐In-­‐Time  compila-on  
compile  each  method  to  machine  code  the  ﬁrst  ;me  it  is  executed  
requires  very  fast  compila;on  –  no  ;me  to  op;mize  
  
AOT  –  Ahead-­‐of-­‐-me  compila-on  
Generate  machine  code  for  a  complete  program,  before  execu;on.  This  is  
"normal"  compila;on,  the  way  it  is  done  in  C,  C++,  ...  
Problem  to  use  this  approach  for  Java:  cannot  support  dynamic  loading.  
  
Adap-ve  op-mizing  compiler  
Run  interpreter  ini;ally  to  get  proﬁling  data  
Find  "hot  spots"  which  are  translated  to  machine  code,  and  then  op;mized  
May  outperform  AOT  compilers  in  some  cases!  
The  approach  used  today  in  the  SUN/Oracle  JVM,  called  "HotSpot".  
                                                                                                              19  

L13.pdf:                                              Inline  call  caches  
                      a  way  to  op;mize  method  calls  at  run;me  
       Based  on  hash  table  lookup  
       Do  a  normal  (slow)  lookup.  Finds  method,  say  Bus-­‐m.  
       Guess  that  the  next  call  will  be  for  an  object  of  the  same  type  (Bus),  i.e.,  to  Bus-­‐m.  
       Replace  the  method  call  with  a  direct  call  to  Bus-­‐m,  with  the  receiver  as  argument.  
       Add  a  prologue  to  the  method,  Bus-­‐m-­‐prologue,  that  checks  if  the  argument  is  of  the  
       guessed  type  (Bus).  
       If  not,  do  a  normal  (slow)  lookup.  
Original  calling  code                                             Op;mized  calling  code  
Vehicle  v  =  ...;                                               Vehicle  v  =  ...;  
while  (...)  {                          op;mize                  while  (...)  {  
    v  =  aList.get();      v  =  aList.get();  
    v.m();      Bus-­‐m-­‐prologue(v);  
}                                                                       }  
              Vehicle                                                   Called  method:  
                                                                          Bus-­‐m-­‐prologue:  
  if  (receiver  is  not  a  Bus)  
        receiver.m();  //  Ordinary  slow  lookup  
Bus             Truck         Car                                   Bus-­‐m:  
    normal  method  body  
    ...  
                                                                                                                                                       20  

L13.pdf:                             Polymorphic  inline  caches  (PICs)  
                                     a  generaliza;on  of  inline  call  caches                                   Vehicle  
                 Handle  several  possible  object  types  
                 Inline  the  prologues  into  the  calling  code.  
                 Check  for  several  types.                                                                  Bus        Truck   Car  
                                                                                   Polymorphic  inlined  cache  
                                                                                   Vehicle  v  =  ...;  
Inlined  call  cache                                                         while  (...)  {  
    v  =  aList.get();  
Vehicle  v  =  ...;      if  (v  is  a  Bus)  
while  (...)  {  
                                                             op;mize          Bus-­‐m(v)  
    v  =  aList.get();  
    else  if  (v  is  a  Car)  
    Bus-­‐m-­‐prologue(v);          Car-­‐m(v)  
}      else  
        v.m();  //  normal  lookup  
Called  method:                                                                }  
Bus-­‐m-­‐prologue:                                                              Called  methods:  
    if  (!receiver  is  a  Bus)  
        receiver.m();  //  normal  lookup                          Bus-­‐m:  
Bus-­‐m:      ...  
    normal  method  body                                                 Car-­‐m:  
    ...      ...  
                                                                                                                                               21  

L13.pdf:                                           Inlining  method  bodies  
                                           Can  be  done  aner  inlining  calls                                          Vehicle  
                 Inlining  method  bodies  
                 Copy  the  called  methods  into  the  calling  code  
                                                                                                                             Bus    Truck    Car  
Polymorphic  inlined  cache                                                       Polymorphic  inlined  cache  
Vehicle  v  =  ...;                                                             Vehicle  v  =  ...;  
while  (...)  {                                                                   while  (...)  {  
    v  =  aList.get();      v  =  aList.get();  
    if  (v  is  a  Bus)      if  (v  is  a  Bus)  
        Bus-­‐m(v)                                   op;mize          ...  //  code  for  Bus-­‐m  
    else  if  (v  is  a  Car)      else  if  (v  is  a  Car)  
        Car-­‐m(v)          ...  //  code  for  Car-­‐m  
    else      else  
        v.m();  //  normal  lookup          v.m();  //  normal  lookup  
}                                                                                     }  
Called  methods:                                                                    Methods:  
Bus-­‐m:                                                                              Bus-­‐m:  
    ...      ...  
Car-­‐m:                                                                              Car-­‐m:  
    ...      ...  
                                                                                                                                                   22  

L13.pdf:                                                Further  op;miza;on  
                                                                                                                                              Vehicle  
                 Now  there  is  a  large  code  chunk  at  the  calling  site  
                 Ordinary  op;miza;ons  can    now  be  done  
                 -­‐  common  subexpression  elimina;on                                                                         Bus    Truck    Car  
                 -­‐  loop  invariant  code  mo;on  
                 -­‐  ...  
Polymorphic  inlined  cache                                                                Polymorphic  inlined  cache  
Vehicle  v  =  ...;                                                                      Vehicle  v  =  ...;  
while  (...)  {                                                                            while  (...)  {  
    v  =  aList.get();      v  =  aList.get();  
    if  (v  is  a  Bus)      if  (v  is  a  Bus)  
        Bus-­‐m(v)                                      op;mize          ...  //  code  for  Bus-­‐m  
    else  if  (v  is  a  Car)      else  if  (v  is  a  Car)  
        Car-­‐m(v)          ...  //  code  for  Car-­‐m  
    else      else  
        v.m();  //  normal  lookup          v.m();  //  normal  lookup  
}                                                                                              }  
Called  methods:                                                                             Methods:  
Bus-­‐m:                                                                                       Bus-­‐m:  
    ...      ...  
Car-­‐m:                                                                                       Car-­‐m:  
    ...      ...  
                                                                                                                                                            23  

L13.pdf:     Dynamic  adap;ve  compila;on  
Keep  track  of  execu-on  proﬁle  
  
Add  PICs  dynamically  
Order  cases  according  to  frequency  
Inline  the  called  methods  if  suﬃciently  frequent  
Op;mize  the  code  if  suﬃciently  frequent  
  
Adapt  the  op-miza-ons  depending  on  current  proﬁle  
  
                                                                        24  

L13.pdf:                          Dynamic  adap;ve  compila;on  
Techniques  originated  in  the  Smalltalk  and  Self  compiler  
  
Adapted  to  Java  in  SUN/Oracle's  HotSpot  JVM  
Techniques  originally  developed  for  dynamically  typed  languages  useful  also  for  
sta;cally  typed  languages!  
Dynamic  adap;ve  op;miza;ons  may  outperform  op;miza;ons  possible  in  a  sta;c  
compiler!  
  
Client  vs  Server  compiler  
Local  op;miza;ons  vs  heavy  inlining  and  other  memory  intensive  op;miza;ons.  
  
Warm-­‐up  vs.  Steady  state  
Slower  when  the  program  starts  (warm-­‐up).  Fast  aner  a  while  (steady-­‐state).  
  
A  huge  success:  
Fast  execu;on  in  spite  of  fast  compila;on  and  dynamic  loading.  
Now  used  in  other  major  languages  like  C#  (CLR  plaporm),  Javascript,  etc.  
Many  languages  compile  to  Java  Bytecode  to  take  advantage  of  the  HotSpot  JVM.  
                                                                                                                      25  

L13.pdf:  Major  advances  in  OO  implementa;on  
dynamic  typing  
                                                              PICs  
                      inline  call  caches              Self  
                             Smalltalk  
                                                                                                    V8  
                                                                                               (JavaScript)  
    SIMULA                                                              Java  
   preﬁxing                                                                      HotSpot  
    vtables                                         C++  
sta-c  typing  
                    1970                   1980              1990               2000               2010  
                                                                                                             26  

L13.pdf:                                          Summary  ques;ons  
•  What  is  the  diﬀerence  between  dynamic  and  sta;c  typing?  
•  Is  Java  sta;cally  typed?  
•  What  is  a  heap  pointer?  
•  How  are  inherited  ﬁelds  represented  in  an  object?  
•  What  is  preﬁxing?  
•  How  can  dynamic  dispatch  be  implemented?  
•  What  is  a  virtual  table?  
•  Why  is  it  not  straighporward  to  op;mize  object-­‐oriented  languages?  
•  What  is  an  inline  call  cache?  
•  What  is  a  polymorphic  inline  cache  (PIC)?  
•  How  can  code  be  further  op;mized  when  call  caches  are  used?  
•  What  is  meant  by  dynamic  adap;ve  compila;on?  
                                                                                                    27  

L14.pdf:     EDAN65:  Compilers,  Lecture  14  
Review  of  important  concepts  
                  Görel  Hedin  
                 Revised:  2015-­‐10-­‐12  

L14.pdf:     Course  overview  
                                                                                            runtime system  
                                                          source  code  (text)  
  Regular         A1          Lexical  analyzer                                           activation
                                                                                                                  stack  
expressions
 (scanner)                                                    records  
                                                          tokens  
Context-­‐free   A1,  A2   SyntacGc  analyzer  
                                                                                                                 garbage
 grammar
 (parser)  
                                                                                                                 collection  
                                                          AST  (Abstract  syntax  tree)  
 AQribute        A3,  A4                                                                                    heap  
                                 SemanGc  analyzer  
 grammar
 objects  
                                                          AQributed  AST  
                                   Intermediate  
                                                             A5                                 Interpreter

                                  code  generator  
                                                          intermediate  code                                   code
                                                                                                     Virtual      and
                                     OpGmizer                                                     machine
 data  
                                                          intermediate  code  
                                    Target  code  
                                                             A6                                  machine
                                     generator  
                                                            target  code  
                                                                                                                            2  

L14.pdf:  Regular  expressions  and  scanning  
                   NFA                                                                  DFA  
                               f                                                    ID                f  
                         2                   3     IF                                  2,4                        3,4     IF  
         i                                                                    i  
                                                                                                     a-­‐eg-­‐z  
   1                                                                  1  
               a-­‐z                                                                                                          a-­‐z  
                                     a-­‐z                                                                    a-­‐z  
                                                                              a-­‐hj-­‐z  
                                      4       ID                                                             4        ID  
Given  some  informal  descripGon,  formulate  a  regular  expression  or  automaton.  
Translate  between  regular  expressions,  NFAs,  DFAs.  
Know  how  to  combine  automata  represenGng  tokens.  
Know  how  to  handle  rule  priority  and  longest  match.  
                                                                                                                                           3  

L14.pdf:                        Context-­‐free  grammars  
         Exp  -­‐>  Exp  "+"  Exp  
         Exp  -­‐>  Exp  "*"  Exp  
         Exp  -­‐>  INT  
Given  some  informal  descripGon,  formulate  a  language  as  a  context-­‐free  grammar.  
  
The  elements  of  a  context-­‐free  grammar  G=(N,  T,  P,  S):  
nonterminal  symbols,  terminal  symbols,  producGons,  start  symbol  
  
Understand  what  the  language  deﬁned  by  a  grammar  is.  
Understand  the  diﬀerence  between  regular  expressions  and  context-­‐free  grammars.  
                                                                     Exp  
                                                                     =>  Exp  "+"  Exp  
                                                                     =>  INT  "+"  Exp  
                                                                     ...  
DerivaGons.  How  to  prove  that  a  sentence  belongs  to  a  language.  
Parse  trees.  How  a  parse  tree  corresponds  to  a  derivaGon.                              4  

L14.pdf:                                                           LL  Parsing  
        CompoundStmt  
                    IfStmt                         Understand  the  main  idea  of  how  LL  parsing  works  
               Id              Assign  
                                                     Understand  the  concepts  of  FIRST,  Nullable,  and  FOLLOW.  
                                                     Be  able  to  compute  them  for  a  given  
                                                     nonterminal  in  a  grammar.  
...  if  ID  then  ID  =  ID  ;  ID  ...  
Be  able  to  construct  a  recursive-­‐descent  parser  for  a  given  LL(1)  grammar.  
  
Understand  what  lea  recursion  and  common  preﬁx  mean.  
Understand  why  grammars  with  these  properGes  are  not  LL(1).  
Be  able  to  transform  such  a  grammar  to  an  equivalent  LL(1)  grammar.  
                                                                                                                                  5  

L14.pdf:                 AmbiguiGes  in  context-­‐free  grammars  
                              Exp                                                        Exp    
                Exp     "+"            Exp                               Exp    "*"   Exp    
                INT                                                                                    INT  
                                Exp    "*"   Exp                Exp    "+"   Exp    
                                INT                 INT               INT              INT  
Understand  what  it  means  for  a  grammar  to  be  ambiguous.  
Understand  what  it  means  for  two  grammars  to  be  equivalent.  
  
Be  able  to  prove  that  a  grammar  is  ambiguous  for  common  ambiguiGes  (expressions  
and  dangling  else).  
  
Be  able  to  transform  an  ambiguous  grammar  to  an  equivalent  unambiguous  grammar,  
for  common  ambiguiGes.  
                                                                                                                        6  

L14.pdf:                     NotaGons  for  context-­‐free  grammars  
         A  -­‐>  B  d  e  C  f                                  Canonical  form  
         A  -­‐>  g  A  
         C  -­‐>  D  a  b  |  b  E  F  |  a  C       BNF  
         G  -­‐>  H*  i  |  (d  E)+  F  |  [d  C]      EBNF  
Be  able  to  formulate  grammars  on  canonical  form,  as  BNF,  and  EBNF  
Be  able  to  translate  between  these  forms.  
                                                                                                       7  

L14.pdf:                                                Abstract  grammars  
Abstract  grammar  
abstract  Stmt;  
IfStmt  :  Stmt  ::=  Expr  Stmt;  
Assignment  :  Stmt  ::=  IdUse  Expr;  
IdUse  :  Expr  ::=  <ID:String>;  
Understand  the  diﬀerence  between  an  abstract  grammar  and  a  context-­‐free  grammar.  
  
Understand  how  an  abstract  grammar  corresponds  to  an  object-­‐oriented  model.  
Be  able  to  design  an  abstract  grammar  for  a  simple  language,  corresponding  to  a  good  
object-­‐oriented  model.  
  
Be  able  to  design  a  high-­‐level  (possibly  ambiguous)  concrete  grammar  that  is  very  close  
to  an  abstract  grammar.  
                                                                                                                                     8  

L14.pdf:                                                      LR  parsing                                  Id                 Assign  
                                                                                                                                  Id  
                                                                                                                              Id  
Understand  the  main  idea  of  how  LR  parsing  works  
with  shia,  reduce,  and  accept  acGons.  
                                                                                        ...  if  ID  then  ID  =  ID  ;  ID  ...  
Understand  why  LR  is  more  powerful  than  LL.  
  
  
Understand  what  an  LR  item  is.  
Understand  what  an  LR  state  is.  
                                                                                                         E  -­‐>  E  •  "+"  E  ?  
  
                                                                                                         E  -­‐>  E  "*"  E  •  "+"  
Understand  what  an  LR  conﬂict  is.  
For  a  given  LR  conﬂict,  be  able  to  construct  a  program  
that  would  expose  the  conﬂict  (for  a  simple  case).  
I  will  not  ask  you  to  construct  an  LR  DFA  or  an  LR  parsing  table  on  the  exam.  
                                                                                                                                                      9  

L14.pdf:          StaGc  aspects  with  intertype  declaraGons  
aspect  Evaluator  {  
    abstract  int  Expr.value();  
    int  Add.value()  {  return  getLea().value()  +  getRight().value();  }  
    int  Sub.value()  {  return  getLea().value()  –  getRight().value();  }  
    int  IntExpr.value()  {  return  String.parseInt(getINT());  }  
}  
Understand  how  staGc  aspect-­‐oriented  programming  with  
inter-­‐type  declaraGons  works.  
  
Be  able  to  program  problems  using  methods  declared  in  aspects.  
                                                                                                   10  

L14.pdf:                                                        Visitors  
accept(new  PrintVisitor())                                    visitAdd(this)  
                                            Add  
                                                                                                 PrintVisitor  
                                 IntExp              IntExp  
                                                                           visitIntExp(this)  
 Understand  how  the  visitor  paQern  works.  
  
 Be  able  to  program  problems  using  visitors.  
                                                                                                                  11  

L14.pdf:                          Reference  aQribute  grammars  
                                                                                              A  
               inh  int  B.i();  
               eq    A.getB().i()  =  2;  
                                                                                   B              C  
                                                                              i  =  2  
Understand  how  reference  aQribute  grammars  work,  with  diﬀerent  kinds  of  aQributes:  
synthesized,  inherited,  parameterized,  NTAs,  circular,  and  collecGon  aQributes.  
  
Be  able  to  program  problems  using  reference  aQribute  grammars.  
You  don't  have  to  memorize  details  in  the  JastAdd  syntax  –  
copies  of  the  JastAdd  reference  manual  will  be  available  at  the  exam.  
                                                                                                                     12  

L14.pdf:        RunGme  systems  and  code  generaGon  
                    Understand  how  an  acGvaGon  stack  works,  with  frame  
                    pointer,  stack  pointer,  and  dynamic  link.  
  
rsp               Understand  simple  calling  convenGons,  like  passing  
           t1  
           d      arguments  on  the  stack  and  the  return  value  in  a  register.  
  
            c  
        dynlink   Be  able  to  write  down  pseudo  assembly  code  for  
rbp  
                    procedure  calls,  procedure  acGvaGon  and  returns,  and  
        retaddr   simple  computaGons  like  loops,  assignments,  expression  
            a     evaluaGon,  etc.  
           b    
           ...    Be  able  to  draw  the  contents  of  the  stack  for  a  given  
        dynlink   execuGon  point  in  a  program.  
                    You  don't  have  to  memorize  x86  instrucGons.  
                                                                                                                 13  

L14.pdf:         RunGme  systems  for  object-­‐oriented  languages  
   activation                         object                  class descriptor       code of method  
          args                           class                         super    m:  
    pushq  ...  
        statlink                        GCinfo                        method1      movq  ...  
        dynlink                          ﬁeld1                        method2      subq  ...  
        retaddr                          ﬁeld2                           ...      ...  
          vars                             ...                       staGc  var1  
         temps                                                         staGc  var2  
                                                                             ...  
Understand  the  role  of  the  staGc  link  ("this"  pointer).  
Understand  how  preﬁxing  works  for  single  inheritance  of  ﬁelds.  
Understand  how  vtables  work  for  single  inheritance  dynamic  dispatch.  
Have  an  overall  idea  about  how  dynamic  adapGve  compilaGon  works.  
You  don't  have  to  memorize  how  to  handle  mulGple  inheritance.  
                                                                                                                      14  

L14.pdf:     Preparing  for  the  exam  
Read  slides,  book,  papers,  lab  descripGons.  
Do  the  exercises  and  the  quizzes.  
Study  old  exams.  
  
See  hQp://cs.lth.se/edan65/material/    
  
Ask  at  the  forum  if  you  have  quesGons!  
  
  
  
Don't  forget  to  sign  up  for  the  exam  by  2015-­‐Oct-­‐18,  at  student.lu.se  
(Because  of  the  new  procedure  for  anonymized  exam  assessment)  
  
                                                                                                               15  

